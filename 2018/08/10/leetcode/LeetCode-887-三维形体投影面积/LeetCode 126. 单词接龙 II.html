<!-- build time:Tue Aug 14 2018 15:43:50 GMT+0800 (CST) --><hr><p>title: LeetCode 126. 单词接龙 II<br>date: 2018-08-14 13:37:30<br>tags: leetcode</p><h2 id="categories-leetcode"><a href="#categories-leetcode" class="headerlink" title="categories: leetcode"></a>categories: leetcode</h2><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典 <em>wordList</em>，找出所有从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回一个空列表。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><pre><code>输入:
beginWord = &quot;hit&quot;,
endWord = &quot;cog&quot;,
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]

输出:
[
  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],
  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]
]
</code></pre><p><strong>示例 2:</strong></p><pre><code>输入:
beginWord = &quot;hit&quot;
endWord = &quot;cog&quot;
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]

输出: []

解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。
</code></pre><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这道题与127题单词接龙和433题基因变化相似，区别就在与，我们需要保存路径的前向节点，最后遍历一遍，就得到结果了</p><p>​ 换个思路解决问题，首先来构建一个结构，每一个都保存这当前值的前向节点</p><p>分两步来做</p><ul><li><p>首先，将数组进行转换</p><pre><code class="lang-python">d = collections.defaultdict(list)
        wordList.append(beginWord)
        for word in wordList:
            for i in range(len(word)):
                s = word[:i] + &quot;_&quot; + word[i + 1:]
                d[s] += [word]
</code></pre><pre><code># 经过上面的变换，得到下面的结果
defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;l_g&#39;: [&#39;log&#39;], &#39;d_g&#39;: [&#39;dog&#39;], &#39;_og&#39;: [&#39;dog&#39;, &#39;log&#39;, &#39;cog&#39;], &#39;l_t&#39;: [&#39;lot&#39;], &#39;do_&#39;: [&#39;dot&#39;, &#39;dog&#39;], &#39;ho_&#39;: [&#39;hot&#39;], &#39;co_&#39;: [&#39;cog&#39;], &#39;hi_&#39;: [&#39;hit&#39;], &#39;h_t&#39;: [&#39;hot&#39;, &#39;hit&#39;], &#39;_it&#39;: [&#39;hit&#39;], &#39;lo_&#39;: [&#39;lot&#39;, &#39;log&#39;], &#39;d_t&#39;: [&#39;dot&#39;], &#39;c_g&#39;: [&#39;cog&#39;], &#39;_ot&#39;: [&#39;hot&#39;, &#39;dot&#39;, &#39;lot&#39;]})
</code></pre></li><li><p>然后，将前向节点字典生成出来</p><pre><code class="lang-python">pre = collections.defaultdict(set)
        for _, value in d.items():
            for i in value:
                pre[i] = pre[i].union(set(value))
                pre[i].remove(i)
</code></pre><pre><code>defaultdict(&lt;class &#39;set&#39;&gt;, {&#39;dog&#39;: {&#39;log&#39;, &#39;dot&#39;, &#39;cog&#39;}, &#39;log&#39;: {&#39;dog&#39;, &#39;lot&#39;, &#39;cog&#39;}, &#39;lot&#39;: {&#39;hot&#39;, &#39;log&#39;, &#39;dot&#39;}, &#39;hot&#39;: {&#39;lot&#39;, &#39;dot&#39;, &#39;hit&#39;}, &#39;dot&#39;: {&#39;dog&#39;, &#39;hot&#39;, &#39;lot&#39;}, &#39;hit&#39;: {&#39;hot&#39;}, &#39;cog&#39;: {&#39;dog&#39;, &#39;log&#39;}})
</code></pre></li><li><p>这样，我们就能够利用树的性质，进行层次遍历，需要注意的就是，已经访问过的节点不能继续访问，不然会产生回环，因此，需要保存一下访问过的路径</p><p>这样，我们就能够从endword开始，向前寻找beginword，找到以后，就加入到结果集中</p></li></ul><p>​ 这个思路可以，不过最后是在127题的解题思路上修改了一下，如下</p><p>​ 如果能够正向的找到endword，那么我们在重新反向找到beginword，就得到路径了，下面就是基于这个思路来做的：</p><ul><li><p>首先，将数组进行变换，同前面一样</p></li><li><p>然后，利用两个set，一个是访问过，一个是未访问过，然后进行层次遍历</p><p>在遍历的过程中，建立一个字典，前向节点的字典，方便我们根据这个字典，回溯路径</p></li></ul><p>如果层次遍历无法得到，最后直接返回[]</p><p>如果第一次找到了，我们就跳出来，根据前向节点的字典，进行路径回溯，然后加入到结果集中</p><pre><code class="lang-python">class Solution:
    def findLadders(self, beginWord, endWord, wordList):
        &quot;&quot;&quot;
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: List[List[str]]
        &quot;&quot;&quot;

        if endWord not in wordList:
            return []

        d = collections.defaultdict(list)
        for word in wordList:
            for i in range(len(word)):
                s = word[:i] + &quot;_&quot; + word[i + 1:]
                d[s] += [word]

        path_node = set()

        visited = set([beginWord])
        temp = set()
        not_visited = set(wordList)

        pre = collections.defaultdict(set)

        pop_item = set()
        count = 0
        while visited:
            for i in visited:
                for j in range(len(i)):
                    s = i[:j] + &quot;_&quot; + i[j + 1:]
                    temp = temp.union(set(d[s]))
                    for w in d[s]:
                        path_node.add(w)
                        if i != w:
                            pre[w].add(i)
                    pop_item.add(s)

            for p in pop_item:
                d.pop(p)
            pop_item.clear()

            if len(temp) == 0:
                return []
            count += 1
            if endWord in temp:
                break

            not_visited = not_visited - temp
            visited = temp
            temp = set()

        ans = [[endWord]]
        temp_ans = []
        visited_path = set([endWord])
        for i in range(count):
            for path in ans:
                temp_next = pre[path[-1]] - visited_path
                for node in temp_next:
                    temp_ans.append(path.copy())
                    temp_ans[-1].append(node)
                visited_path.add(path[-1])
            ans = temp_ans
            temp_ans = []

        return [ list(reversed(x)) for x in ans if x[-1] == beginWord ]
</code></pre><!-- rebuild by neat -->