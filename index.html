<!-- build time:Fri Aug 17 2018 08:50:43 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0"><link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"6.3.0",sidebar:{position:"right",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"GBC1F47D02",apiKey:"",indexName:"myblog",hits:{per_page:10},labels:{input_placeholder:"请输入关键字",hits_empty:"未找到: ${query}",hits_stats:"${hits} 搜索用时 ${time} ms"}}}</script><meta name="description" content="天行健，君子以自强不息！"><meta name="keywords" content="Linux 技术 云计算 LeetCode"><meta property="og:type" content="website"><meta property="og:title" content="夜行"><meta property="og:url" content="https://www.aisky.men/index.html"><meta property="og:site_name" content="夜行"><meta property="og:description" content="天行健，君子以自强不息！"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="夜行"><meta name="twitter:description" content="天行健，君子以自强不息！"><link rel="canonical" href="https://www.aisky.men/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>夜行</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?03806bd68e029f12f863ba16efac2c2c";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-right page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">夜行</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home menu-item-active"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/17/leetcode/LeetCode 442. 数组中重复的数据/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/17/leetcode/LeetCode 442. 数组中重复的数据/" itemprop="url">LeetCode 442. 数组中重复的数据</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-17 08:45:20 / 修改时间：08:49:30" itemprop="dateCreated datePublished" datetime="2018-08-17T08:45:20+08:00">2018-08-17</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/17/leetcode/LeetCode 442. 数组中重复的数据/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/17/leetcode/LeetCode 442. 数组中重复的数据/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定一个整数数组 a，其中1 ≤ a[i] ≤ <em>n</em> （<em>n</em>为数组长度）, 其中有些元素出现<strong>两次</strong>而其他元素出现<strong>一次</strong>。</p><p>找到所有出现<strong>两次</strong>的元素。</p><p>你可以不用到任何额外空间并在O(<em>n</em>)时间复杂度内解决这个问题吗？</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这道题与448题基本一致，区别就在于一个找重复的，一个找消失的，思路都是一样的</p><ul><li>首先，遇到一个元素k，我们就判断这个元素对应的下标a[k-1]是不是负数，如果是，加入结果数组中，并将这个元素变成正数</li><li>遍历到头即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            i = abs(i)</span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                ans.append(i)</span><br><span class="line"></span><br><span class="line">            nums[i<span class="number">-1</span>] = -nums[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>​ 只要理清思路，就会变得非常简单。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/16/leetcode/LeetCode 873. 最长的斐波那契子序列的长度/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/16/leetcode/LeetCode 873. 最长的斐波那契子序列的长度/" itemprop="url">LeetCode 873. 最长的斐波那契子序列的长度</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-16 20:55:40 / 修改时间：21:05:23" itemprop="dateCreated datePublished" datetime="2018-08-16T20:55:40+08:00">2018-08-16</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/16/leetcode/LeetCode 873. 最长的斐波那契子序列的长度/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/16/leetcode/LeetCode 873. 最长的斐波那契子序列的长度/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式</em> 的：</p><ul><li><code>n &gt;= 3</code></li><li>对于所有 <code>i + 2 &lt;= n</code>，都有 <code>X_i + X_{i+1} = X_{i+2}</code></li></ul><p>给定一个<strong>严格递增</strong>的正整数数组形成序列，找到 <code>A</code> 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。</p><p><em>（回想一下，子序列是从原序列 A 中派生出来的，它从 A 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</em></p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7,8]</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">最长的斐波那契式子序列为：[1,2,3,5,8] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,7,11,12,14,18]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">最长的斐波那契式子序列有：</span><br><span class="line">[1,11,12]，[3,11,14] 以及 [7,11,18] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= A.length &lt;= 1000</code></li><li><code>1 &lt;= A[0] &lt; A[1] &lt; ... &lt; A[A.length - 1] &lt;= 10^9</code></li><li><em>（对于以 Java，C，C++，以及 C# 的提交，时间限制被减少了 50%）</em></li></ul><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 直接看到这道题，首先能想到下面的解法</p><ul><li>从第一个元素开始，第一个元素与第二个元素之和，是否存在，如果存在，顺着当前序列判断下去</li><li>然后第一个元素与第三个元素之和，是否存在，如果存在，继续判断下去</li><li>经过这样的判断，确实能够得到答案，但是时间复杂度是<script type="math/tex">O(n^3)</script>，所以不太符合要求</li></ul><p>​ 这样的题目，可以考虑使用动态规划，利用前面已经计算的结果来做</p><ul><li>建立一个字典，默认值是0，键则用两个数字组成的元组</li><li>当我们判断两个数字的时候，看看是不是形成了斐波那契序列，如果是，就保存到字典中，键为起那两个数字所形成的斐波那契数列值加1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        buff = collections.defaultdict(int)</span><br><span class="line">        s = set(A)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> A[i] - A[j] &lt; A[j] <span class="keyword">and</span> A[i] - A[j] <span class="keyword">in</span> s:</span><br><span class="line">                    buff[(A[i], A[j])] = buff.get((A[j], A[i] - A[j]), <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, buff[(A[i], A[j])])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/16/leetcode/LeetCode 436. 寻找右区间/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/16/leetcode/LeetCode 436. 寻找右区间/" itemprop="url">LeetCode 436. 寻找右区间</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-16 19:30:30 / 修改时间：20:59:06" itemprop="dateCreated datePublished" datetime="2018-08-16T19:30:30+08:00">2018-08-16</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/16/leetcode/LeetCode 436. 寻找右区间/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/16/leetcode/LeetCode 436. 寻找右区间/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定一组区间，对于每一个区间 i，检查是否存在一个区间 j，它的起始点大于或等于区间 i 的终点，这可以称为 j 在 i 的“右侧”。</p><p>对于任何区间，你需要存储的满足条件的区间 j 的最小索引，这意味着区间 j 有最小的起始点可以使其成为“右侧”区间。如果区间 j 不存在，则将区间 i 存储为 -1。最后，你需要输出一个值为存储的区间值的数组。</p><p><strong>注意:</strong></p><ol><li>你可以假设区间的终点总是大于它的起始点。</li><li>你可以假定这些区间都不具有相同的起始点。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2] ]</span><br><span class="line">输出: [-1]</span><br><span class="line"></span><br><span class="line">解释:集合中只有一个区间，所以输出-1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [3,4], [2,3], [1,2] ]</span><br><span class="line">输出: [-1, 0, 1]</span><br><span class="line"></span><br><span class="line">解释:对于[3,4]，没有满足条件的“右侧”区间。</span><br><span class="line">对于[2,3]，区间[3,4]具有最小的“右”起点;</span><br><span class="line">对于[1,2]，区间[2,3]具有最小的“右”起点。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,4], [2,3], [3,4] ]</span><br><span class="line">输出: [-1, 2, -1]</span><br><span class="line"></span><br><span class="line">解释:对于区间[1,4]和[3,4]，没有满足条件的“右侧”区间。</span><br><span class="line">对于[2,3]，区间[3,4]有最小的“右”起点。</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 题目的大意很简单，就是对于当前区间，找出整个数组中在这个区间右面的那个区间的最小索引值</p><p>​ 一般的思路是将左边界与索引值放入数组，然后将遍历每一个区间，判断大于当前区间的右边界的值的最小索引，这个过程可以通过二分法来判断，因为左边界不相同，所以判断也很简单</p><p>​ 不过，直接考虑使用堆栈来做，更简单一些</p><ul><li>将左边界与索引值作为元组放入数组中，然后建堆</li><li>将右边界与索引值作为元组放入数组中，然后建堆</li></ul><p>接着，我们就遍历一遍，就能够直接得到结果了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRightInterval</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(intervals)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        ans = [<span class="number">0</span>] * length</span><br><span class="line"></span><br><span class="line">        left = [(value.start, index) <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(intervals)]</span><br><span class="line">        right = [(value.end, index) <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(intervals)]</span><br><span class="line"></span><br><span class="line">        heapq.heapify(left)</span><br><span class="line">        heapq.heapify(right)</span><br><span class="line"></span><br><span class="line">        left_count = <span class="number">0</span></span><br><span class="line">        left_temp = heapq.heappop(left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            right_temp = heapq.heappop(right)</span><br><span class="line">            <span class="keyword">while</span> left_count &lt; length:</span><br><span class="line">                <span class="keyword">if</span> left_temp[<span class="number">0</span>] &gt;= right_temp[<span class="number">0</span>]:</span><br><span class="line">                    ans[right_temp[<span class="number">1</span>]] = left_temp[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left_count += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> left_count &lt; length:</span><br><span class="line">                        left_temp = heapq.heappop(left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[right_temp[<span class="number">1</span>]] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>​ 这样写比较简单，哈哈</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/15/leetcode/LeetCode 435. 无重叠区间/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/15/leetcode/LeetCode 435. 无重叠区间/" itemprop="url">LeetCode 435. 无重叠区间</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-15 21:04:00 / 修改时间：21:05:29" itemprop="dateCreated datePublished" datetime="2018-08-15T21:04:00+08:00">2018-08-15</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/15/leetcode/LeetCode 435. 无重叠区间/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/15/leetcode/LeetCode 435. 无重叠区间/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>注意:</strong></p><ol><li>可以认为区间的终点总是大于它的起点。</li><li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这道题的关键就是利用贪心法，每一次，将跨越区域最多的删除，然后更新其他区间跨越的区间数量，然后继续更新</p><p>关键点在于，如何有效率的找出相互区间之前的重叠</p><ul><li>首先，我们按照区间左边界进行排序</li><li>我们判断当前区间和前面的区间关系，如果当前区间的左边界，小于前面区间的右边界，肯定是要删除一个，消除重叠，这时候，我们判断，这两个区间，那个区间的右边界比较小，我们挑选小的按个，删除另一个，因为右边界更小，表示向后重叠的机会就越小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        intervals = sorted(intervals,key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[pre].end &gt; intervals[i].start:</span><br><span class="line">                pre = i <span class="keyword">if</span> intervals[pre].end &gt; intervals[i].end <span class="keyword">else</span> pre</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = i</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/14/leetcode/LeetCode 888. 两句话中的不常见单词/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/14/leetcode/LeetCode 888. 两句话中的不常见单词/" itemprop="url">LeetCode 888. 两句话中的不常见单词</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-14 15:40:00 / 修改时间：15:41:23" itemprop="dateCreated datePublished" datetime="2018-08-14T15:40:00+08:00">2018-08-14</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/14/leetcode/LeetCode 888. 两句话中的不常见单词/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/14/leetcode/LeetCode 888. 两句话中的不常见单词/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定两个句子 <code>A</code> 和 <code>B</code> 。 （<em>句子</em>是一串由空格分隔的单词。每个<em>单词</em>仅由小写字母组成。）</p><p>如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是<em>不常见的</em>。</p><p>返回所有不常用单词的列表。</p><p>您可以按任何顺序返回列表。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot;</span><br><span class="line">输出：[&quot;sweet&quot;,&quot;sour&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = &quot;apple apple&quot;, B = &quot;banana&quot;</span><br><span class="line">输出：[&quot;banana&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 200</code></li><li><code>0 &lt;= B.length &lt;= 200</code></li><li><code>A</code> 和 <code>B</code> 都只包含空格和小写字母。</li></ol><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这道题是简单题，哈哈（简单题好简单）</p><ul><li>首先使用哈希统计出两个句子的单词数量</li><li>将句子1中出现1次，并且不在句子2中的单词放入结果数组</li><li>将句子2中出现1次，并且不在句子1中的单词放入结果数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uncommonFromSentences</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        count_A = collections.Counter(A.split(<span class="string">" "</span>))</span><br><span class="line">        count_B = collections.Counter(B.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">        ans += [x <span class="keyword">for</span> x <span class="keyword">in</span> count_A <span class="keyword">if</span> count_A[x] == <span class="number">1</span> <span class="keyword">and</span> x <span class="keyword">not</span> <span class="keyword">in</span> count_B]</span><br><span class="line">        ans += [x <span class="keyword">for</span> x <span class="keyword">in</span> count_B <span class="keyword">if</span> count_B[x] == <span class="number">1</span> <span class="keyword">and</span> x <span class="keyword">not</span> <span class="keyword">in</span> count_A]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/14/leetcode/LeetCode 126. 单词接龙 II/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/14/leetcode/LeetCode 126. 单词接龙 II/" itemprop="url">LeetCode 126. 单词接龙 II</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-14 13:37:30 / 修改时间：13:37:53" itemprop="dateCreated datePublished" datetime="2018-08-14T13:37:30+08:00">2018-08-14</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/14/leetcode/LeetCode 126. 单词接龙 II/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/14/leetcode/LeetCode 126. 单词接龙 II/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典 <em>wordList</em>，找出所有从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回一个空列表。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: []</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这道题与127题单词接龙和433题基因变化相似，区别就在与，我们需要保存路径的前向节点，最后遍历一遍，就得到结果了</p><p>​ 换个思路解决问题，首先来构建一个结构，每一个都保存这当前值的前向节点</p><p>分两步来做</p><ul><li><p>首先，将数组进行转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = collections.defaultdict(list)</span><br><span class="line">        wordList.append(beginWord)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                s = word[:i] + <span class="string">"_"</span> + word[i + <span class="number">1</span>:]</span><br><span class="line">                d[s] += [word]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 经过上面的变换，得到下面的结果</span><br><span class="line">defaultdict(&lt;class &apos;list&apos;&gt;, &#123;&apos;l_g&apos;: [&apos;log&apos;], &apos;d_g&apos;: [&apos;dog&apos;], &apos;_og&apos;: [&apos;dog&apos;, &apos;log&apos;, &apos;cog&apos;], &apos;l_t&apos;: [&apos;lot&apos;], &apos;do_&apos;: [&apos;dot&apos;, &apos;dog&apos;], &apos;ho_&apos;: [&apos;hot&apos;], &apos;co_&apos;: [&apos;cog&apos;], &apos;hi_&apos;: [&apos;hit&apos;], &apos;h_t&apos;: [&apos;hot&apos;, &apos;hit&apos;], &apos;_it&apos;: [&apos;hit&apos;], &apos;lo_&apos;: [&apos;lot&apos;, &apos;log&apos;], &apos;d_t&apos;: [&apos;dot&apos;], &apos;c_g&apos;: [&apos;cog&apos;], &apos;_ot&apos;: [&apos;hot&apos;, &apos;dot&apos;, &apos;lot&apos;]&#125;)</span><br></pre></td></tr></table></figure></li><li><p>然后，将前向节点字典生成出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pre = collections.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> _, value <span class="keyword">in</span> d.items():</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> value:</span><br><span class="line">                pre[i] = pre[i].union(set(value))</span><br><span class="line">                pre[i].remove(i)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultdict(&lt;class &apos;set&apos;&gt;, &#123;&apos;dog&apos;: &#123;&apos;log&apos;, &apos;dot&apos;, &apos;cog&apos;&#125;, &apos;log&apos;: &#123;&apos;dog&apos;, &apos;lot&apos;, &apos;cog&apos;&#125;, &apos;lot&apos;: &#123;&apos;hot&apos;, &apos;log&apos;, &apos;dot&apos;&#125;, &apos;hot&apos;: &#123;&apos;lot&apos;, &apos;dot&apos;, &apos;hit&apos;&#125;, &apos;dot&apos;: &#123;&apos;dog&apos;, &apos;hot&apos;, &apos;lot&apos;&#125;, &apos;hit&apos;: &#123;&apos;hot&apos;&#125;, &apos;cog&apos;: &#123;&apos;dog&apos;, &apos;log&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>这样，我们就能够利用树的性质，进行层次遍历，需要注意的就是，已经访问过的节点不能继续访问，不然会产生回环，因此，需要保存一下访问过的路径</p><p>这样，我们就能够从endword开始，向前寻找beginword，找到以后，就加入到结果集中</p></li></ul><p>​ 这个思路可以，不过最后是在127题的解题思路上修改了一下，如下</p><p>​ 如果能够正向的找到endword，那么我们在重新反向找到beginword，就得到路径了，下面就是基于这个思路来做的：</p><ul><li><p>首先，将数组进行变换，同前面一样</p></li><li><p>然后，利用两个set，一个是访问过，一个是未访问过，然后进行层次遍历</p><p>在遍历的过程中，建立一个字典，前向节点的字典，方便我们根据这个字典，回溯路径</p></li></ul><p>如果层次遍历无法得到，最后直接返回[]</p><p>如果第一次找到了，我们就跳出来，根据前向节点的字典，进行路径回溯，然后加入到结果集中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                s = word[:i] + <span class="string">"_"</span> + word[i + <span class="number">1</span>:]</span><br><span class="line">                d[s] += [word]</span><br><span class="line"></span><br><span class="line">        path_node = set()</span><br><span class="line"></span><br><span class="line">        visited = set([beginWord])</span><br><span class="line">        temp = set()</span><br><span class="line">        not_visited = set(wordList)</span><br><span class="line"></span><br><span class="line">        pre = collections.defaultdict(set)</span><br><span class="line"></span><br><span class="line">        pop_item = set()</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> visited:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(i)):</span><br><span class="line">                    s = i[:j] + <span class="string">"_"</span> + i[j + <span class="number">1</span>:]</span><br><span class="line">                    temp = temp.union(set(d[s]))</span><br><span class="line">                    <span class="keyword">for</span> w <span class="keyword">in</span> d[s]:</span><br><span class="line">                        path_node.add(w)</span><br><span class="line">                        <span class="keyword">if</span> i != w:</span><br><span class="line">                            pre[w].add(i)</span><br><span class="line">                    pop_item.add(s)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> pop_item:</span><br><span class="line">                d.pop(p)</span><br><span class="line">            pop_item.clear()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> len(temp) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> endWord <span class="keyword">in</span> temp:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            not_visited = not_visited - temp</span><br><span class="line">            visited = temp</span><br><span class="line">            temp = set()</span><br><span class="line"></span><br><span class="line">        ans = [[endWord]]</span><br><span class="line">        temp_ans = []</span><br><span class="line">        visited_path = set([endWord])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">            <span class="keyword">for</span> path <span class="keyword">in</span> ans:</span><br><span class="line">                temp_next = pre[path[<span class="number">-1</span>]] - visited_path</span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> temp_next:</span><br><span class="line">                    temp_ans.append(path.copy())</span><br><span class="line">                    temp_ans[<span class="number">-1</span>].append(node)</span><br><span class="line">                visited_path.add(path[<span class="number">-1</span>])</span><br><span class="line">            ans = temp_ans</span><br><span class="line">            temp_ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [ list(reversed(x)) <span class="keyword">for</span> x <span class="keyword">in</span> ans <span class="keyword">if</span> x[<span class="number">-1</span>] == beginWord ]</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/14/leetcode/LeetCode 433. 最小基因变化/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/14/leetcode/LeetCode 433. 最小基因变化/" itemprop="url">LeetCode 433. 最小基因变化</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-14 10:20:30 / 修改时间：13:36:42" itemprop="dateCreated datePublished" datetime="2018-08-14T10:20:30+08:00">2018-08-14</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/14/leetcode/LeetCode 433. 最小基因变化/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/14/leetcode/LeetCode 433. 最小基因变化/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 <code>&quot;A&quot;</code>, <code>&quot;C&quot;</code>, <code>&quot;G&quot;</code>, <code>&quot;T&quot;</code>中的任意一个。</p><p>假设我们要调查一个基因序列的变化。<strong>一次</strong>基因变化意味着这个基因序列中的<strong>一个</strong>字符发生了变化。</p><p>例如，基因序列由<code>&quot;AACCGGTT&quot;</code> 变化至 <code>&quot;AACCGGTA&quot;</code>即发生了一次基因变化。</p><p>与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。</p><p>现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。</p><p><strong>注意:</strong></p><ol><li>起始基因序列默认是合法的，但是它并不一定会出现在基因库中。</li><li>所有的目标基因序列必须是合法的。</li><li>假定起始基因序列与目标基因序列是不一样的。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start: &quot;AACCGGTT&quot;</span><br><span class="line">end:   &quot;AACCGGTA&quot;</span><br><span class="line">bank: [&quot;AACCGGTA&quot;]</span><br><span class="line"></span><br><span class="line">返回值: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start: &quot;AACCGGTT&quot;</span><br><span class="line">end:   &quot;AAACGGTA&quot;</span><br><span class="line">bank: [&quot;AACCGGTA&quot;, &quot;AACCGCTA&quot;, &quot;AAACGGTA&quot;]</span><br><span class="line"></span><br><span class="line">返回值: 2</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start: &quot;AAAAACCC&quot;</span><br><span class="line">end:   &quot;AACCCCCC&quot;</span><br><span class="line">bank: [&quot;AAAACCCC&quot;, &quot;AAACCCCC&quot;, &quot;AACCCCCC&quot;]</span><br><span class="line"></span><br><span class="line">返回值: 3</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这道题跟127题很相似,直接应该使用广度优先搜索来做，直接使用127提的解法就可以</p><p>举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start: &quot;AACCGGTT&quot;</span><br><span class="line">end:   &quot;AACCGGTA&quot;</span><br><span class="line">bank: [&quot;AACCGGTA&quot;]</span><br><span class="line">首先，我们将bank进行建模</span><br><span class="line">&#123;&quot;AACCGGT_&quot;:[&quot;AACCGGTA&quot;]&#125;</span><br><span class="line">然后，设置两个set()，visited和not_visited</span><br><span class="line">利用这两个set进行广度优先遍历</span><br><span class="line">首先，对于visited中的每一个元素，我们改变一位，判断是不是在bank里面出现，如果出现了，就放到temp中</span><br><span class="line">然后，判断temp中是否还有元素，如果没有，表示找不到了，返回-1</span><br><span class="line">如果有元素，继续判断，判断end是不是出现在temp中，如果出现了，返回计数，没有出现，返回第一步，继续判断</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMutation</span><span class="params">(self, start, end, bank)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type start: str</span></span><br><span class="line"><span class="string">        :type end: str</span></span><br><span class="line"><span class="string">        :type bank: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> gene <span class="keyword">in</span> bank:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gene)):</span><br><span class="line">                s = gene[:i] + <span class="string">"_"</span> + gene[i + <span class="number">1</span>:]</span><br><span class="line">                d[s] = d.get(s, []) + [gene]</span><br><span class="line"></span><br><span class="line">        visited = set([start])</span><br><span class="line">        temp = set()</span><br><span class="line">        not_visited = set(bank)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> visited:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(i)):</span><br><span class="line">                    s = i[:j] + <span class="string">"_"</span> + i[j + <span class="number">1</span>:]</span><br><span class="line">                    temp = temp.union(set(d.get(s, [])))</span><br><span class="line">                    d.pop(s, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> len(temp) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end <span class="keyword">in</span> temp:</span><br><span class="line">                <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">            not_visited = not_visited - temp</span><br><span class="line">            visited = temp</span><br><span class="line">            temp = set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/13/leetcode/LeetCode 430. Flatten a Multilevel Doubly Linked List/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/13/leetcode/LeetCode 430. Flatten a Multilevel Doubly Linked List/" itemprop="url">LeetCode 430. Flatten a Multilevel Doubly Linked List</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-13 16:49:40 / 修改时间：16:49:29" itemprop="dateCreated datePublished" datetime="2018-08-13T16:49:40+08:00">2018-08-13</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/13/leetcode/LeetCode 430. Flatten a Multilevel Doubly Linked List/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/13/leetcode/LeetCode 430. Flatten a Multilevel Doubly Linked List/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.</p><p>Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"> 1---2---3---4---5---6--NULL</span><br><span class="line">         |</span><br><span class="line">         7---8---9---10--NULL</span><br><span class="line">             |</span><br><span class="line">             11--12--NULL</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1-2-3-7-8-11-12-9-10-4-5-6-NULL</span><br></pre></td></tr></table></figure><p><strong>Explanation for the above example:</strong></p><p>Given the following multilevel doubly linked list:</p><p><img src="https://leetcode-cn.com/static/images/problemset/MultilevelLinkedList.png" alt="img"></p><p>We should return the following flattened doubly linked list:</p><p><img src="https://leetcode-cn.com/static/images/problemset/MultilevelLinkedListFlattened.png" alt="img"></p><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 可以使用深度优先搜索，也可以不是用，首先来剖析一下问题</p><p>​ 这道题与前面114题很相似，如果当前的节点有子节点，该如何做呢？</p><p>​ 将剩下的节点，挂到子节点的末尾，然后，将当前节点的next指向子节点，子节点的prev指向当前节点即可，然后节点后移，继续判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.child:</span><br><span class="line">                head_next = head.next</span><br><span class="line">                temp = head.child</span><br><span class="line">                <span class="keyword">while</span> temp.next:</span><br><span class="line">                    temp = temp.next</span><br><span class="line">                temp.next = head_next</span><br><span class="line">                head_next.prev = temp</span><br><span class="line"></span><br><span class="line">                head.next = head.child</span><br><span class="line">                head.child.prev = head</span><br><span class="line">                head.child = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>​ 思路很简单，但是通过了19个测试用了，下一个超时了，因此，要考虑如何提高效率</p><p>​ 考虑在展开的过程中，不直接将下一个元素挂到子列的尾部，而是保存到栈中，等到遍历到最后的时候，就将栈中的元素取出来，接到尾部，然后继续判断即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val, prev, next, child):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.prev = prev</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.child = child</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = head</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> head:</span><br><span class="line">                prev = head</span><br><span class="line">                <span class="keyword">if</span> head.child:</span><br><span class="line">                    <span class="keyword">if</span> head.next:</span><br><span class="line">                        stack.append(head.next)</span><br><span class="line">                    head.next = head.child</span><br><span class="line">                    head.child.prev = head</span><br><span class="line">                    head.child = <span class="keyword">None</span></span><br><span class="line">                head = head.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = stack.pop()</span><br><span class="line">                prev.next = temp</span><br><span class="line">                temp.prev = prev</span><br><span class="line">                head = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>​ 这样，仅需要从头到尾遍历一遍即可得出结果</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/13/leetcode/LeetCode: 424. 替换后的最长重复字符/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/13/leetcode/LeetCode: 424. 替换后的最长重复字符/" itemprop="url">LeetCode 424. 替换后的最长重复字符</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-13 09:30:00 / 修改时间：09:30:27" itemprop="dateCreated datePublished" datetime="2018-08-13T09:30:00+08:00">2018-08-13</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/13/leetcode/LeetCode: 424. 替换后的最长重复字符/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/13/leetcode/LeetCode: 424. 替换后的最长重复字符/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 <em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p><strong>注意:</strong><br>字符串长度 和 <em>k</em> 不会超过 104。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ABAB&quot;, k = 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">用两个&apos;A&apos;替换为两个&apos;B&apos;,反之亦然。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;AABABBA&quot;, k = 1</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">将中间的一个&apos;A&apos;替换为&apos;B&apos;,字符串变为 &quot;AABBBBA&quot;。</span><br><span class="line">子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这个问题可以使用滑动窗口来做</p><ul><li>首先判断length&lt;=k+1? 是的话，直接返回length，不是的话，继续判断</li><li>初始的窗口大小设置为k+1，这样的话，肯定能替换出来</li><li>然后统计一下窗口内的字符的数量，找出最大的那个数量m</li><li>判断，如果窗口大小-m&lt;=k,窗口右指针向右移动</li><li>同样继续判断，窗口大小-m&gt;窗口左指针向右移动</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">characterReplacement</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> length &lt;= k + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line">        ans = k + <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = k + <span class="number">1</span></span><br><span class="line">        count = collections.Counter(s[start:end])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start &lt; length:</span><br><span class="line">            most = count.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> end - start - most &lt;= k:</span><br><span class="line">                ans = max(ans, end - start)</span><br><span class="line">                <span class="keyword">if</span> end &lt; length:</span><br><span class="line">                    count[s[end]] += <span class="number">1</span></span><br><span class="line">                    end += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            count[s[start]] -= <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/12/leetcode/LeetCode 423. 从英文中重建数字/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/12/leetcode/LeetCode 423. 从英文中重建数字/" itemprop="url">LeetCode 423. 从英文中重建数字</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-12 19:01:00 / 修改时间：19:02:01" itemprop="dateCreated datePublished" datetime="2018-08-12T19:01:00+08:00">2018-08-12</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/12/leetcode/LeetCode 423. 从英文中重建数字/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/12/leetcode/LeetCode 423. 从英文中重建数字/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定一个<strong>非空</strong>字符串，其中包含字母顺序打乱的英文单词表示的数字<code>0-9</code>。按升序输出原始的数字。</p><p><strong>注意:</strong></p><ol><li>输入只包含小写英文字母。</li><li>输入保证合法并可以转换为原始的数字，这意味着像 “abc” 或 “zerone” 的输入是不允许的。</li><li>输入字符串的长度小于 50,000。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;owoztneoer&quot;</span><br><span class="line"></span><br><span class="line">输出: &quot;012&quot; (zeroonetwo)</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;fviefuro&quot;</span><br><span class="line"></span><br><span class="line">输出: &quot;45&quot; (fourfive)</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 首先来分析下每个数字的英文组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zero</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br><span class="line">six</span><br><span class="line">seven</span><br><span class="line">eight</span><br><span class="line">nine</span><br></pre></td></tr></table></figure><p>​ 根据上面的字符，我们发现，一共出现了下面几个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;n&apos;, &apos;o&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;z&apos;]</span><br></pre></td></tr></table></figure><p>​ 其中，仅仅在某一个数字中出现的有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z: zero</span><br><span class="line">w: two</span><br><span class="line">u: four</span><br><span class="line">x: six</span><br><span class="line">g: eight</span><br></pre></td></tr></table></figure><p>​ 因此，根据这几个字符的数量，我们就能够直接判断上面几个数字的数量</p><p>并且，有了上面几个数字以后，我们就可以判断机器的数字了，例如1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one </span><br><span class="line">在所有数字中，包含o的只有0，1，2，4，而我们已经得到0，2，4的数量，就可以直接算出1的数量了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">three</span><br><span class="line">r仅仅出现在zero，four，同样的也能够计算出3的数量了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">five</span><br><span class="line">f仅仅出现在four，five，也可以计算出5的数量了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seven</span><br><span class="line">v仅仅出现在five，seven中，利用v直接计算7</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nine</span><br><span class="line">其他数字都已经计算出来了，剩下的9，利用n来计算也可以，i也可以，e也可以，用n的计算量比较小，因为n仅出现在one，seven，nine中</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">originalDigits</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">zero</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        buff = collections.defaultdict(zero)</span><br><span class="line">        nums = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            buff[c] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        nums[<span class="number">0</span>] = buff[<span class="string">'z'</span>]</span><br><span class="line">        nums[<span class="number">2</span>] = buff[<span class="string">'w'</span>]</span><br><span class="line">        nums[<span class="number">4</span>] = buff[<span class="string">'u'</span>]</span><br><span class="line">        nums[<span class="number">6</span>] = buff[<span class="string">'x'</span>]</span><br><span class="line">        nums[<span class="number">8</span>] = buff[<span class="string">'g'</span>]</span><br><span class="line">        nums[<span class="number">1</span>] = buff[<span class="string">'o'</span>] - nums[<span class="number">0</span>] - nums[<span class="number">2</span>] -nums[<span class="number">4</span>]</span><br><span class="line">        nums[<span class="number">3</span>] = buff[<span class="string">'r'</span>] - nums[<span class="number">0</span>] - nums[<span class="number">4</span>]</span><br><span class="line">        nums[<span class="number">5</span>] = buff[<span class="string">'f'</span>] - nums[<span class="number">4</span>]</span><br><span class="line">        nums[<span class="number">7</span>] = buff[<span class="string">'v'</span>] - nums[<span class="number">5</span>]</span><br><span class="line">        nums[<span class="number">9</span>] = buff[<span class="string">'i'</span>] - nums[<span class="number">5</span>] - nums[<span class="number">6</span>] - nums[<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">        ans = [str(i) * n <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums)]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(ans)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="夜行"><p class="site-author-name" itemprop="name">夜行</p><p class="site-description motion-element" itemprop="description">天行健，君子以自强不息！</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">411</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zhishengqianjun123" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:zhishengqianjun@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">夜行</span></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv" title="总访客量"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv" title="总访问量"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!1,notify:!1,appId:"qluXerUVutA7CjS8IgGYE7wg-gzGzoHsz",appKey:"kkrJimHdrtGVpP0goHXGtGDW",placeholder:"Just go go",avatar:"mm",meta:guest,pageSize:"10",visitor:!1})</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script></body></html><!-- rebuild by neat -->