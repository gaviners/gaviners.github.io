<!-- build time:Tue Aug 21 2018 14:27:51 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0"><link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"6.3.0",sidebar:{position:"right",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"GBC1F47D02",apiKey:"",indexName:"myblog",hits:{per_page:10},labels:{input_placeholder:"请输入关键字",hits_empty:"未找到: ${query}",hits_stats:"${hits} 搜索用时 ${time} ms"}}}</script><meta name="description" content="天行健，君子以自强不息！"><meta name="keywords" content="Linux 技术 云计算 LeetCode"><meta property="og:type" content="website"><meta property="og:title" content="夜行"><meta property="og:url" content="https://www.aisky.men/page/2/index.html"><meta property="og:site_name" content="夜行"><meta property="og:description" content="天行健，君子以自强不息！"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="夜行"><meta name="twitter:description" content="天行健，君子以自强不息！"><link rel="canonical" href="https://www.aisky.men/page/2/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>夜行</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?03806bd68e029f12f863ba16efac2c2c";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-right page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">夜行</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/15/leetcode/LeetCode 435. 无重叠区间/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/15/leetcode/LeetCode 435. 无重叠区间/" itemprop="url">LeetCode 435. 无重叠区间</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-15 21:04:00 / 修改时间：21:05:29" itemprop="dateCreated datePublished" datetime="2018-08-15T21:04:00+08:00">2018-08-15</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/15/leetcode/LeetCode 435. 无重叠区间/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/15/leetcode/LeetCode 435. 无重叠区间/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>注意:</strong></p><ol><li>可以认为区间的终点总是大于它的起点。</li><li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这道题的关键就是利用贪心法，每一次，将跨越区域最多的删除，然后更新其他区间跨越的区间数量，然后继续更新</p><p>关键点在于，如何有效率的找出相互区间之前的重叠</p><ul><li>首先，我们按照区间左边界进行排序</li><li>我们判断当前区间和前面的区间关系，如果当前区间的左边界，小于前面区间的右边界，肯定是要删除一个，消除重叠，这时候，我们判断，这两个区间，那个区间的右边界比较小，我们挑选小的按个，删除另一个，因为右边界更小，表示向后重叠的机会就越小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        intervals = sorted(intervals,key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[pre].end &gt; intervals[i].start:</span><br><span class="line">                pre = i <span class="keyword">if</span> intervals[pre].end &gt; intervals[i].end <span class="keyword">else</span> pre</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = i</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/14/leetcode/LeetCode 888. 两句话中的不常见单词/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/14/leetcode/LeetCode 888. 两句话中的不常见单词/" itemprop="url">LeetCode 884. 两句话中的不常见单词</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-14 15:40:00" itemprop="dateCreated datePublished" datetime="2018-08-14T15:40:00+08:00">2018-08-14</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-08-21 09:15:14" itemprop="dateModified" datetime="2018-08-21T09:15:14+08:00">2018-08-21</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/14/leetcode/LeetCode 888. 两句话中的不常见单词/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/14/leetcode/LeetCode 888. 两句话中的不常见单词/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定两个句子 <code>A</code> 和 <code>B</code> 。 （<em>句子</em>是一串由空格分隔的单词。每个<em>单词</em>仅由小写字母组成。）</p><p>如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是<em>不常见的</em>。</p><p>返回所有不常用单词的列表。</p><p>您可以按任何顺序返回列表。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot;</span><br><span class="line">输出：[&quot;sweet&quot;,&quot;sour&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = &quot;apple apple&quot;, B = &quot;banana&quot;</span><br><span class="line">输出：[&quot;banana&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 200</code></li><li><code>0 &lt;= B.length &lt;= 200</code></li><li><code>A</code> 和 <code>B</code> 都只包含空格和小写字母。</li></ol><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><pre><code>这道题是简单题，哈哈（简单题好简单）
</code></pre><ul><li>首先使用哈希统计出两个句子的单词数量</li><li>将句子1中出现1次，并且不在句子2中的单词放入结果数组</li><li>将句子2中出现1次，并且不在句子1中的单词放入结果数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uncommonFromSentences</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        count_A = collections.Counter(A.split(<span class="string">" "</span>))</span><br><span class="line">        count_B = collections.Counter(B.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">        ans += [x <span class="keyword">for</span> x <span class="keyword">in</span> count_A <span class="keyword">if</span> count_A[x] == <span class="number">1</span> <span class="keyword">and</span> x <span class="keyword">not</span> <span class="keyword">in</span> count_B]</span><br><span class="line">        ans += [x <span class="keyword">for</span> x <span class="keyword">in</span> count_B <span class="keyword">if</span> count_B[x] == <span class="number">1</span> <span class="keyword">and</span> x <span class="keyword">not</span> <span class="keyword">in</span> count_A]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/14/leetcode/LeetCode 126. 单词接龙 II/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/14/leetcode/LeetCode 126. 单词接龙 II/" itemprop="url">LeetCode 126. 单词接龙 II</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-14 13:37:30 / 修改时间：13:37:53" itemprop="dateCreated datePublished" datetime="2018-08-14T13:37:30+08:00">2018-08-14</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/14/leetcode/LeetCode 126. 单词接龙 II/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/14/leetcode/LeetCode 126. 单词接龙 II/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典 <em>wordList</em>，找出所有从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回一个空列表。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: []</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这道题与127题单词接龙和433题基因变化相似，区别就在与，我们需要保存路径的前向节点，最后遍历一遍，就得到结果了</p><p>​ 换个思路解决问题，首先来构建一个结构，每一个都保存这当前值的前向节点</p><p>分两步来做</p><ul><li><p>首先，将数组进行转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = collections.defaultdict(list)</span><br><span class="line">        wordList.append(beginWord)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                s = word[:i] + <span class="string">"_"</span> + word[i + <span class="number">1</span>:]</span><br><span class="line">                d[s] += [word]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 经过上面的变换，得到下面的结果</span><br><span class="line">defaultdict(&lt;class &apos;list&apos;&gt;, &#123;&apos;l_g&apos;: [&apos;log&apos;], &apos;d_g&apos;: [&apos;dog&apos;], &apos;_og&apos;: [&apos;dog&apos;, &apos;log&apos;, &apos;cog&apos;], &apos;l_t&apos;: [&apos;lot&apos;], &apos;do_&apos;: [&apos;dot&apos;, &apos;dog&apos;], &apos;ho_&apos;: [&apos;hot&apos;], &apos;co_&apos;: [&apos;cog&apos;], &apos;hi_&apos;: [&apos;hit&apos;], &apos;h_t&apos;: [&apos;hot&apos;, &apos;hit&apos;], &apos;_it&apos;: [&apos;hit&apos;], &apos;lo_&apos;: [&apos;lot&apos;, &apos;log&apos;], &apos;d_t&apos;: [&apos;dot&apos;], &apos;c_g&apos;: [&apos;cog&apos;], &apos;_ot&apos;: [&apos;hot&apos;, &apos;dot&apos;, &apos;lot&apos;]&#125;)</span><br></pre></td></tr></table></figure></li><li><p>然后，将前向节点字典生成出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pre = collections.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> _, value <span class="keyword">in</span> d.items():</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> value:</span><br><span class="line">                pre[i] = pre[i].union(set(value))</span><br><span class="line">                pre[i].remove(i)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultdict(&lt;class &apos;set&apos;&gt;, &#123;&apos;dog&apos;: &#123;&apos;log&apos;, &apos;dot&apos;, &apos;cog&apos;&#125;, &apos;log&apos;: &#123;&apos;dog&apos;, &apos;lot&apos;, &apos;cog&apos;&#125;, &apos;lot&apos;: &#123;&apos;hot&apos;, &apos;log&apos;, &apos;dot&apos;&#125;, &apos;hot&apos;: &#123;&apos;lot&apos;, &apos;dot&apos;, &apos;hit&apos;&#125;, &apos;dot&apos;: &#123;&apos;dog&apos;, &apos;hot&apos;, &apos;lot&apos;&#125;, &apos;hit&apos;: &#123;&apos;hot&apos;&#125;, &apos;cog&apos;: &#123;&apos;dog&apos;, &apos;log&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>这样，我们就能够利用树的性质，进行层次遍历，需要注意的就是，已经访问过的节点不能继续访问，不然会产生回环，因此，需要保存一下访问过的路径</p><p>这样，我们就能够从endword开始，向前寻找beginword，找到以后，就加入到结果集中</p></li></ul><p>​ 这个思路可以，不过最后是在127题的解题思路上修改了一下，如下</p><p>​ 如果能够正向的找到endword，那么我们在重新反向找到beginword，就得到路径了，下面就是基于这个思路来做的：</p><ul><li><p>首先，将数组进行变换，同前面一样</p></li><li><p>然后，利用两个set，一个是访问过，一个是未访问过，然后进行层次遍历</p><p>在遍历的过程中，建立一个字典，前向节点的字典，方便我们根据这个字典，回溯路径</p></li></ul><p>如果层次遍历无法得到，最后直接返回[]</p><p>如果第一次找到了，我们就跳出来，根据前向节点的字典，进行路径回溯，然后加入到结果集中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                s = word[:i] + <span class="string">"_"</span> + word[i + <span class="number">1</span>:]</span><br><span class="line">                d[s] += [word]</span><br><span class="line"></span><br><span class="line">        path_node = set()</span><br><span class="line"></span><br><span class="line">        visited = set([beginWord])</span><br><span class="line">        temp = set()</span><br><span class="line">        not_visited = set(wordList)</span><br><span class="line"></span><br><span class="line">        pre = collections.defaultdict(set)</span><br><span class="line"></span><br><span class="line">        pop_item = set()</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> visited:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(i)):</span><br><span class="line">                    s = i[:j] + <span class="string">"_"</span> + i[j + <span class="number">1</span>:]</span><br><span class="line">                    temp = temp.union(set(d[s]))</span><br><span class="line">                    <span class="keyword">for</span> w <span class="keyword">in</span> d[s]:</span><br><span class="line">                        path_node.add(w)</span><br><span class="line">                        <span class="keyword">if</span> i != w:</span><br><span class="line">                            pre[w].add(i)</span><br><span class="line">                    pop_item.add(s)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> pop_item:</span><br><span class="line">                d.pop(p)</span><br><span class="line">            pop_item.clear()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> len(temp) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> endWord <span class="keyword">in</span> temp:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            not_visited = not_visited - temp</span><br><span class="line">            visited = temp</span><br><span class="line">            temp = set()</span><br><span class="line"></span><br><span class="line">        ans = [[endWord]]</span><br><span class="line">        temp_ans = []</span><br><span class="line">        visited_path = set([endWord])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">            <span class="keyword">for</span> path <span class="keyword">in</span> ans:</span><br><span class="line">                temp_next = pre[path[<span class="number">-1</span>]] - visited_path</span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> temp_next:</span><br><span class="line">                    temp_ans.append(path.copy())</span><br><span class="line">                    temp_ans[<span class="number">-1</span>].append(node)</span><br><span class="line">                visited_path.add(path[<span class="number">-1</span>])</span><br><span class="line">            ans = temp_ans</span><br><span class="line">            temp_ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [ list(reversed(x)) <span class="keyword">for</span> x <span class="keyword">in</span> ans <span class="keyword">if</span> x[<span class="number">-1</span>] == beginWord ]</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/14/leetcode/LeetCode 433. 最小基因变化/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/14/leetcode/LeetCode 433. 最小基因变化/" itemprop="url">LeetCode 433. 最小基因变化</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-14 10:20:30 / 修改时间：13:36:42" itemprop="dateCreated datePublished" datetime="2018-08-14T10:20:30+08:00">2018-08-14</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/14/leetcode/LeetCode 433. 最小基因变化/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/14/leetcode/LeetCode 433. 最小基因变化/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 <code>&quot;A&quot;</code>, <code>&quot;C&quot;</code>, <code>&quot;G&quot;</code>, <code>&quot;T&quot;</code>中的任意一个。</p><p>假设我们要调查一个基因序列的变化。<strong>一次</strong>基因变化意味着这个基因序列中的<strong>一个</strong>字符发生了变化。</p><p>例如，基因序列由<code>&quot;AACCGGTT&quot;</code> 变化至 <code>&quot;AACCGGTA&quot;</code>即发生了一次基因变化。</p><p>与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。</p><p>现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。</p><p><strong>注意:</strong></p><ol><li>起始基因序列默认是合法的，但是它并不一定会出现在基因库中。</li><li>所有的目标基因序列必须是合法的。</li><li>假定起始基因序列与目标基因序列是不一样的。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start: &quot;AACCGGTT&quot;</span><br><span class="line">end:   &quot;AACCGGTA&quot;</span><br><span class="line">bank: [&quot;AACCGGTA&quot;]</span><br><span class="line"></span><br><span class="line">返回值: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start: &quot;AACCGGTT&quot;</span><br><span class="line">end:   &quot;AAACGGTA&quot;</span><br><span class="line">bank: [&quot;AACCGGTA&quot;, &quot;AACCGCTA&quot;, &quot;AAACGGTA&quot;]</span><br><span class="line"></span><br><span class="line">返回值: 2</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start: &quot;AAAAACCC&quot;</span><br><span class="line">end:   &quot;AACCCCCC&quot;</span><br><span class="line">bank: [&quot;AAAACCCC&quot;, &quot;AAACCCCC&quot;, &quot;AACCCCCC&quot;]</span><br><span class="line"></span><br><span class="line">返回值: 3</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这道题跟127题很相似,直接应该使用广度优先搜索来做，直接使用127提的解法就可以</p><p>举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start: &quot;AACCGGTT&quot;</span><br><span class="line">end:   &quot;AACCGGTA&quot;</span><br><span class="line">bank: [&quot;AACCGGTA&quot;]</span><br><span class="line">首先，我们将bank进行建模</span><br><span class="line">&#123;&quot;AACCGGT_&quot;:[&quot;AACCGGTA&quot;]&#125;</span><br><span class="line">然后，设置两个set()，visited和not_visited</span><br><span class="line">利用这两个set进行广度优先遍历</span><br><span class="line">首先，对于visited中的每一个元素，我们改变一位，判断是不是在bank里面出现，如果出现了，就放到temp中</span><br><span class="line">然后，判断temp中是否还有元素，如果没有，表示找不到了，返回-1</span><br><span class="line">如果有元素，继续判断，判断end是不是出现在temp中，如果出现了，返回计数，没有出现，返回第一步，继续判断</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMutation</span><span class="params">(self, start, end, bank)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type start: str</span></span><br><span class="line"><span class="string">        :type end: str</span></span><br><span class="line"><span class="string">        :type bank: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> gene <span class="keyword">in</span> bank:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gene)):</span><br><span class="line">                s = gene[:i] + <span class="string">"_"</span> + gene[i + <span class="number">1</span>:]</span><br><span class="line">                d[s] = d.get(s, []) + [gene]</span><br><span class="line"></span><br><span class="line">        visited = set([start])</span><br><span class="line">        temp = set()</span><br><span class="line">        not_visited = set(bank)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> visited:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(i)):</span><br><span class="line">                    s = i[:j] + <span class="string">"_"</span> + i[j + <span class="number">1</span>:]</span><br><span class="line">                    temp = temp.union(set(d.get(s, [])))</span><br><span class="line">                    d.pop(s, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> len(temp) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end <span class="keyword">in</span> temp:</span><br><span class="line">                <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">            not_visited = not_visited - temp</span><br><span class="line">            visited = temp</span><br><span class="line">            temp = set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/13/leetcode/LeetCode 430. Flatten a Multilevel Doubly Linked List/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/13/leetcode/LeetCode 430. Flatten a Multilevel Doubly Linked List/" itemprop="url">LeetCode 430. Flatten a Multilevel Doubly Linked List</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-13 16:49:40 / 修改时间：16:49:29" itemprop="dateCreated datePublished" datetime="2018-08-13T16:49:40+08:00">2018-08-13</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/13/leetcode/LeetCode 430. Flatten a Multilevel Doubly Linked List/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/13/leetcode/LeetCode 430. Flatten a Multilevel Doubly Linked List/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.</p><p>Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"> 1---2---3---4---5---6--NULL</span><br><span class="line">         |</span><br><span class="line">         7---8---9---10--NULL</span><br><span class="line">             |</span><br><span class="line">             11--12--NULL</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1-2-3-7-8-11-12-9-10-4-5-6-NULL</span><br></pre></td></tr></table></figure><p><strong>Explanation for the above example:</strong></p><p>Given the following multilevel doubly linked list:</p><p><img src="https://leetcode-cn.com/static/images/problemset/MultilevelLinkedList.png" alt="img"></p><p>We should return the following flattened doubly linked list:</p><p><img src="https://leetcode-cn.com/static/images/problemset/MultilevelLinkedListFlattened.png" alt="img"></p><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 可以使用深度优先搜索，也可以不是用，首先来剖析一下问题</p><p>​ 这道题与前面114题很相似，如果当前的节点有子节点，该如何做呢？</p><p>​ 将剩下的节点，挂到子节点的末尾，然后，将当前节点的next指向子节点，子节点的prev指向当前节点即可，然后节点后移，继续判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.child:</span><br><span class="line">                head_next = head.next</span><br><span class="line">                temp = head.child</span><br><span class="line">                <span class="keyword">while</span> temp.next:</span><br><span class="line">                    temp = temp.next</span><br><span class="line">                temp.next = head_next</span><br><span class="line">                head_next.prev = temp</span><br><span class="line"></span><br><span class="line">                head.next = head.child</span><br><span class="line">                head.child.prev = head</span><br><span class="line">                head.child = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>​ 思路很简单，但是通过了19个测试用了，下一个超时了，因此，要考虑如何提高效率</p><p>​ 考虑在展开的过程中，不直接将下一个元素挂到子列的尾部，而是保存到栈中，等到遍历到最后的时候，就将栈中的元素取出来，接到尾部，然后继续判断即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val, prev, next, child):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.prev = prev</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.child = child</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = head</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> head:</span><br><span class="line">                prev = head</span><br><span class="line">                <span class="keyword">if</span> head.child:</span><br><span class="line">                    <span class="keyword">if</span> head.next:</span><br><span class="line">                        stack.append(head.next)</span><br><span class="line">                    head.next = head.child</span><br><span class="line">                    head.child.prev = head</span><br><span class="line">                    head.child = <span class="keyword">None</span></span><br><span class="line">                head = head.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = stack.pop()</span><br><span class="line">                prev.next = temp</span><br><span class="line">                temp.prev = prev</span><br><span class="line">                head = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>​ 这样，仅需要从头到尾遍历一遍即可得出结果</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/13/leetcode/LeetCode: 424. 替换后的最长重复字符/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/13/leetcode/LeetCode: 424. 替换后的最长重复字符/" itemprop="url">LeetCode 424. 替换后的最长重复字符</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-13 09:30:00 / 修改时间：09:30:27" itemprop="dateCreated datePublished" datetime="2018-08-13T09:30:00+08:00">2018-08-13</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/13/leetcode/LeetCode: 424. 替换后的最长重复字符/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/13/leetcode/LeetCode: 424. 替换后的最长重复字符/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 <em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p><strong>注意:</strong><br>字符串长度 和 <em>k</em> 不会超过 104。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ABAB&quot;, k = 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">用两个&apos;A&apos;替换为两个&apos;B&apos;,反之亦然。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;AABABBA&quot;, k = 1</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">将中间的一个&apos;A&apos;替换为&apos;B&apos;,字符串变为 &quot;AABBBBA&quot;。</span><br><span class="line">子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这个问题可以使用滑动窗口来做</p><ul><li>首先判断length&lt;=k+1? 是的话，直接返回length，不是的话，继续判断</li><li>初始的窗口大小设置为k+1，这样的话，肯定能替换出来</li><li>然后统计一下窗口内的字符的数量，找出最大的那个数量m</li><li>判断，如果窗口大小-m&lt;=k,窗口右指针向右移动</li><li>同样继续判断，窗口大小-m&gt;窗口左指针向右移动</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">characterReplacement</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> length &lt;= k + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line">        ans = k + <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = k + <span class="number">1</span></span><br><span class="line">        count = collections.Counter(s[start:end])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start &lt; length:</span><br><span class="line">            most = count.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> end - start - most &lt;= k:</span><br><span class="line">                ans = max(ans, end - start)</span><br><span class="line">                <span class="keyword">if</span> end &lt; length:</span><br><span class="line">                    count[s[end]] += <span class="number">1</span></span><br><span class="line">                    end += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            count[s[start]] -= <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/12/leetcode/LeetCode 423. 从英文中重建数字/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/12/leetcode/LeetCode 423. 从英文中重建数字/" itemprop="url">LeetCode 423. 从英文中重建数字</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-12 19:01:00 / 修改时间：19:02:01" itemprop="dateCreated datePublished" datetime="2018-08-12T19:01:00+08:00">2018-08-12</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/12/leetcode/LeetCode 423. 从英文中重建数字/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/12/leetcode/LeetCode 423. 从英文中重建数字/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定一个<strong>非空</strong>字符串，其中包含字母顺序打乱的英文单词表示的数字<code>0-9</code>。按升序输出原始的数字。</p><p><strong>注意:</strong></p><ol><li>输入只包含小写英文字母。</li><li>输入保证合法并可以转换为原始的数字，这意味着像 “abc” 或 “zerone” 的输入是不允许的。</li><li>输入字符串的长度小于 50,000。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;owoztneoer&quot;</span><br><span class="line"></span><br><span class="line">输出: &quot;012&quot; (zeroonetwo)</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;fviefuro&quot;</span><br><span class="line"></span><br><span class="line">输出: &quot;45&quot; (fourfive)</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 首先来分析下每个数字的英文组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zero</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br><span class="line">six</span><br><span class="line">seven</span><br><span class="line">eight</span><br><span class="line">nine</span><br></pre></td></tr></table></figure><p>​ 根据上面的字符，我们发现，一共出现了下面几个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;n&apos;, &apos;o&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;z&apos;]</span><br></pre></td></tr></table></figure><p>​ 其中，仅仅在某一个数字中出现的有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z: zero</span><br><span class="line">w: two</span><br><span class="line">u: four</span><br><span class="line">x: six</span><br><span class="line">g: eight</span><br></pre></td></tr></table></figure><p>​ 因此，根据这几个字符的数量，我们就能够直接判断上面几个数字的数量</p><p>并且，有了上面几个数字以后，我们就可以判断机器的数字了，例如1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one </span><br><span class="line">在所有数字中，包含o的只有0，1，2，4，而我们已经得到0，2，4的数量，就可以直接算出1的数量了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">three</span><br><span class="line">r仅仅出现在zero，four，同样的也能够计算出3的数量了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">five</span><br><span class="line">f仅仅出现在four，five，也可以计算出5的数量了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seven</span><br><span class="line">v仅仅出现在five，seven中，利用v直接计算7</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nine</span><br><span class="line">其他数字都已经计算出来了，剩下的9，利用n来计算也可以，i也可以，e也可以，用n的计算量比较小，因为n仅出现在one，seven，nine中</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">originalDigits</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">zero</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        buff = collections.defaultdict(zero)</span><br><span class="line">        nums = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            buff[c] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        nums[<span class="number">0</span>] = buff[<span class="string">'z'</span>]</span><br><span class="line">        nums[<span class="number">2</span>] = buff[<span class="string">'w'</span>]</span><br><span class="line">        nums[<span class="number">4</span>] = buff[<span class="string">'u'</span>]</span><br><span class="line">        nums[<span class="number">6</span>] = buff[<span class="string">'x'</span>]</span><br><span class="line">        nums[<span class="number">8</span>] = buff[<span class="string">'g'</span>]</span><br><span class="line">        nums[<span class="number">1</span>] = buff[<span class="string">'o'</span>] - nums[<span class="number">0</span>] - nums[<span class="number">2</span>] -nums[<span class="number">4</span>]</span><br><span class="line">        nums[<span class="number">3</span>] = buff[<span class="string">'r'</span>] - nums[<span class="number">0</span>] - nums[<span class="number">4</span>]</span><br><span class="line">        nums[<span class="number">5</span>] = buff[<span class="string">'f'</span>] - nums[<span class="number">4</span>]</span><br><span class="line">        nums[<span class="number">7</span>] = buff[<span class="string">'v'</span>] - nums[<span class="number">5</span>]</span><br><span class="line">        nums[<span class="number">9</span>] = buff[<span class="string">'i'</span>] - nums[<span class="number">5</span>] - nums[<span class="number">6</span>] - nums[<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">        ans = [str(i) * n <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums)]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(ans)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/12/leetcode/LeetCode: 421. 数组中两个数的最大异或值/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/12/leetcode/LeetCode: 421. 数组中两个数的最大异或值/" itemprop="url">LeetCode 421. 数组中两个数的最大异或值</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-12 10:01:01 / 修改时间：10:01:36" itemprop="dateCreated datePublished" datetime="2018-08-12T10:01:01+08:00">2018-08-12</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/12/leetcode/LeetCode: 421. 数组中两个数的最大异或值/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/12/leetcode/LeetCode: 421. 数组中两个数的最大异或值/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai &lt; 231 。</p><p>找到 ai 和aj 最大的异或 (XOR) 运算结果，其中0 ≤ <em>i</em>, <em>j</em> &lt; <em>n</em> 。</p><p>你能在O(<em>n</em>)的时间解决这个问题吗？</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [3, 10, 5, 25, 2, 8]</span><br><span class="line"></span><br><span class="line">输出: 28</span><br><span class="line"></span><br><span class="line">解释: 最大的结果是 5 ^ 25 = 28.</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 首先明确一下，数组中怎样的两个数才能异或得到最大值</p><p>​ 首先，第一个数肯定是所有数中，最高位为1的，另一个数则是最高位不为1的</p><p>​ 一般的想法是建立一颗字典树，然后利用二进制的性质，进行搜索</p><p>​ 按位操作</p><p>​ 在LeetCode的diss里面，看到了一个十分精彩的解法，只有6行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        answer &lt;&lt;= <span class="number">1</span></span><br><span class="line">        prefixes = &#123;num &gt;&gt; i <span class="keyword">for</span> num <span class="keyword">in</span> nums&#125;</span><br><span class="line">        answer += any(answer^<span class="number">1</span> ^ p <span class="keyword">in</span> prefixes <span class="keyword">for</span> p <span class="keyword">in</span> prefixes)</span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p>​ 直接看上去，有些困惑，不过只要把握这个算法的主要思想就就可以想到了</p><p>​ 首先，这个数可定是少于32位的，如果结果中每一位异或的结果都是1，肯定能得到最大值，这个算法的思想就是这个</p><ul><li>首先是第32位，看看能不能有两个数，异或以后得到1，如果能够得到，那么ans设置为1</li><li>然后ans左移一位，也就是判断第31位，这时候，ans=10，也就是2，<ul><li>重点来了，这时候，判断有没有两个数，能够在第一位为1的情况下，将第二位也设置为1</li><li>利用的公式为<code>a^b=c,a=b^c</code></li><li>算法的重点在于，我只要判断能够得到最高位的那些数字就可以了，其他的数字都可以不看，因为你们得不到最高位为1，这里的最高位，指的是数组中能得到的1的最高位</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">answer^<span class="number">1</span> ^ p <span class="keyword">in</span> prefixes <span class="keyword">for</span> p <span class="keyword">in</span> prefixes</span><br></pre></td></tr></table></figure><p>算法的核心在上面这一句，就是用来判断能否得到当前位为的两个数存在，</p><p>​ 实际上，在判断的时候，还能够进行一点优化，因为先将所有的前缀计算出来了，实际上，只需要判断能够得到answer即可，只有所有的结果都不能得到answer的时候，这种情况才会将所有的数遍历一遍进行计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>)[::<span class="number">-1</span>]:</span><br><span class="line">            ans = (ans &lt;&lt; <span class="number">1</span>) ^ <span class="number">1</span></span><br><span class="line">            pre = set()</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                temp = num &gt;&gt; i</span><br><span class="line">                <span class="keyword">if</span> (temp ^ ans) <span class="keyword">in</span> pre:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                pre.add(temp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>​ 上面的就是减少了计算量，进一步提高了效率。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/11/leetcode/LeetCode: 419. 甲板上的战舰/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/11/leetcode/LeetCode: 419. 甲板上的战舰/" itemprop="url">LeetCode 419. 甲板上的战舰</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-11 14:35:35 / 修改时间：14:37:04" itemprop="dateCreated datePublished" datetime="2018-08-11T14:35:35+08:00">2018-08-11</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/11/leetcode/LeetCode: 419. 甲板上的战舰/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/11/leetcode/LeetCode: 419. 甲板上的战舰/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定一个二维的甲板， 请计算其中有多少艘战舰。 战舰用 <code>&#39;X&#39;</code>表示，空位用 <code>&#39;.&#39;</code>表示。 你需要遵守以下规则：</p><ul><li>给你一个有效的甲板，仅由战舰或者空位组成。</li><li>战舰只能水平或者垂直放置。换句话说,战舰只能由 <code>1xN</code> (1 行, N 列)组成，或者 <code>Nx1</code> (N 行, 1 列)组成，其中N可以是任意大小。</li><li>两艘战舰之间至少有一个水平或垂直的空位分隔 - 即没有相邻的战舰。</li></ul><p><strong>示例 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X..X</span><br><span class="line">...X</span><br><span class="line">...X</span><br></pre></td></tr></table></figure><p>在上面的甲板中有2艘战舰。</p><p><strong>无效样例 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...X</span><br><span class="line">XXXX</span><br><span class="line">...X</span><br></pre></td></tr></table></figure><p>你不会收到这样的无效甲板 - 因为战舰之间至少会有一个空位将它们分开。</p><p><strong>进阶:</strong></p><p>你可以用<strong>一次扫描算法</strong>，只使用<strong>O(1)额外空间，</strong>并且<strong>不修改</strong>甲板的值来解决这个问题吗？</p><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 一开始没有理解题意，实际上，应该这样描述：</p><ul><li>甲板上，’.’代表空位，’X’代表有战舰</li><li>战舰可能占有一个’X’或多个，一个战舰只能横着摆放或者竖着摆放</li><li>战舰之间必须留有空位（不然出不去了）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X..X.</span><br><span class="line">.XXX.</span><br><span class="line">...X.</span><br></pre></td></tr></table></figure><p>如上，这就不对的，战舰放在了一起，没法区别是什么样的战舰了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X..X.</span><br><span class="line">.XX..</span><br><span class="line">...X.</span><br></pre></td></tr></table></figure><p>这样就是正确的了</p><p>​ 根据之前的描述，可以这样来判判定：</p><ul><li>如果遇到’X’，判断这个点上方和左方有没有’X’，如果有，表示这个点是战舰的一部分，不增加计数</li><li>如果左面和上面都没有’X’，计数加一即可</li><li>遍历完成即可得</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBattleships</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row = len(board)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> row:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        col = len(board[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'X'</span>:</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                            ans += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">elif</span> board[i][j - <span class="number">1</span>] != <span class="string">'X'</span>:</span><br><span class="line">                            ans += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                            <span class="keyword">if</span> board[i - <span class="number">1</span>][j] != <span class="string">'X'</span>:</span><br><span class="line">                                ans += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">if</span> board[i - <span class="number">1</span>][j] != <span class="string">'X'</span> <span class="keyword">and</span> board[i][j - <span class="number">1</span>] != <span class="string">'X'</span>:</span><br><span class="line">                                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>​ 判断条件还可以反过来写，这样判断起来更简单一些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBattleships</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        row = len(board)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> row:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        col = len(board[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'.'</span> <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> board[i - <span class="number">1</span>][j] == <span class="string">'X'</span>) <span class="keyword">or</span> (j &gt; <span class="number">0</span> <span class="keyword">and</span> board[i][j - <span class="number">1</span>] == <span class="string">'X'</span>):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.aisky.men/2018/08/11/leetcode/LeetCode: 417. 太平洋大西洋水流问题/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="夜行"><meta itemprop="description" content="天行健，君子以自强不息！"><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜行"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/08/11/leetcode/LeetCode: 417. 太平洋大西洋水流问题/" itemprop="url">LeetCode 417. 太平洋大西洋水流问题</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-11 13:48:40 / 修改时间：13:49:21" itemprop="dateCreated datePublished" datetime="2018-08-11T13:48:40+08:00">2018-08-11</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/08/11/leetcode/LeetCode: 417. 太平洋大西洋水流问题/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/08/11/leetcode/LeetCode: 417. 太平洋大西洋水流问题/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、题目描述"><a href="#1、题目描述" class="headerlink" title="1、题目描述"></a>1、题目描述</h2><p>给定一个 <code>m x n</code> 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p><p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p><p><strong>提示：</strong></p><ol><li>输出坐标的顺序不重要</li><li><em>m</em> 和 <em>n</em> 都小于150</li></ol><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定下面的 5x5 矩阵:</span><br><span class="line"></span><br><span class="line">  太平洋 ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * 大西洋</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line"></span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</span><br></pre></td></tr></table></figure><h2 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h2><p>​ 这道题使用深度优先搜索即可，对于每一个坐标，判断是不是能够到太平洋和大西洋，如果都能到，假如结果集中即可</p><ul><li><p>判断当前节点是不是在太平洋边界上，如果不是，深度优先所搜索，向上和想左，判断能否到达</p></li><li><p>大西洋也是如此</p><p>如果对每一个节点判断能否到大西洋或者太平洋，有一点麻烦，计算量太大了，可以换个角度，找出所有能够流到大西洋的节点，找出所有能够流到太平洋的节点，然后将它们相交的点放入结果集中即可</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        row = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> row:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        col = len(matrix[<span class="number">0</span>])</span><br><span class="line">        a_visited = [[<span class="number">0</span>] * col <span class="keyword">for</span> _ <span class="keyword">in</span> range(row)]</span><br><span class="line">        b_visited = [[<span class="number">0</span>] * col <span class="keyword">for</span> _ <span class="keyword">in</span> range(row)]</span><br><span class="line"></span><br><span class="line">        directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x, y, visited)</span>:</span></span><br><span class="line">            visited[x][y] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> directions:</span><br><span class="line">                m = x + i</span><br><span class="line">                n = y + j</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= m &lt; row <span class="keyword">and</span> <span class="number">0</span> &lt;= n &lt; col <span class="keyword">and</span> <span class="keyword">not</span> visited[m][n] <span class="keyword">and</span> matrix[m][n] &gt;= matrix[x][y]:</span><br><span class="line">                    dfs(m, n, visited)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(row):</span><br><span class="line">            dfs(r, <span class="number">0</span>, a_visited)</span><br><span class="line">            dfs(r, col - <span class="number">1</span>, b_visited)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(col):</span><br><span class="line">            dfs(<span class="number">0</span>, c, a_visited)</span><br><span class="line">            dfs(row - <span class="number">1</span>, c, b_visited)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> a_visited[r][c] <span class="keyword">and</span> b_visited[r][c]:</span><br><span class="line">                    ans.append([r, c])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="夜行"><p class="site-author-name" itemprop="name">夜行</p><p class="site-description motion-element" itemprop="description">天行健，君子以自强不息！</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">418</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zhishengqianjun123" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:zhishengqianjun@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">夜行</span></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv" title="总访客量"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv" title="总访问量"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!1,notify:!1,appId:"qluXerUVutA7CjS8IgGYE7wg-gzGzoHsz",appKey:"kkrJimHdrtGVpP0goHXGtGDW",placeholder:"Just go go",avatar:"mm",meta:guest,pageSize:"10",visitor:!1})</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script></body></html><!-- rebuild by neat -->