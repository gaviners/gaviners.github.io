<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内部排序算法]]></title>
    <url>%2F2018%2F08%2F07%2Falgorithm%2F%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1python：3.6.2 前言​ 排序算法是计算机中最基础的算法，很多高级算法都依赖于此； 排序算法的稳定性 ​ 如果待排序的数列中，相同的元素在排序前后相对顺序不变，即为稳定； ​ 例如待排序列$[1,2_{a},5,3,2_{b}]$，如果排序之后，$2_{a}$依然在$2_{b}$的前面，就表示稳定； ​ 算法的判断条件很重要，更改了条件，稳定的排序也会变得不稳定，如将冒泡的比较变成$\ge$。 ​ 一图胜千言，在下面搜集了一些简单的示例图，使用gif录屏器制作(算法可视化参见见参考文献)。 1、排序算法的分类​ 排序算法的理论： 计算复杂性理论 大O符号 全序关系 列表&amp;action=edit&amp;redlink=1) 稳定性 比较排序 自适应排序 排序网络 整数排序 ​ 根据排序的方法：插入、交换、选择、合并等, 将排序进行划分： 排序方法 排序算法 交换排序 冒泡排序 鸡尾酒排序 奇偶排序 梳排序 侏儒排序 快速排序 臭皮匠排序 Bogo排序 选择排序 选择排序 堆排序 平滑排序 笛卡尔树排序 锦标赛排序 圈排序 插入排序 插入排序 希尔排序 伸展排序 二叉查找树排序 图书馆排序 耐心排序 归并排序 归并排序 梯级归并排序 振荡归并排序 多相归并排序 列表排序 分布排序 美国旗帜排序 珠排序 桶排序 爆炸排序 计数排序 鸽巢排序 相邻图排序 基数排序 闪电排序 插值排序 并发排序 双调排序器 Batcher归并网络 两两排序网络 混合排序 块排序 Tim排序 内省排序 Spread排序 J排序 其他 拓扑排序 煎饼排序 意粉排序 下面是常用的算法列表： 冒泡排序 直接冒泡排序 鸡尾酒排序 梳排序 选择排序 插入排序 直接插入排序 二分插入排序 希尔排序 归并排序 堆排序 快速排序 计数排序 基数排序 桶排序 算法 最坏时间复杂度 最佳时间复杂度 平均时间复杂度 空间复杂度 稳定性 冒泡排序 $O(n^{2})$ $O(n)$ $O(n^{2})$ $O(1)$ 稳定 选择排序 $O(n^{2})$ $O(n^{2})$ $O(n^{2})$ O(1) 不稳定 插入排序 $O(n^{2})$ $O(n)$ $O(n^{2})$ $O(1)$ 稳定 希尔排序 $O(nlog(n)) \sim O(n^{2})$ $O(n^{1.5})$ $O(n^{2})$ $O(1)$ 不稳定 堆排序 $O(nlog(n))$ $O(nlog(n))$ $O(nlog(n))$ $O(1)$ 不稳定 归并排序 $O(nlog(n))$ $O(nlog(n))$ $O(nlog(n))$ $O(n)$ 稳定 快速排序 $O(n^{2})$ $O(nlog(n))$ $O(nlog(n))$ $O(logn)\sim O(n)$ 不稳定 计数排序 $O(n+m)$ $O(n+m)$ $O(n+m)$ $O(n + m)$ 稳定 基数排序 $O(k*n)$ $O(k*n)$ $O(k*n)$ $O(k*n)$ 稳定 桶排序 $O(n)$ $O(n)$ $O(n)$ $O(m)$ 不稳定 2、交换排序2.1 冒泡排序 Bubble Sort 2.1.1 直接冒泡排序 ​ 冒泡排序如上图所示，给定一个待排序列，从前往后依次扫描，将最大的元素放到最后面正确的位置，已经放到正确位置的序列在下一次扫描中就不会继续比对。 待排序列：[4,3,1,2] [3,1,2,==4==] [1,2,==3,4==] [1,==2,3,4==] [==1,2,3,4==] 如上面的简单序列所示，黄色的表示已经排好的序列 实际上，我们可以看到，最后一次排序并没有进行元素交换，所以，我们可以设置一个标志位，当本次比对没有进行数据交换的时候，就表明已经有序，跳出程序。 ​ 123456789101112131415161718192021222324252627def bubble_sort(l_A): n = len(l_A) for i in range(0,n): for j in range(0,n-i-1): if l_A[j] &gt; l_A[j + 1]: l_A[j + 1] , l_A[j] = l_A[j] , l_A[j + 1] return l_Adef bubble_sort_enhance(l_A): n = len(l_A) swap_flag = 0 for i in range(0,n): swap_flag = 0 for j in range(0,n-i-1): if l_A[j] &gt; l_A[j + 1]: swap_flag = 1 l_A[j + 1] , l_A[j] = l_A[j] , l_A[j + 1] if swap_flag == 0: break return l_Aif __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) sorted_A = bubble_sort_enhance(A) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 2.1.2 鸡尾酒排序​ 在调制鸡尾酒的过程中，需要来回摇晃，鸡尾酒算法也叫搅拌排序，涟漪排序 ​ 鸡尾酒排序是冒泡排序的简单改进，直接冒泡排序是单向的，而鸡尾酒算法则是进行双向排序； 待排序列：[4,3,2,1] [3,2,1,==4==] [==1==,3,2,==4==] [==1==,2,==3,4==] [==1,2,3,4==] 如上图所示，首先进行一次最大数冒泡，将最大数放到最后面，然后进行一次最小数冒泡，将最小数放到左面； 鸡尾酒排序在完全无序的情况下，与直接冒泡排序并无差别，同样的，我们也设置一个交换标志位，在没有交换的情况下，直接跳出。 1234567891011121314151617181920212223242526272829def cocktail_sort(l_A , n): left = 0 right = n - 1 swap_flag = 1 while left &lt; right: if swap_flag: for i in range(left,right): swap_flag = 0 if l_A[i] &gt; l_A[i + 1]: swap_flag = 1 l_A[i] , l_A[i + 1] = l_A[i + 1] , l_A[i] right = right - 1 for i in range(right,left,-1): if l_A[i] &lt; l_A[i - 1]: swap_flag = 1 l_A[i] , l_A[i - 1] = l_A[i - 1] , l_A[i] left = left + 1 else: break return l_Aif __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) sorted_A = cocktail_sort(A,len(A)) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 2.1.3 梳排序​ Comb Sort ​ 梳排序也是一种冒泡排序的改进方法，与希尔排序的思想类似，采用不同的增量序列，将待排序列划分成多个子序列，然后将每个子序列使用冒泡排序，最后一次的间隔一定是1，保证最终排序。 ​ 生成子序列的间隔一般是取待排序列长度递归除以==1.3==得到，例如长度为6的序列，其递减增量序列为： 123456/1.3 = 4.62 =&gt; 44/1.3 = 3.07 =&gt; 33/1.3 = 2.31 =&gt; 22/1.3 = 1.54 =&gt; 1最终序列为：[4,3,2,1] 待排序列：[6,5,4,3,2,1] [2,1,4,3,6,5] ==使用间隔4== [2,1,4,3,6,5] ==使用间隔3== [2,1,4,3,6,5] ==使用间隔2== [1,2,3,4,5,6] ==使用间隔1== 如上所示，使用不同的间隔的情况 12345678910111213141516def comb_sort(l_A): size = len(l_A) gap = int(size/1.3) while gap &gt;= 1 : for i in range(0,size - gap): if l_A[i] &gt; l_A[i + gap]: l_A[i] , l_A[i + gap] = l_A[i + gap] , l_A[i] gap = int(gap/1.3) return l_Aif __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) sorted_A = comb_sort(A) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 2.2 快速排序​ Quick Sort 2.2.1 快速排序 ​ 快速排序算法分治策略(Divide and Conquer)，将一个序列分成两个序列，然后选取基准，使用基准，将小于等于基准的放到左面，大于等于基准的数，放到右面； 我们来看这样的处理顺序： 判断待处理的数组中有多少元素，如果只有一个，返回 选取基准，利用基准将数组分成两部分，进行划分，小于等于基准的在左面，大于基准的在右面 将基准左面的数组重新执行第一步 将基准右面的数组重新执行第一步 待排序列：[6,5,4,3,2,1] ==下标 5 基准 1== [1, 5, 4, 3, 2, 6] ==下标 5 基准 6== [1, 5, 4, 3, 2, 6] ==下标 4 基准 2== [1, 2, 4, 3, 5, 6] ==下标 4 基准 5== [1, 2, 4, 3, 5, 6] ==下标 3 基准 3== [1, 2, 3, 4, 5, 6] 如上所示，目前基准选择的是最右面的元素，第一次，选择1作为基准，第二次选择6作为基准，一次类推； 123456789101112131415161718192021222324252627def partation(l_A , left , right): pivot = l_A[right] pivot_index = left # print('下标',right,'基准',pivot) for i in range(left, right): if l_A[i] &lt;= pivot: l_A[i] ,l_A[pivot_index] = l_A[pivot_index], l_A[i] pivot_index += 1 if pivot_index != right: l_A[pivot_index] , l_A[right] = l_A[right] ,l_A[pivot_index] # print(l_A) return pivot_indexdef quick_sort(l_A, left , right): if left &gt;= right: return pivot_index = partation(l_A ,left, right) quick_sort(l_A,left,pivot_index -1) quick_sort(l_A, pivot_index+1 , right)if __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) quick_sort(A,0,len(A)-1) sorted_A_str = ",".join([str(i) for i in A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 2.2.2 随机快速排序 ​ 随机快速排序与快速排序的主要区别就在于基准的选择上，随机快排是随机的选择基准，然后 待排序列：[6,5,4,3,2,1] ==下标 4 基准 2== [1, 2, 4, 3, 6, 5] ==下标 5 基准 5== [1, 2, 4, 3, 5, 6] ==下标 2 基准 4== [1, 2, 3, 4, 5, 6] 如上所示， 123456789101112131415161718192021222324252627282930import randomdef partation(l_A , left , right): p = left + int((right - left + 1) * random.random()) l_A[p] ,l_A[right] = l_A[right], l_A[p] pivot = l_A[right] # print('下标',p,'基准',pivot) pivot_index = left for i in range(left, right): if l_A[i] &lt;= pivot: l_A[i] ,l_A[pivot_index] = l_A[pivot_index], l_A[i] pivot_index += 1 if pivot_index != right: l_A[pivot_index] , l_A[right] = l_A[right] ,l_A[pivot_index] # print(l_A) return pivot_indexdef quick_sort(l_A, left , right): if left &gt;= right: return pivot_index = partation(l_A ,left, right) quick_sort(l_A,left,pivot_index -1) quick_sort(l_A, pivot_index+1 , right)if __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) quick_sort(A,0,len(A)-1) sorted_A_str = ",".join([str(i) for i in A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 3、选择排序3.1 选择排序​ Selection Sort ​ 插入排序的基本思路就是从未排序的序列里面选出一个最小的，然后将至放到已排序列的尾部后面元素交换位置，一直到待排序列为0. 待排序列：[5,4,3,2,1] [==1==,4,3,2,5] [1,==2==,3,4,5] [1,2,==3==,4,5] [1,2,3,==4==,5] [1,2,3,4,==5==] 如上所示，第一次，扫描全部序列，将最小的1选出来，然后将1与首位的数字5进行交换，然后第二次将最小数字2与数字4进行交换。 123456789101112131415161718def selection_sort(l_A): n = len(l_A) for i in range(0,n): swap_num = i for j in range(i + 1,n): if l_A[j] &lt; l_A[i]: swap_num = j if swap_num != i: l_A[i] , l_A[swap_num] = l_A[swap_num], l_A[i] return l_Aif __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) sorted_A = selection_sort(A) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 3.2 堆排序​ Heap Sort ​ 堆是完全二叉树，分为最大堆和最小堆，最大堆中，根节点都比其子节点要大，而最小堆中，根节点都比其子节点要小； ​ 最大堆的应用场景，例如带有优先级的排队进程，当系统空闲，优先处理优先级高的； ​ 最大堆主要有这样几个注意点： 建堆 删除根节点 插入一个节点 使用堆排序，主要是利用根节点一直是最大的性质，将根节点与最后面的儿子节点位置对调，堆的大小减一， 然后进行堆调整，然后再将根节点与莫为节点对调，再调整成堆，然后循环递归； 所以，堆排序主要是下面几个步骤： 将数组调整成堆 将根元素与堆的末尾元素对调，调整堆 重复第二步，直到堆的大小为1为止。 待排序列：[6,5,4,3,2,1] [5,4,3,2,1,==6==] [4,3,2,1,==5,6==] [3,2,1,==4,5,6==] [2,1,==3,4,5,6==] [==1,2,3,4,5,6==] 这一个较为特殊，默认就是堆的形式，第一步是调整成堆 1234567891011121314151617181920212223242526272829303132333435def heapify(l_A, node , size): left_child = 2 * node + 1 right_child = 2 * node + 2 max = node if left_child &lt; size and l_A[max] &lt; l_A[left_child] : max = left_child if right_child &lt; size and l_A[max] &lt; l_A[right_child] : max = right_child if max != node: l_A[max] , l_A[node] = l_A[node],l_A[max] heapify(l_A, max , size)def build_heap(l_A, size): heap_size = (size - 1) // 2 while heap_size &gt;= 0 : heapify(l_A, heap_size , size) heap_size -= 1 return l_Adef heap_sort(l_A): size = len(l_A) temp = build_heap(l_A, size) while size &gt; 1: size -= 1 l_A[0],l_A[size] = l_A[size],l_A[0] heapify(l_A,0, size) return tempif __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) sorted_A = heap_sort(A) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 4、插入排序4.1 直接插入排序 ​ 直接插入排序也是将待排序列分成两部分，其一是左面排好序的，然后是右面待排序，首先将待排序的第一个元素取出来，与排好序的序列机芯从右向左的比对，如果小于，则将此元素向右移动，一直找到当前元素应该放在的位置。 待排序列：[5,4,3,2,1] [==4,5==,3,2,1] [==3,4,5==,2,1] [==2,3,4,5==,1] [==1,2,3,4,5==] 如上，以高亮表示排好序的元素，然后第一次从待排序中，取出4，然后与5比较，将5向后移位，然后将4放到首位，剩下元素依次进行。 123456789101112131415161718def insertion_sort(l_A): n = len(l_A) for i in range(1,n): get = l_A[i] j = i - 1 while j &gt;= 0 and l_A[j] &gt; get: l_A[j+1] = l_A[j] j = j - 1 l_A[j+1] = get return l_Aif __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) sorted_A = insertion_sort(A) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 4.2 二分插入排序​ 二分插入排序是直接插入排序的改进版，主要针对于需要比对次数多的场景，例如有一个较小的元素，需要比对多次才能确定要插入的位置，使用二分法，提高查找效率。 待排序列：[6,5,4,3,2,1] [==5, 6==, 4, 3, 2, 1] [==4, 5, 6==, 3, 2, 1] [==3, 4, 5, 6==, 2, 1] [==2, 3, 4, 5, 6==, 1] [==1, 2, 3, 4, 5, 6==] 与前面基本相同，唯一不同的就是，在寻找要插入的位置的时候，使用了二分查找法。 1234567891011121314151617181920212223def binary_insertion_sort(l_A): n = len(l_A) for i in range(1, n): get = l_A[i] left = 0 right = i -1 while left &lt;= right: mid = (left+right)//2 if l_A[i] &lt; l_A[mid]: right = mid - 1 else: left = mid + 1 for j in range(i,left,-1): l_A[j] = l_A[j-1] l_A[left] = get return l_Aif __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) sorted_A = binary_insertion_sort(A) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 4.3 希尔排序​ 前面两种插入排序需要移动元素的次数还是太多，是否能够一次将元素移动多个位置，尽可能接近他本来的位置，希尔排序的基本思路就是使用一个递减增量，将待排序列分成多个子序列，进行插入排序，然后最后使用一次增量为1的直接插入排序。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 待排序列：[6,5,4,3,2,1] 增量序列：[4,1] 首先，取出增量4，将待排序列分成几个子序列： [6,2] [5,1] [4] [3] 分成了4个子序列，然后分别使用插入排序，对这4个子序列进行排序得到下面的结果：[2,1,4,3,6,5] 可以看到，6,5直接被移动到靠近他们办类的位置上了； 然后，使用增量1，再来使用插入排序 [==1, 2==, 4, 3, 6, 5] [==1, 2, 4==, 3, 6, 5] [==1, 2, 3, 4==, 6, 5] [==1, 2, 3, 4, 6==, 5] [==1, 2, 3, 4, 5, 6==] 1234567891011121314151617181920def shell_sort(l_A): n = len(l_A) h = n // 2 while h &gt;= 1: for i in range(h,n): get = l_A[i] j = i - h while j &gt;= 0 and l_A[j] &gt; get: l_A[j + h] = l_A[j] j -= h l_A[j+h] = get h = h // 2 return l_Aif __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) sorted_A = shell_sort(A) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) ​ 上面采用的增量序列为[3,1]，是利用h = n // 2获得，我们可以使用增量函数，或者直接使用增量序列。 5、归并排序 ​ 归并排序是建立在分治法上的典型应用，分为递归实现和非递归实现 基本步骤： 创建一个数组，能够存放两个已经有序的数组 两个分别指向两个有序数组起始位置的指针 比较指针指向的两个元素，将其中较小的放入和数组，指针加一 重复上面步骤，直到指针指向有序数组的末尾 将另一个未指向末尾的数组放入到和数组中 递归实现：[6,5,4,3,2,1] [5, 6] [4, 5, 6] [2, 3] [1, 2, 3] [1, 2, 3, 4, 5, 6] 上面为归并函数一次处理的有序数组，第一个表示将[6],[5]进行归并，以此类推； [5, 6, 4, 3, 2, 1] [4, 5, 6, 3, 2, 1] [4, 5, 6, 2, 3, 1] [4, 5, 6, 1, 2, 3] [1, 2, 3, 4, 5, 6] 上面表示待排数字的依次变化 非递归实现：[6,5,4,3,2,1] [5, 6] [3, 4] [1, 2] [3, 4, 5, 6] [1, 2, 3, 4, 5, 6] 上面表示非递归模式下，依次进行处理的有序数列； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def merge(l_A, left, mid, right): temp = [] i = left j = mid + 1 while i &lt;= mid and j &lt;= right: if l_A[i] &lt;= l_A[j]: temp.append(l_A[i]) i += 1 else: temp.append(l_A[j]) j += 1 while i &lt;= mid: temp.append(l_A[i]) i += 1 while j &lt;= right: temp.append(j) j += 1 l_A[left:right+1] = temp return l_Adef merge_recursion(l_A, left , right): if left == right: return mid = (left + right) // 2 merge_recursion(l_A,left,mid) merge_recursion(l_A,mid+1,right) merge(l_A,left,mid,right)def merge_iteration(l_A): length = len(l_A) i = 1 while i &lt; length : left = 0 while left + i &lt; length: mid = left + i -1 if mid + i &lt; length: right = mid + i else: right = length - 1 merge(l_A,left,mid,right) left = right + 1 i *= 2 # print(l_A) return l_Aif __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) # merge_recursion(A,0,len(A)-1) merge_iteration(A) sorted_A_str = ",".join([str(i) for i in A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 6、分布排序6.1 计数排序​ Counting Sort ​ 计数排序的思想：假如现在有10个数，[2,3,4,5,1,2,3,4,2,5]，如何能直接确定数字2在排好序的数组里面的位置呢？假如现在已经将数组中所有小于2的数的总数量统计了，如上面的数组，小于2的数一共有1个，那么在排好序的数组里面，2是从下标为1的数组中开始存储，占有的存储单元就是2个个数。 计数排序的步骤： 待排数组为A 初始化数组B，数据全部为0，数组大小为待排数组中最大的元素+1 扫描待排数组，统计元素个数，存放在数组B对应的下标中，例如3的个数，存放在B[3]中 然后，数组B中的每一个元素都是&lt;=当前下标数据之和 举个例子，如果B=[1,0,2,3,4,5] B[0] = B[0] B[1] = B[1]+B[0] B[2] = B[2]+B[1]+B[0] 使用循环控制的话，就能够使用如下表示： B[0] = B[0] B[1] = B[1]+B[0] B[2] = B[2]+B[1] 然后，我们就得到了每一个元素在排好序的数组中的最后一个位置 然后，创建数组C，与待排数组大小相同 从后向前扫描A，将出现的数放到C，存放位置为B[i],然后将i减一，表示下一个数字i的位置 待排数组：[6,5,4,3,2,1] 数组B：[0,1,1,1,1,1,1] 累加B：[0,1,2,3,4,5,6] 数组C：[1,0,0,0,0,0] 数组C：[1,2,0,0,0,0] 数组C：[1,2,3,0,0,0] 数组C：[1,2,3,4,0,0] 数组C：[1,2,3,4,5,0] 数组C：[1,2,3,4,5,6] 需要注意的是，我们计数是从1开始，二存储的时候，下标从0开始，所以需要将数组B中的数字减一，作为存储在C中的下标。 12345678910111213141516171819202122232425def counting_sort(l_A): ''' l_A：待排数组 ''' size = len(l_A) nums = max(l_A) + 1 temp_position_len = nums + 1 temp_position = [0 for i in range(temp_position_len)] temp_position_right = [0 for i in range(size)] for i in range(size): temp_position[l_A[i]] += 1 for i in range(1, len(temp_position)): temp_position[i] += temp_position[i-1] for i in range(size-1,-1,-1): temp_position_right[temp_position[l_A[i]] -1] = l_A[i] temp_position[l_A[i]] -= 1 l_A = temp_position_right return l_Aif __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) sorted_A = counting_sort(A) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 6.2 基数排序​ Radix Sort ​ 基数排序，其原理为利用数字不同位置的数码，进行排序；假如有这样的数组，[12,45,6,77,88]，我们发现数字最多两位，数码有10个，也就是0~9，我们创建10个数组，分别代表0~9, 第一次，将最低位相同的数字放到同样的数组里面，也就是最低位为1的数字放到表示1的数组中，将待排数组从前往后扫描，然后从第0个数组开始，将数据取出来，为了保障是稳定性，取出数据的时候，从后往前取出来，然后在扫描第二次，判断第二个数码； 待排数组: [89,88,77,6,5,4,3,2,1] 第一次扫描： 0数组：[] 1数组：[1] 2数组：[2] 3数组：[3] 4数组：[4] 5数组：[5] 6数组：[6] 7数组：[77] 8数组：[88] 9数组：[89] 放回待排数组：[1,2,3,4,5,6,77,88,89] 第2次扫描： 0数组：[1,2,3,4,5,6] 1数组：[] 2数组：[] 3数组：[] 4数组：[] 5数组：[] 6数组：[] 7数组：[] 8数组：[88,89] 9数组：[] 放回待排数组：[1,2,3,4,5,6,77,88,89] ​ 根据上面的思路，有两种实现思路： 第一种： ​ 创建多个数组，每个数组都代表一个数码，按照最大的数的位数进行循环操作 第二种： ​ 我们发现，在按照数码放到不同的素组里的思路，与前面的计数有些相似，如果按照不同的位数，进行计数排序，并且同时保证稳定性，也可以实现我们想要的操作。 第一种 123456789101112131415161718192021222324def get_digit(digit,position): num = digit // 10 ** position % 10 return num def radix_sort(l_A, digits, nums): size = len(l_A) temp_nums = [[] for i in range(digits)] for i in range(nums): for j in range(size): temp_nums[get_digit(l_A[j],i)].append(l_A[j]) l_A = [] for j in range(digits): for temp_item in range(len(temp_nums[j])): l_A.append(temp_nums[j].pop(0)) return l_Aif __name__ == '__main__': # A = [6,5,4,3,2,1] A = [33,44,13,6,7,8,33,45,90] A_str = ",".join([str(i) for i in A]) sorted_A = radix_sort(A,10,2 ) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 第二种 1234567891011121314151617181920212223242526272829303132333435def get_digit(digit,position): num = digit // 10 ** position % 10 return num def counting_sort(l_A ,nums,position,size): temp_position_len = nums temp_position = [0 for i in range(temp_position_len)] temp_position_right = [0 for i in range(size)] for i in range(size): temp_position[get_digit(l_A[i],position)] += 1 for i in range(1, len(temp_position)): temp_position[i] += temp_position[i-1] for i in range(size-1,-1,-1): temp_position_right[temp_position[get_digit(l_A[i],position)] -1] = l_A[i] temp_position[get_digit(l_A[i],position)] -= 1 l_A = temp_position_right return l_Adef radix_sort(l_A,digits, nums): ''' l_A：待排数组 digits：数码个数 nums：最大数的位数 ''' size = len(l_A) for i in range(nums): l_A = counting_sort(l_A, digits,i, size) return l_Aif __name__ == '__main__': A = [33,44,1000,13,6,7,8,33,45,990] A_str = ",".join([str(i) for i in A]) sorted_A = radix_sort(A,10,4 ) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 6.3 鸽巢排序​ Pigeonhole Sort ​ 鸽巢排序是一中种高速排序，但是需要很大的辅助空间； ​ 例如待排数组：[5,3,2,6,33,77]，就需要77-2+1=76个辅助空间 ​ 排序思路： 申请辅助空间 得到数组中的最大、最小值 扫描数组，将每个数减去最小值的数作为下标，将此下标中的数增加1 扫描辅助数组，将对应下标加上最小值，得到原来的数，放入待排数组 待排数组：[5,3,2,5,7] 辅助空间：[0,0,0,0,0,0] 最大值：7 最小值：2 扫描数组，处理辅助数组：[1,1,0,2,0,1] 扫描辅助数组，得到排序数组：[2,3,5,5,7] ​ 由上面可得，如果数据范围太大，或者说重复的数据很少，使用鸽巢排序不划算，只有在差值（或者可被映射在差值）很小的范围内的数值排序的情况下实用 12345678910111213141516171819202122232425def pigeonhole_sort(l_A): size = len(l_A) if size &gt; 1: max_value = max(l_A) min_value = min(l_A) else: return l_A assistant = [0 for i in range(max_value - min_value + 1)] for i in range(size): assistant[l_A[i]-min_value] += 1 l_A = [] for i in range(len(assistant)): while assistant[i] &gt;= 1: l_A.append(min_value+i) assistant[i] -= 1 return l_Aif __name__ == '__main__': A = [6,5,4,3,2,1] A_str = ",".join([str(i) for i in A]) sorted_A = pigeonhole_sort(A) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 6.4 桶排序​ Bucket Sort ​ 桶排序是将待排序列放到有限数量的桶里，然后在每个桶里，使用其他的排序算法，进行排序；桶由计数所决定； ​ 基本思路： 确定桶的数量 例如，我们输入的数据都在0到50之间，那么我们确定5个桶，0~10,11~20等 根据桶的数量，确定映射函数，也就是将能够确定相同的桶的依据 例如，根据上面说的，我们设置数据的十位数作为分桶依据，映射函数就是in/10 将数据分开，放在不同的桶中，也就是记住不同的桶之间的边界数据 比如说，使用计数算法，将不同的边界分开 在桶内使用排序算法进行排序 待排序列：[33,9,11,4,22,44,5,6] 桶的数量：5 映射函数：x//10 ==python中，//表示整除== 分桶：[9,4,5,6,11,22,33,44] 边界数据：[4,1,1,1,1] 桶内排序：[4,5,6,9,11,22,33,44] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def map2bucket(number): return number // 10def insert_sort(l_A,left,right): if left == right: return l_A length = right - left + 1 for i in range(1,length): get = l_A[i] j = i-1 while j &gt;=0 and l_A[j] &gt; get: l_A[j+1] = l_A[j] j -= 1 l_A[j+1] = get return l_Adef counting_sort(l_A, nums): ''' l_A：待排数组 nums：桶的数量 ''' size = len(l_A) temp_position_len = nums temp_position = [0 for i in range(temp_position_len)] temp_position_right = [0 for i in range(size)] for i in range(size): temp_position[map2bucket(l_A[i])] += 1 for i in range(1, len(temp_position)): temp_position[i] += temp_position[i-1] boundary = temp_position.copy() for i in range(size-1,-1,-1): temp_position_right[temp_position[map2bucket(l_A[i])] -1] = l_A[i] temp_position[map2bucket(l_A[i])] -= 1 l_A = temp_position_right return l_A, boundarydef bucket_sort(l_A, bucket_nums): temp_l_A, boundary = counting_sort(l_A, bucket_nums) for i in range(bucket_nums): left = boundary[i] if left &gt;= len(l_A): left = 0 if i &gt;= bucket_nums - 1 : right = boundary[0] - 1 else: right = boundary[i+1] -1 temp_l_A = insert_sort(temp_l_A, left,right) return temp_l_Aif __name__ == '__main__': A = [6,5,4,3,2,1,11,33,22,44] A_str = ",".join([str(i) for i in A]) sorted_A = bucket_sort(A, 5) sorted_A_str = ",".join([str(i) for i in sorted_A]) print("待排序列：",A_str) print("已排序列：",sorted_A_str) 7、参考资料数据结构与算法动态可视化： https://visualgo.net/zh 可视化排序：http://panthema.net/2013/sound-of-sorting/# wiki排序算法：排序算法]]></content>
      <categories>
        <category>sorting</category>
      </categories>
      <tags>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1. 两数之和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%201.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述12345678910给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 2、解题思路2.1 解题1​ 一般我们第一时间就能想到的思路，就是用双重for循环来遍历一遍，肯定可以得到结果； 1234循环1：元素1 in 数组 循环2：元素2 in 数组 判断：元素1与元素2不是同一个元素 and 它们之和等于目标值： 返回元素1和元素2的下标 12345678910111213int* twoSum(int* nums, int numsSize, int target) &#123; int* result = (int*)malloc(sizeof(int)*2); for (int i = 0;i&lt; numsSize-1; i++)&#123; for(int j = i+1; j &lt;numsSize;j++ )&#123; if (nums[i] + nums[j] == target)&#123; result[0] = i; result[1] = j; return result; &#125; &#125; &#125; return result;&#125; 2.2 解题2​ 双重for循环会浪费时间和空间，并且有这样的一个缺点，就是已经计算过的值，并不会保存，每一次的计算，与前面的计算没有关系，如果我们每一次计算都能利用前面计算的结果，那么效率应该会提高。 123456创建一个容器：buff #使用buff存储下标和目标值与当前值的差值循环： 元素 in 数组 判断： 如果当前值在容器中存在 返回：容器中的值下标，当前下标 判断： 不存在 将当前值得下标与(目标值-当前值)存储倒容器中 ​ 实际上，这里利用了一个缓冲容器的思路，将差值作为键，下标作为值存储到字典中，那么实际上我们只需要用一层循环就可以了，每一次都将前面元素的差值存储，那么每遇到一个元素，判断一下这个值在是不是在字典中，如果在，那么这个值与字典中的下标所代表的值之和肯定就是目标值，时间复杂度是O(n)。 3、参考代码1Python版本：3 12345678class Solution(object): def twoSum(self, nums, target): buff_dict = &#123;&#125; for i in range(len(nums)): if nums[i] in buff_dict: return [buff_dict[nums[i]], i] else: buff_dict[target - nums[i]] = i]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 100. 相同的树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20100.%C2%A0%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 1234567输入: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2: 1234567输入: 1 1 / \ 2 2 [1,2], [1,null,2]输出: false 示例 3: 1234567输入: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]输出: false 2、解题思路123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */bool isSameTree(struct TreeNode* p, struct TreeNode* q) &#123; if(!p &amp;&amp; !q)&#123; return true; &#125; if (p &amp;&amp; !q || !p &amp;&amp; q || p-&gt;val != q-&gt;val || !p-&gt;left &amp;&amp; q-&gt;left || p-&gt;right &amp;&amp; !q-&gt;right) &#123; return false; &#125; return isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 102. 二叉树的层次遍历]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20102.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 2、解题思路​ 借助数据结构，如队列，存储当前行的节点 ​ 然后将当前行的节点的子节点放入队列中，并将当前节点弹出，放入结果数组中 1234567891011121314151617181920212223242526272829303132333435# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneimport queueclass Solution: def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] result = [] q = queue.Queue() q.put(root) while not q.empty(): temp = [] size = q.qsize() for i in range(size): node = q.get() if node.left: q.put(node.left) if node.right: q.put(node.right) temp.append(node.val) result.append(temp) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 105. 从前序与中序遍历序列构造二叉树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20105.%C2%A0%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 2、解题思路​ 根据前序遍历，我们直接能够找到当前的根节点是哪个 ​ 然后找到在中序遍历中的位置，左面的就是左子树的中序遍历结果，右面的就是右子树的遍历结果 ​ 这样我们就能进行递归了，生成一个根节点，然后将左子树的前序遍历，中序遍历递归，得到了左子树；右子树的前序遍历结果与中序遍历结果递归，得到右子树 ​ 12345678910111213141516171819202122232425262728293031# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, preorder, inorder): """ :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode """ if len(preorder) &lt;= 0: return None root = TreeNode(preorder[0]) root_index = inorder.index(preorder[0]) inorder_left_subTree = inorder[:root_index] inorder_right_subTree = inorder[root_index + 1:] preorder_left_subTree = preorder[1:len(inorder_left_subTree)+1] preorder_right_subTree = preorder[len(inorder_left_subTree)+1:] root.left = self.buildTree(preorder_left_subTree, inorder_left_subTree) root.right = self.buildTree(preorder_right_subTree, inorder_right_subTree) return root ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 103. 二叉树的锯齿形层次遍历]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20103.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回锯齿形层次遍历如下： 12345[ [3], [20,9], [15,7]] 2、解题思路​ 与前面102题基本差不多，只需要加一个控制变量，不断地将每一行的元素反转，放到结果数组中即可 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneimport queueclass Solution: def zigzagLevelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] result = [] q = queue.Queue() reverse_list = False q.put(root) while not q.empty(): temp = [] size = q.qsize() for i in range(size): node = q.get() if node.left: q.put(node.left) if node.right: q.put(node.right) temp.append(node.val) if not reverse_list: result.append(temp) else: result.append(list(reversed(temp))) reverse_list = not reverse_list return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 104. 二叉树的最大深度]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 2、解题思路12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */int maxDepth(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int left = 0; int right = 0; if (root-&gt;left) &#123; left = maxDepth(root-&gt;left); &#125; if (root-&gt;right) &#123; right = maxDepth(root-&gt;right); &#125; return left &gt; right ? left + 1 : right + 1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 106. 从中序与后序遍历序列构造二叉树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20106.%C2%A0%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 2、解题思路​ 在前面105题中，使用前序遍历和中序遍历得到二叉树一样，后序遍历就是根节点放在了最后，其他的与前面没有区别 12345678910111213141516171819202122232425262728293031# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, inorder, postorder): """ :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode """ if len(inorder) &lt;= 0: return None root = TreeNode(postorder[-1]) root_index = inorder.index(postorder[-1]) inorder_left_subTree = inorder[:root_index] inorder_right_subTree = inorder[root_index + 1:] postorder_left_subTree = postorder[:len(inorder_left_subTree)] postorder_right_subTree = postorder[len(inorder_left_subTree):-1] root.left = self.buildTree(inorder_left_subTree, postorder_left_subTree) root.right = self.buildTree(inorder_right_subTree, postorder_right_subTree) return root]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 109. 有序链表转换二叉搜索树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20109.%C2%A0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 2、解题思路​ 在前面，108题中，是数组的形式，每一次找到中间值，然后分成左右两部分，递归操作 ​ 但是在数组中，找到中间值很简单，在链表中，找到中间值可以利用两个指针，一个快，一个慢，块的每一次走两步，慢的走一步，这样慢的指针就是想要找的中间值 ​ 一开始想到的是利用从头开始走的，不过超出了时间限制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def sortedListToBST(self, head): """ :type head: ListNode :rtype: TreeNode """ left = 0 right = self.getLength(head) - 1 return self.dfs(head, left, right) def dfs(self, root, left, right): if left &gt; right: return None mid = (left + right+1) // 2 mid_temp = mid temp = root mid_val = root.val while mid_temp &gt; 0: temp = temp.next mid_val = temp.val mid_temp -= 1 result = TreeNode(mid_val) result.left = self.dfs(root, left, mid - 1) result.right = self.dfs(root, mid + 1, right) return result def getLength(self, root): if not root: return 0 count = 0 while root: count += 1 root = root.next return count ​ 利用双指针求中间值 1234567891011121314151617181920212223242526272829303132333435363738394041# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def sortedListToBST(self, head): """ :type head: ListNode :rtype: TreeNode """ if not head: return None return self.dfs(head, None) def dfs(self, head, tail): if head == tail: return None faster = head slower = head while faster != tail: faster = faster.next if faster != tail: faster = faster.next slower = slower.next node = TreeNode(slower.val) node.left = self.dfs(head, slower) node.right = self.dfs(slower.next, tail) return node]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 108. 将有序数组转换为二叉搜索树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 2、解题思路2.1 递归法​ 判断当前节点是不是空，是则返回NULL ​ 构造一个节点，使用中间的元素做为value ​ 然后递归求解左子树和右子树 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */struct TreeNode* sortedArrayToBST(int* nums, int numsSize) &#123; if (numsSize == 0) &#123; return NULL; &#125; struct TreeNode *result = (struct TreeNode *) malloc(sizeof(struct TreeNode)); result-&gt;val = nums[numsSize / 2]; if (numsSize / 2 == 0) &#123; result-&gt;left = NULL; &#125; else &#123; result-&gt;left = sortedArrayToBST(nums, numsSize / 2); &#125; // 已经到了最右面 if (numsSize / 2 &gt;= (numsSize - 1)) &#123; result-&gt;right = NULL; &#125; else &#123; result-&gt;right = sortedArrayToBST(&amp;nums[numsSize / 2 + 1], numsSize - numsSize / 2 - 1); &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 11. 盛最多水的容器]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2011.%C2%A0%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 注意：你不能倾斜容器，n 至少是2。 2、解题思路​ 一般能直接想到的就是暴力破解法，但是这个效率实在太差了 ​ 换个思路的话，我们从两边开始找起 ​ 考虑到盛水的容器仅与段的那个数字相关，我们设置两个指针，指向两头，然后不断地向中间移动，直到两个相遇为止，每一次都是小的边向长的边移动靠拢，这样能保证我们尽可能减少损失，找出最大的面积 ​ 1234567891011121314151617181920#define min(a, b) (a&lt;b?a:b)#define max(a, b) (a&gt;b?a:b)int maxArea(int* height, int heightSize) &#123; int left = 0; int right = heightSize - 1; int area = 0; while (left &lt; right) &#123; area = max(area, (right - left) * min(height[left], height[right])); if (height[left] &lt; height[right]) &#123; left++; &#125; else &#123; right--; &#125; &#125; return area;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 107. 二叉树的层次遍历 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20107.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其自底向上的层次遍历为： 12345[ [15,7], [9,20], [3]] 2、解题思路​ 首先判断是不是空，为空直接返回 ​ 然后创建一个队列，将根节点放到队列中 ​ 然后判断烈烈中有几个元素，就是当前层次的节点数 ​ 接着，依次取出队列中的元素，并且将其子节点加入到队列中 ​ 如果队列为空，表示已经便利完成 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if(root == null)&#123; return list; &#125; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; //获取当前层的节点数 int levelNum = queue.size(); List&lt;Integer&gt; subList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; levelNum; i++) &#123; TreeNode node = queue.poll(); subList.add(node.val); if(node.left != null)&#123; queue.offer(node.left); &#125; if(node.right != null)&#123; queue.offer(node.right); &#125; &#125; list.add(0,subList); &#125; return list; &#125;&#125; ​ 从根节点开始，判断当前的层次是不是在数组中，如果不在，new一个 ​ 然后将当前值加入对应的层次中去 ​ 不断递归 ​ 最后将集合逆序返回 12345678910111213141516class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; list=new ArrayList&lt;List&lt;Integer&gt;&gt;(); addLevel(list,0,root); Collections.reverse(list); return list; &#125; public void addLevel(List&lt;List&lt;Integer&gt;&gt; list, int level, TreeNode node)&#123; if(node==null)return ; if(list.size()-1&lt;level)list.add(new ArrayList&lt;Integer&gt;()); list.get(level).add(node.val); addLevel(list,level+1,node.left); addLevel(list,level+1,node.right); &#125; &#125; C语言实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; *//** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *columnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int maxDepth(struct TreeNode *root) &#123; if (!root) &#123; return 0; &#125; int left = 0; int right = 0; if (root-&gt;left) &#123; left = maxDepth(root-&gt;left); &#125; if (root-&gt;right) &#123; right = maxDepth(root-&gt;right); &#125; return left &gt; right ? left + 1 : right + 1;&#125;void init_pointer(struct TreeNode **buf, int size) &#123; for (int i = 0; i &lt; size; i++) &#123; buf[i] = NULL; &#125;&#125;int **levelOrderBottom(struct TreeNode *root, int **columnSizes, int *returnSize) &#123; if (!root) &#123; return NULL; &#125; *returnSize = maxDepth(root); int **return_array = (int **) malloc(sizeof(int *) * (*returnSize)); *columnSizes = (int *) malloc(sizeof(int) * (*returnSize)); int line_nums = 1; int line_nums_child = 0; int buf_size = 1; // 用buf_array存储每一行所有的元素的指针 struct TreeNode **buf_array_father = (struct TreeNode **) malloc(sizeof(struct TreeNode *) * 2); struct TreeNode **buf_array_child = (struct TreeNode **) malloc(sizeof(struct TreeNode *) * 3); init_pointer(buf_array_father, 2); init_pointer(buf_array_child, 3); buf_array_father[0] = root; int *cur_line; struct TreeNode **temp; for (int line_count = 0; line_count &lt; *returnSize; line_count++) &#123; cur_line = (int *) malloc(sizeof(int) * line_nums); return_array[line_count] = cur_line; // 存放每一行的元素个数 int *cur_column = (*columnSizes) + line_count; *cur_column = 0; temp = buf_array_father; // 将下一行放到缓冲里面 while (*buf_array_father) &#123; if ((*buf_array_father)-&gt;left) &#123; buf_array_child[line_nums_child++] = (*buf_array_father)-&gt;left; &#125; if ((*buf_array_father)-&gt;right) &#123; buf_array_child[line_nums_child++] = (*buf_array_father)-&gt;right; &#125; cur_line[(*cur_column)++] = (*buf_array_father)-&gt;val; buf_array_father++; &#125; free(temp); buf_array_father = buf_array_child; buf_array_child = (struct TreeNode **) malloc(sizeof(struct TreeNode *) * (line_nums_child * 2 + 1)); init_pointer(buf_array_child, (line_nums_child * 2 + 1)); line_nums = line_nums_child; line_nums_child = 0; &#125; free(buf_array_father); free(buf_array_child); int *temp_reverse; int size_temp; for (int i = 0; i &lt; ((*returnSize) / 2); i++) &#123; temp_reverse = return_array[i]; return_array[i] = return_array[(*returnSize) - 1 - i]; return_array[(*returnSize) - 1 - i] = temp_reverse; size_temp = *((*columnSizes) + i); *((*columnSizes) + i) = *((*columnSizes) + (*returnSize) - 1 - i); *((*columnSizes) + (*returnSize) - 1 - i) = size_temp; &#125; return return_array;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 110. 平衡二叉树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 12345 3 / \9 20 / \ 15 7 返回 true 。示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 2、解题思路​ 判断左右子树的深度是多少，如果左右子树是平衡树，并且左右子树的高度差不超过1，返回真 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */int getDepth(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int left = 0; int right = 0; if (root-&gt;left) &#123; left = getDepth(root-&gt;left); &#125; if (root-&gt;right) &#123; right = getDepth(root-&gt;right); &#125; return left &gt; right ? left + 1 : right + 1;&#125;bool isBalanced(struct TreeNode* root) &#123; if(!root)&#123; return true; &#125; bool result = false; int left = 0; int right = 0; if(root-&gt;left)&#123; left = getDepth(root-&gt;left); &#125; if (root-&gt;right)&#123; right = getDepth(root-&gt;right); &#125; if ((left-right &gt;= -1) &amp;&amp; (left-right &lt;= 1))&#123; result = true; &#125; result = result &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 111 . 二叉树的最小深度]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20111%20.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述12345678910111213141516给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明: 叶子节点是指没有子节点的节点。示例:给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7返回它的最小深度 2. 2、解题思路12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */int minDepth(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int left = 0; int right = 0; int result = 0; if (root-&gt;left) &#123; left = minDepth(root-&gt;left); result = left+1; &#125;else&#123; result = left = INT_MAX; &#125; if (root-&gt;right) &#123; right = minDepth(root-&gt;right); result = result &gt; right+1 ? right + 1 : result; &#125; if(result == INT_MAX)&#123; result = 1; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 112. 路径总和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20112.%C2%A0%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 2、解题思路123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */bool hasPathSum(struct TreeNode* root, int sum) &#123; if (!root) &#123; return false; &#125; int sub_num = sum - root-&gt;val; bool left_path = false; bool right_path = false; if (root-&gt;left) &#123; left_path = hasPathSum(root-&gt;left, sub_num); &#125; if (root-&gt;right) &#123; right_path = hasPathSum(root-&gt;right, sub_num); &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; if (sub_num == 0) &#123; return true; &#125;else&#123; return false; &#125; &#125; else &#123; return left_path || right_path; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 113. 路径总和 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20113.%C2%A0%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 返回: 1234[ [5,4,11,2], [5,8,4,5]] 2、解题思路​ 看到这道题，直接想到用dfs来做 ​ 每次传入当前节点的想要求解的和，然后减去当前节点的值，判断，当前节点是不是叶子节点，然后如果是，并且和是0，放入结果数组 ​ 12345678910111213141516171819202122232425262728293031323334# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] result = [] self.dfs(root, sum, [], result) return result def dfs(self, root, cur_sum, current, result): temp_sum = cur_sum - root.val if not root.left and not root.right and temp_sum == 0: current.append(root.val) result.append(current) return if root.left: left_temp = current[:] + [root.val] self.dfs(root.left, temp_sum, left_temp, result) if root.right: right_temp = current[:] + [root.val] self.dfs(root.right, temp_sum, right_temp, result)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 114. 二叉树展开为链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20114.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 12345 1 / \ 2 5 / \ \3 4 6 将其展开为： 12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 2、解题思路2.1 递归法​ 一般看到二叉树，第一个想到的就是递归求解 ​ 首先，我们来分析一下将二叉树展开成链表的规律 对根节点来讲，如果左子树和右子树都展开了，直接将左子树中最右端的端点的右指针指向当前的右子树，左子树变成右子树，左子树变成None即可 对每个节点来讲，都是如此 那么使用什么方式，将左右子树变成链表呢？ 首先我们确定，左右子树应该是已经变成链表以后进行操作，所以，应该是后续遍历 12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def flatten(self, root): """ :type root: TreeNode :rtype: void Do not return anything, modify root in-place instead. """ if not root: return None self.flatten(root.left) self.flatten(root.right) if root.left: temp = root.right left_node = root.left while left_node.right: left_node = left_node.right root.right = root.left root.left = None left_node.right = temp 2.2 非递归法​ 实际上还可以用非递归法，比如说我们知道，当前节点的右子树应该放在什么位置呢？ ​ 就是当前节点左子树的最右节点的后面，我们直接把它放过去，然后，指针后移，如果有左子树，就把右子树放到左子树的最右面节点的后面 ​ 以此类推，直到最后一个节点，所有的就都被变成了链表了 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def flatten(self, root): """ :type root: TreeNode :rtype: void Do not return anything, modify root in-place instead. """ if not root: return None while root: if root.left: temp = root.right left_node = root.left while left_node.right: left_node = left_node.right root.right = root.left root.left = None left_node.right = temp root = root.right]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 116. 填充同一层的兄弟节点]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20116.%C2%A0%E5%A1%AB%E5%85%85%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个二叉树 12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 说明: 你只能使用额外常数空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 你可以假设它是一个完美二叉树（即所有叶子节点都在同一层，每个父节点都有两个子节点）。 示例: 给定完美二叉树， 12345 1 / \ 2 3 / \ / \4 5 6 7 调用你的函数后，该完美二叉树变为： 12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL 2、解题思路2.1 递归求解​ 首先，因为是完美二叉树，那么下一行的判断就能够依据上一行的结果 给定一个节点，如果当前节点有左子树，右子树，就将左子树指向右子树，右子树指向父节点的兄弟节点的左子树 123456789101112131415161718192021# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return if not root.left: return root.left.next = root.right if root.next: root.right.next = root.next.left self.connect(root.left) self.connect(root.right) 2.2 非递归法​ 实际上，不一定要用递归来做，也可以通过遍历每一行来做，也是借助上一行的结果，设置两个指针，一个指向最左端，从最左端移动到最右端 ​ 123456789101112131415161718192021222324252627# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return if not root.left: return line_start = root while line_start.left: cur = line_start while cur: cur.left.next = cur.right if cur.next: cur.right.next = cur.next.left cur = cur.next line_start = line_start.left]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 117. 填充同一层的兄弟节点 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20117.%C2%A0%E5%A1%AB%E5%85%85%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树 12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 说明: 你只能使用额外常数空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例: 给定二叉树， 12345 1 / \ 2 3 / \ \4 5 7 调用你的函数后，该二叉树变为： 12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \4-&gt; 5 -&gt; 7 -&gt; NULL 2、解题思路​ 这道题和前面116的区别就在于这个二叉树不是完美二叉树，可能是没有左子树，或者没有右子树 ​ 所以，每一行想要找到第一个元素很关键，所以，我们创建一个节点，这个节点指向每一行的第一个元素 ​ 然后每一行修改完毕以后，移动到下一行 ​ 12345678910111213141516171819202122232425262728293031323334# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return if not root.left and not root.right: return first_node = TreeLinkNode(0) left = first_node while root: if root.left: left.next = root.left left = root.left if root.right: left.next = root.right left = root.right root = root.next if not root: left = first_node root = first_node.next first_node.next = None]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 118. 杨辉三角]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 2、解题思路1234567891011121314151617181920212223242526272829303132/** * Return an array of arrays. * The sizes of the arrays are returned as *columnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** generate(int numRows, int** columnSizes) &#123; if (numRows &lt;= 0) &#123; return NULL; &#125; int cur_pos = 0; int **result = (int **) malloc(sizeof(int *) * numRows); int *cur_line; *columnSizes = (int *) malloc(sizeof(int) * numRows); for (int count = 1; count &lt;= numRows; count++) &#123; (*columnSizes)[count - 1] = count; cur_line = (int *) malloc(sizeof(int) * count); result[count - 1] = cur_line; cur_line[cur_pos++] = 1; while (cur_pos &lt; (count - 1)) &#123; cur_line[cur_pos] = result[count - 2][cur_pos - 1] + result[count - 2][cur_pos]; cur_pos++; &#125; if(count&gt;1)&#123; cur_line[cur_pos] = 1; &#125; cur_pos = 0; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 12. 整数转罗马数字]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2012.%C2%A0%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 12输入: 3输出: &quot;III&quot; 示例 2: 12输入: 4输出: &quot;IV&quot; 示例 3: 12输入: 9输出: &quot;IX&quot; 示例 4: 123输入: 58输出: &quot;LVIII&quot;解释: C = 100, L = 50, XXX = 30, III = 3. 示例 5: 123输入: 1994输出: &quot;MCMXCIV&quot;解释: M = 1000, CM = 900, XC = 90, IV = 4. 2、解题思路​ 对不同的位上的数字进行判断，要么是小于4的，等于4，等于5，5到9，等于9，只有这几种情况 ​ 实际上，可以直接将所有的可能性变成列表，这样更加简单 ​ 12345678910111213141516171819202122232425262728class Solution: def intToRoman(self, num): """ :type num: int :rtype: str """ if num &lt;= 0: return "" roam = [&#123;1: "M"&#125;, &#123;1: "C", 5: "D", 4: "CD", 9: "CM"&#125;, &#123;1: "X", 5: "L", 4: "XL", 9: "XC"&#125;, &#123;1: "I", 5: "V", 4: "IV", 9: "IX"&#125;] result = "" temp = num for i in range(3, -1, -1): digit = (temp // 10 ** i) % 10 if digit &gt; 0: if digit &lt; 4: result += roam[3 - i][1] * digit elif digit == 4: result += roam[3 - i][4] elif digit == 5: result += roam[3 - i][5] elif digit &gt; 5 and digit &lt; 9: result += roam[3 - i][5] + roam[3 - i][1] * (digit - 5) elif digit == 9: result += roam[3 - i][9] return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 119. 杨辉三角 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 12输入: 3输出: [1,3,3,1] 进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？ 2、解题思路​ 实际上，杨辉三角就是多项式的展开式的系数， ​ 因此，可以用组合公式直接求解 ​ 例如第一行 $C^{0}_{0}$ 第二行 $C^{0}{1}$ $C^{1}{1}$ 第三行 $C^{0}{2}$ $C^{1}{2}$ $C^{2}_{2}$ 因此，根据这个规律，以及对称性，只需要用公式将左半部分计算出来，右半部分直接赋值就好了 实际在实现的时候，发现在进行求组合的时候，出现了溢出，为了防止溢出，进行约分处理 约分的时候，为了效率起见，先求出了质数数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include "stdio.h"#include "string.h"struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right;&#125;;int *findPrimes(int num, int *numSize) &#123; if (num &lt;= 1) &#123; *numSize = 0; return NULL; &#125; int *result = (int *) malloc(sizeof(int) * (num / 2 + 1)); result[0] = 2; *numSize = 1; int cur_num = 3; bool isPrime = true; while (cur_num &lt;= num) &#123; isPrime = true; for (int i = 0; i &lt; *numSize; i++) &#123; if (cur_num % result[i] == 0) &#123; isPrime = false; break; &#125; &#125; if (isPrime) &#123; result[(*numSize)++] = cur_num; &#125; cur_num++; &#125; return result;&#125;int combination(int total, int chose) &#123; if (chose == 0) &#123; return 1; &#125; else if (chose == 1) &#123; return total; &#125; int total_left = total - chose &gt; chose ? total - chose : chose; int chose_right = total - chose &gt; chose ? chose : total - chose; // 找到所有小于chose_right 的质数 int primeSize = 0; int *primes = findPrimes(chose_right, &amp;primeSize); int *buff_total = (int *) malloc(sizeof(int) * (total - total_left)); int *buff_chose = (int *) malloc((sizeof(int) * (chose_right - 1))); // 缓冲初始化 for (int i = total_left + 1; i &lt;= total; i++) &#123; buff_total[i - total_left - 1] = i; &#125; for (int i = 2; i &lt;= chose_right; i++) &#123; buff_chose[i - 2] = i; &#125; // 进行约分 bool reduction = false; while (!reduction) &#123; reduction = true; for (int i = 0; i &lt; chose_right - 1; i++) &#123; for (int j = 0; j &lt; primeSize; j++) &#123; if (buff_chose[i] != 1 &amp;&amp; buff_chose[i] % primes[j] == 0) &#123; buff_chose[i] /= primes[j]; for (int k = 0; k &lt; total - total_left; k++) &#123; if (buff_total[k] != 1 &amp;&amp; buff_total[k] % primes[j] == 0) &#123; buff_total[k] /= primes[j]; break; &#125; &#125; if (buff_chose[i] != 1) &#123; reduction = false; &#125; break; &#125; &#125; &#125; &#125; int result = 1; for (int i = 0; i &lt; total - total_left; i++) &#123; result *= buff_total[i]; &#125; free(buff_total); free(buff_chose); free(primes); return result;&#125;int *getRow(int rowIndex, int *returnSize) &#123; if (rowIndex &lt; 0) &#123; return NULL; &#125; rowIndex++; int *result = (int *) malloc(sizeof(int) * rowIndex); *returnSize = rowIndex; // 计算左面半边的值 for (int i = 0; i &lt; (rowIndex + 1) / 2; i++) &#123; result[i] = combination(rowIndex - 1, i); &#125; // 将左半部分的值赋值到右面 for (int i = 0; i &lt; rowIndex / 2; i++) &#123; result[rowIndex - 1 - i] = result[i]; &#125; return result;&#125;void pprint(int *a, int b) &#123; for (int i = 0; i &lt; b; i++) &#123; printf("%d ", a[i]); &#125; printf("\n");&#125;int main() &#123;// printf("%d\n", combination(4, 2)); int r = 0; for (int i = 0; i &lt; 31; i++) &#123; int *a = getRow(i, &amp;r); pprint(a, r); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/Users/zhangguohao/CLionProjects/untitled/cmake-build-debug/untitled1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 1 10 45 120 210 252 210 120 45 10 1 1 11 55 165 330 462 462 330 165 55 11 1 1 12 66 220 495 792 924 792 495 220 66 12 1 1 13 78 286 715 1287 1716 1716 1287 715 286 78 13 1 1 14 91 364 1001 2002 3003 3432 3003 2002 1001 364 91 14 1 1 15 105 455 1365 3003 5005 6435 6435 5005 3003 1365 455 105 15 1 1 16 120 560 1820 4368 8008 11440 12870 11440 8008 4368 1820 560 120 16 1 1 17 136 680 2380 6188 12376 19448 24310 24310 19448 12376 6188 2380 680 136 17 1 1 18 153 816 3060 8568 18564 31824 43758 48620 43758 31824 18564 8568 3060 816 153 18 1 1 19 171 969 3876 11628 27132 50388 75582 92378 92378 75582 50388 27132 11628 3876 969 171 19 1 1 20 190 1140 4845 15504 38760 77520 125970 167960 184756 167960 125970 77520 38760 15504 4845 1140 190 20 1 1 21 210 1330 5985 20349 54264 116280 203490 293930 352716 352716 293930 203490 116280 54264 20349 5985 1330 210 21 1 1 22 231 1540 7315 26334 74613 170544 319770 497420 646646 705432 646646 497420 319770 170544 74613 26334 7315 1540 231 22 1 1 23 253 1771 8855 33649 100947 245157 490314 817190 1144066 1352078 1352078 1144066 817190 490314 245157 100947 33649 8855 1771 253 23 1 1 24 276 2024 10626 42504 134596 346104 735471 1307504 1961256 2496144 2704156 2496144 1961256 1307504 735471 346104 134596 42504 10626 2024 276 24 1 1 25 300 2300 12650 53130 177100 480700 1081575 2042975 3268760 4457400 5200300 5200300 4457400 3268760 2042975 1081575 480700 177100 53130 12650 2300 300 25 1 1 26 325 2600 14950 65780 230230 657800 1562275 3124550 5311735 7726160 9657700 10400600 9657700 7726160 5311735 3124550 1562275 657800 230230 65780 14950 2600 325 26 1 1 27 351 2925 17550 80730 296010 888030 2220075 4686825 8436285 13037895 17383860 20058300 20058300 17383860 13037895 8436285 4686825 2220075 888030 296010 80730 17550 2925 351 27 1 1 28 378 3276 20475 98280 376740 1184040 3108105 6906900 13123110 21474180 30421755 37442160 40116600 37442160 30421755 21474180 13123110 6906900 3108105 1184040 376740 98280 20475 3276 378 28 1 1 29 406 3654 23751 118755 475020 1560780 4292145 10015005 20030010 34597290 51895935 67863915 77558760 77558760 67863915 51895935 34597290 20030010 10015005 4292145 1560780 475020 118755 23751 3654 406 29 1 1 30 435 4060 27405 142506 593775 2035800 5852925 14307150 30045015 54627300 86493225 119759850 145422675 155117520 145422675 119759850 86493225 54627300 30045015 14307150 5852925 2035800 593775 142506 27405 4060 435 30 1 Process finished with exit code 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 120. 三角形最小路径和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20120.%C2%A0%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 ​ 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 2、解题思路​ 通过上面的描述，第一时间能够想到的就是动态规划，这个动态规划与一般的不一样，之前做的题目的状态都是某个节点的状态依赖于其他的一个或几个节点，但这里不太一样的就是，我们要将每一行看作是一个状态，上一行依赖于下一行 ​ 因此，我们设计一个缓冲数组即可，长度为n，从下向上进行计算，左后一行比较特殊，直接赋值即可 倒数第二行，每一个数字都是当前数字和下面一行的数字之和中更小的那个 举个例子， 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 一开始，缓冲数组赋值为最后一行的值 1[4,1,8,3] 然后，计算前面一行的值，这时候，需要考虑一下下面一行的相邻节点的值 12345678910首先是6，他的相邻节点是4，1和值为10，7，我们取最小的，7，放到开头[7,1,8,3]然后是5，他的相邻节点是1，8和值是6，13，取最小值6[7,6,8,3]然后是7，他的相邻节点是8，3和值为15，10，取最小值10[7,6,10,3]这样，第三行的数据就处理完了，以此类推，处理到最后的第一行的时候，位于行首的元素就是我们所要的答案 1234567891011121314151617class Solution: def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ length = len(triangle) if length == 1: return triangle[0][0] line = triangle[-1][:] for i in range(length - 2, -1, -1): for j in range(i + 1): line[j] = min(triangle[i][j] + line[j], triangle[i][j] + line[j+1]) return line[0]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 121. 买卖股票的最佳时机]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20121.%C2%A0%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 2、解题思路2.1 迭代法​ 一开始的想法，先将所有的右面有大于它的数的下标找出来，然后分别将每个数字对应的最大间隔找出来，进行比较 ​ 有点浪费时间 123456789101112131415161718192021222324252627282930313233343536int maxProfit(int* prices, int pricesSize) &#123; if (!prices || pricesSize &lt;= 1) &#123; return 0; &#125; // 首先找到几个下标，在右面有比当前数大的数字 bool right_bigger = false; int *buf = (int *) malloc(sizeof(int) * pricesSize - 1); int buf_size = 0; for (int i = 0; i &lt; pricesSize - 1; i++) &#123; for (int j = i + 1; j &lt; pricesSize; j++) &#123; if (prices[i] &lt; prices[j]) &#123; buf[buf_size++] = i; break; &#125; &#125; &#125; if (buf_size &lt;= 0) &#123; return 0; &#125; int result = 0; //int min_pos = buf[0]; for (int i = 0; i &lt; buf_size; i++) &#123; for (int j = buf[i] + 1; j &lt; pricesSize; j++) &#123; if (prices[j] - prices[buf[i]] &gt; result) &#123; result = prices[j] - prices[buf[i]]; &#125; &#125; &#125; return result;&#125; 2.2 递归法​ 递归法则是从当前值开始判断，找到大于当前值的最大的那个数，得到差值 ​ 然后从下一个数判判断，得到最大的那个差值，进行判断 ​ 效率也不是很高 1234567891011121314151617181920int maxProfit(int* prices, int pricesSize) &#123; if (pricesSize &lt;= 1) &#123; return 0; &#125; int result = 0; int temp = 0; for (int i = 0; i &lt; pricesSize; i++) &#123; if (result &lt; prices[i] - prices[0]) &#123; result = prices[i] - prices[0]; &#125; &#125; temp = maxProfit(&amp;prices[1], pricesSize - 1); if (result &lt; temp) &#123; result = temp; &#125; return result;&#125; 2.3 前向扫描法​ 前两种办法效率不高，主要是考虑的不到位， ​ 实际上，我们可以这样考虑，考虑在数组中有一个最小值，每一次都是当前值和最小值之间的比较 例如，4 3 6 3 7 ​ 一开始，最小值是1 ​ 然后发现3比4小，更新最小值，然后继续向下判断 ​ 如果这个值大于最小值，就算出差值 ​ 然后继续向下判断，如果如果还是大于最小值，就算出差值，与之前的进行比较 1234567891011121314151617int maxProfit(int* prices, int pricesSize) &#123; if (pricesSize &lt;= 1) &#123; return 0; &#125; int min_pos = 0; int result = 0; for (int i = 1; i &lt; pricesSize; i++) &#123; if (prices[i] &gt; prices[min_pos]) &#123; result = result &gt; prices[i] - prices[min_pos] ? result : prices[i] - prices[min_pos]; &#125; else &#123; min_pos = i; &#125; &#125; return result;&#125; 12345678910111213141516int maxProfit(int *prices, int pricesSize) &#123; if (pricesSize &lt;= 1) &#123; return 0; &#125; int min_pos = 0; int result = 0; for (int i = 1; i &lt; pricesSize; i++) &#123; min_pos = prices[i] &gt; prices[min_pos] ? min_pos : i; result = result &gt; prices[i] - prices[min_pos] ? result : prices[i] - prices[min_pos]; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 122. 买卖股票的最佳时机 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 2、解题思路2.1 贪心算法​ 实际上，考虑到问题的解答，就是从前往后，所有的递增值都要加起来 1234567891011121314int maxProfit(int* prices, int pricesSize) &#123; if (pricesSize &lt;= 1) &#123; return 0; &#125; int result = 0; for (int i = 1; i &lt; pricesSize; i++) &#123; if (prices[i] &gt; prices[i - 1]) &#123; result += prices[i] - prices[i - 1]; &#125; &#125; return result;&#125; 12345678910111213141516int maxProfit(int* prices, int pricesSize) &#123; if (pricesSize &lt;= 1) &#123; return 0; &#125; int result = 0; int temp = 0; for (int i = 1; i &lt; pricesSize; i++) &#123; temp = prices[i] - prices[i - 1]; if(temp &gt;0)&#123; result += temp; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 125. 验证回文串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20125.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 2、解题思路​ 123456789101112131415161718192021222324252627282930313233343536373839404142bool isAlphaNumber(char c) &#123; if (c &gt;= '0' &amp;&amp; c &lt;= '9' || c &gt;= 'a' &amp;&amp; c &lt;= 'z' || c &gt;= 'A' &amp;&amp; c &lt;= 'Z') &#123; return true; &#125; else &#123; return false; &#125;&#125;bool isPalindrome(char *s) &#123; int length = (int) strlen(s); if (length &lt;= 1) &#123; return true; &#125; // 构造缓冲字符串,去掉所有的非判断字符，将大写转换为小写 char *buff = (char *) malloc(sizeof(int) * length + 1); int buff_pos = 0; for (int i = 0; i &lt; length; i++) &#123; if (isAlphaNumber(s[i])) &#123; if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') &#123; buff[buff_pos++] = s[i] + 32; &#125; else &#123; buff[buff_pos++] = s[i]; &#125; &#125; &#125; bool result = true; for (int i = 0; i &lt; buff_pos / 2; i++) &#123; if (buff[i] != buff[buff_pos - 1 - i]) &#123; result = false; break; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 13. 罗马数字转整数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2013.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述1234567891011121314151617181920212223242526272829303132333435363738394041罗马数字包含以下七种字符：I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例 1:输入: &quot;III&quot;输出: 3示例 2:输入: &quot;IV&quot;输出: 4示例 3:输入: &quot;IX&quot;输出: 9示例 4:输入: &quot;LVIII&quot;输出: 58解释: C = 100, L = 50, XXX = 30, III = 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 2、解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273int romanToInt(char* s) &#123; /* 特殊情况： * IV :4 * IX :9 * XL :40 * XC :90 * CD :400 * CM :900 */ // 特殊情况判断 int result = 0; while (*s) &#123; switch (*s) &#123; case 'I': if (*(s + 1) &amp;&amp; (*(s + 1) == 'V' || *(s + 1) == 'X')) &#123; if (*(s + 1) == 'V') &#123; result += 4; &#125; else &#123; result += 9; &#125; s += 2; &#125; else &#123; result += 1; s++; &#125; break; case 'V': result += 5; s++; break; case 'X': if (*(s + 1) &amp;&amp; (*(s + 1) == 'L' || *(s + 1) == 'C')) &#123; if (*(s + 1) == 'L') &#123; result += 40; &#125; else &#123; result += 90; &#125; s += 2; &#125; else &#123; result += 10; s++; &#125; break; case 'L': result += 50; s++; break; case 'C': if (*(s + 1) &amp;&amp; (*(s + 1) == 'D' || *(s + 1) == 'M')) &#123; if (*(s + 1) == 'D') &#123; result += 400; &#125; else &#123; result += 900; &#125; s += 2; &#125; else &#123; result += 100; s++; &#125; break; case 'D': result += 500; s++; break; case 'M': result += 1000; s++; break; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 129. 求根到叶子节点数字之和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20129.%C2%A0%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1: 123456789输入: [1,2,3] 1 / \ 2 3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25. 示例 2: 123456789101112输入: [4,9,0,5,1] 4 / \ 9 0 / \5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026. 2、解题思路​ 这个题目是一道典型的dfs的题目，直接用深度优先搜索就出来了 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: result = 0 def sumNumbers(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 self.dfs(root, 0) return self.result def dfs(self, root, num): if not root: return num = num * 10 + root.val if not root.left and not root.right: self.result += num return self.dfs(root.left, num) self.dfs(root.right, num)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 127. 单词接龙]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20127.%C2%A0%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 123456789输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出: 5解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。 示例 2: 12345678输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: 0解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。 2、解题思路​ 这道题目类似于图中的最小路径搜索，使用的是广度优先搜索 ​ 当然，这里并不需要将数组变成图，我们先构造一个已经访问过的集合，一个待访问集合，还有一个是广度优先搜索的中间值 首先将开始单词放入访问过集合中 然后对每一个在访问过集合中的元素，到未访问过的集合中去寻找，如果存在仅相差一个字母对的单词，就放到临时集合中，判断临时集合中是不是存在目标单词，如果不存在，就继续判断 如果临时集合为空，还没有找到返回0，表示未找到 123456789101112131415161718192021222324252627282930313233class Solution: def ladderLength(self, beginWord, endWord, wordList): """ :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int """ if endWord not in wordList: return 0 visited = set([beginWord]) temp = set() not_visited = set(wordList) count = 1 while visited: for i in visited: for j in not_visited: if [i[k] == j[k] for k in range(len(i))].count(False) == 1: temp.add(j) if len(temp) == 0: return 0 count += 1 if endWord in temp: return count not_visited = not_visited - temp visited = temp temp = set() return 0 ​ 很遗憾，前面的这种方法超出了时间限制，分析一下，瓶颈可能就在判断查找改变一个字符的word上面，并且每一次对比目标单词也很耗费时间 ​ 为了加快搜索速度，使用哈希比较快，使用字典来存储，某一个单词改变一个字母的的时候，能够变成哪些单词 ​ 例如， 1[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;] 例如上面的单词表，首先来看hot 如果改变第一个字母，_ot，能够变成哪些单词呢？ 可以是hot，dot，lot 那么就可以在字典中存储这些单词： {“_ot”:[“hot”,”dot”,”lot”]} 一次类推，对每一个单词都这样判断一下 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def ladderLength(self, beginWord, endWord, wordList): """ :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int """ if endWord not in wordList: return 0 d = &#123;&#125; for word in wordList: for i in range(len(word)): s = word[:i] + "_" + word[i + 1:] d[s] = d.get(s, []) + [word] visited = set([beginWord]) temp = set() not_visited = set(wordList) count = 1 while visited: for i in visited: for j in range(len(i)): s = i[:j] + "_" + i[j + 1:] temp = temp.union(set(d.get(s, []))) d.pop(s, 0) if len(temp) == 0: return 0 count += 1 if endWord in temp: return count not_visited = not_visited - temp visited = temp temp = set() return 0 ​ 这一次虽然通过了，但是耗费时间还是很长，还需要优化]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 131. 分割回文串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20131.%C2%A0%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例: 123456输入: &quot;aab&quot;输出:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 2、解题思路​ 这道题是用递归来做，不过递归中嵌套这迭代，每一次需要判断是不是回文串，如果是，放到数组中，继续判断 ​ 如果不是，不用继续判断 12345678910111213141516171819202122232425262728293031323334class Solution: def partition(self, s): """ :type s: str :rtype: List[List[str]] """ if not s: return [[]] result = [] self.dfs(s, [], result) return result def dfs(self, s, current, result): if not s: result.append(current) return for i in range(len(s)): if self.isPalindrome(s[:i + 1]): temp = current[:] temp.append(s[:i + 1]) self.dfs(s[i + 1:], temp, result) def isPalindrome(self, s): length = len(s) for i in range(length // 2): if s[i] != s[length - 1 - i]: return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 133. 克隆图]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20133.%C2%A0%E5%85%8B%E9%9A%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述克隆一张无向图，图中的每个节点包含一个 label （标签）和一个 neighbors （邻接点）列表 。 OJ的无向图序列化： 节点被唯一标记。 我们用 # 作为每个节点的分隔符，用 , 作为节点标签和邻接点的分隔符。 例如，序列化无向图 {0,1,2#1,2#2,2}。 该图总共有三个节点, 被两个分隔符 # 分为三部分。 第一个节点的标签为 0，存在从节点 0 到节点 1 和节点 2 的两条边。 第二个节点的标签为 1，存在从节点 1 到节点 2 的一条边。 第三个节点的标签为 2，存在从节点 2 到节点 2 (本身) 的一条边，从而形成自环。 我们将图形可视化如下： 123456 1 / \ / \0 --- 2 / \ \_/ 2、解题思路​ 看到图的问题，首先想到的就是深度优先很广度优先 使用深度优先 ​ 一开始写的深度优先，没有考虑到自循环的问题，陷入自循环中，所以，应该标记一下，已经访问过的点，保存到字典中，如果是已经添加过的节点，直接放到邻居中即可，不需要重新的生成一个节点 ​ 123456789101112131415161718192021222324252627# Definition for a undirected graph node# class UndirectedGraphNode:# def __init__(self, x):# self.label = x# self.neighbors = []class Solution: node_dict = &#123;&#125; # @param node, a undirected graph node # @return a undirected graph node def cloneGraph(self, node): if not node: return None return self.dfs(node) def dfs(self, node): if node in self.node_dict: return self.node_dict[node] current = UndirectedGraphNode(node.label) self.node_dict[node] = current for i in node.neighbors: self.node_dict[node].neighbors += [self.dfs(i)] return self.node_dict[node]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 134. 加油站]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1: 1234567891011121314输入: gas = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2: 12345678910111213输入: gas = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 2、解题思路2.1 暴力法​ 我们可以让每一个点作为起点进行尝试，如果能够走完，就返回 2.2 前向扫描移动​ 如果总的汽油数小于消耗数，肯定是不能环行的， ​ 如果从起始点开始，累积汽油小于0，表示从气势点到这个点过不去，起始点要从下一个点开始 123456789101112131415161718192021class Solution(object): def canCompleteCircuit(self, gas, cost): """ :type gas: List[int] :type cost: List[int] :rtype: int """ start = 0 total = 0 current_gas = 0 for i in range(len(gas)): current_gas += gas[i] - cost[i] total += gas[i] - cost[i] if current_gas &lt; 0: start = i + 1 current_gas = 0 if total &lt; 0: return -1 else: return start]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 136. 只出现一次的数字]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20136.%C2%A0%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 12输入: [2,2,1]输出: 1 示例 2: 12输入: [4,1,2,1,2]输出: 4 2、解题思路​ 题目要求是线性时间复杂度，并且不用额外的空间 ​ 考虑从头到尾扫描一遍，如何能够分辨呢 ​ 实际上，利用异或的特性，异或同一个值两次，就得到了答案 1234567int singleNumber(int* nums, int numsSize) &#123; int result = nums[0]; for (int i = 1; i &lt; numsSize; i++) &#123; result ^= nums[i]; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 130. 被围绕的区域]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20130.%C2%A0%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二维的矩阵，包含 &#39;X&#39; 和 &#39;O&#39;（字母 O）。 找到所有被 &#39;X&#39; 围绕的区域，并将这些区域里所有的 &#39;O&#39; 用 &#39;X&#39; 填充。 示例: 1234X X X XX O O XX X O XX O X X 运行你的函数后，矩阵变为： 1234X X X XX X X XX X X XX O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#39;O&#39; 都不会被填充为 &#39;X&#39;。 任何不在边界上，或不与边界上的 &#39;O&#39; 相连的 &#39;O&#39; 最终都会被填充为 &#39;X&#39;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 2、解题思路​ 看到这道题，首先想到的就是利用dfs来搜索 ​ 基本思路就是乳沟在边界发现了一个’0’，就利用深度优先搜索，将所有的与之相邻的0并且不是边界的0标记位A ​ 然后将所有的0变成X， ​ 然后将左右的A变成0即可 ​ 注意，是字母$O$，不是数字$0$ 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ row = len(board) if row &lt;= 2: return col = len(board[0]) for i in range(row): if board[i][0] == 'O': self.dfs(board, i, 0) if board[i][col - 1] == 'O': self.dfs(board, i, col - 1) for i in range(col): if board[0][i] == 'O': self.dfs(board, 0, i) if board[row - 1][i] == 'O': self.dfs(board, row - 1, i) for i in range(row): for j in range(col): if board[i][j] == 'O': board[i][j] = 'X' elif board[i][j] == 'A': board[i][j] = 'O' def dfs(self, board, i, j): if i &gt;= 0 and i &lt; len(board) and j &gt;= 0 and j &lt; len(board[0]) and board[i][j] == "O": board[i][j] = 'A' self.dfs(board, i - 1, j) self.dfs(board, i, j - 1) self.dfs(board, i + 1, j) self.dfs(board, i, j + 1)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 137. 只出现一次的数字 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20137.%C2%A0%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 12输入: [2,2,3,2]输出: 3 示例 2: 12输入: [0,1,0,1,0,1,99]输出: 99 2、解题思路​ 在前面，做过只出现一次的数字，当时其他所有的数字出现的都是2次，于是直接用异或就出来了 ​ 在这里，因为出现的是3次，不能直接使用异或来做，不过还是可以考虑位运算 ​ 我们发现，如果某一位，比如第0位，不考虑只出现1次的那个数，出现1的次数是x，出现0的次数是y ​ 那么3x+3y = n-1 ​ 也就是说，如果在某一位上，出现3次1，我们就可以将它清零 ​ 考虑用3个变量，保存出现3次1的次数，2次1的次数，1次1的次数，遇到一个数，我们就更新一下 ​ 这样最后剩下的那个只出现1次的，就是想要找的数 ​ 举个例子 12345输入: [2,2,3,2]一开始，three=0,two=0,one=0然后,取到数字2，找出那几个出现了3次，需要用two来判断three = 2 &amp; two然后，我们先从two中，去掉出现了3次的1，然后利用one更新出现了两次的1 123456789101112131415161718192021class Solution: def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ one = 0 two = 0 three = 0 for i in nums: # 更新出现了3次的1 three = two &amp; i # 在出现了两次的1的基础上，去掉出现了3次的1，数字中也去掉 two = two &amp; ~three i = i &amp; ~three # 更新出现了两次的1 two |= one &amp; i # 更新出现了一次的1 one ^= i return one]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 138. 复制带随机指针的链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20138.%C2%A0%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的深度拷贝。 2、解题思路​ 这道题的深度拷贝，主要需要注意的问题就是不能形成环，也就是已经生成的节点不需要再次创建 1234567891011121314151617181920212223242526# Definition for singly-linked list with a random pointer.# class RandomListNode(object):# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution(object): def copyRandomList(self, head): """ :type head: RandomListNode :rtype: RandomListNode """ result = &#123;&#125; return self.dfs(head, result) def dfs(self, node, result): if node: if result.get(node) is None: result[node] = RandomListNode(node.label) result[node].next = self.dfs(node.next,result) result[node].random = self.dfs(node.random,result) else: return None return result[node]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 14. 最长公共前缀]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2014.%C2%A0%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述12345678910111213141516编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。示例 1:输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;示例 2:输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。说明:所有输入只包含小写字母 a-z 。 2、解题思路1234567891011121314151617181920212223242526272829303132333435363738char* longestCommonPrefix(char** strs, int strsSize) &#123; if(strsSize &lt;=0)&#123; return ""; &#125; // 计算最长前缀的缓冲长度，使用所有字符串中最小的那个 int buff_length = INT32_MAX; for (int i = 0; i &lt; strsSize; i++) &#123; if (strlen(*(strs + i)) &lt; buff_length) &#123; buff_length = strlen(*(strs + i)); &#125; &#125; if (buff_length == 0) &#123; return ""; &#125; char *result = (char *) malloc(sizeof(char) * (buff_length + 1)); int count = 0; bool found = false; while (!found &amp;&amp; count &lt; buff_length) &#123; // 判断是不是所有的字符串都有这个字符，如果有一个没有，表示已经找到了最长前缀 for (int i = 0; i &lt; strsSize - 1; i++) &#123; if ((*(strs + i))[count] != (*(strs + i + 1))[count]) &#123; found = true; break; &#125; &#125; // 如果当前字符存在所有的字符串中，放入缓存，继续寻找 if (!found) &#123; result[count] = (*strs)[count]; count++; &#125; &#125; result[count] = '\0'; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 141. 环形链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、 题目描述给定一个链表，判断链表中是否有环。 进阶：你能否不使用额外空间解决此题？ 2、解题思路​ 从开头向后扫描 ​ 如果遇到NULL，表示没有环形的 ​ 然后设置两个指针 ​ 一个指针一次前进一步，另一个一次前进两步 ​ 如果有环形，那么这两个指针肯定能够相遇 ​ ，就好比一个车跑得快，一个跑得慢，在环形里面，跑得快的肯定能追上跑得慢的 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */bool hasCycle(struct ListNode *head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return false; &#125; struct ListNode *current = head; struct ListNode *next_node = head-&gt;next; while (current != next_node) &#123; if (next_node == NULL || next_node-&gt;next == NULL) &#123; return false; &#125; current = current-&gt;next; next_node = next_node-&gt;next-&gt;next; &#125; return true; &#125; ​ 需要注意的是，判断跳出循环的条件用跑的快的节点判断，放置出现下一个节点已经是结尾的情况，next_node就会赋值出错的 123if (next_node == NULL || next_node-&gt;next == NULL) &#123; return false;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 139. 单词拆分]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20139.%C2%A0%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 2、解题思路​ 这道题也可以用深度优先搜索，如果整个单词都被搜索完毕，返回真，否则返回假 ​ 因为在数组中找到单词比较慢，我们直接使用字典来做，先将wordDict转换为字典 ​ 很遗憾，用递归超出了时间限制。。。 12345678910111213141516171819202122class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ word_dict = &#123;&#125; for i in wordDict: word_dict[i] = 1 return self.dfs(s, word_dict) def dfs(self, s, word_dict): if s == "": return True result = False for i in range(1, len(s) + 1): if s[:i] in word_dict: result = result or self.dfs(s[i:], word_dict) return result ​ ​ 再来分析一下这个题目，实际上，我们发现，假如前面i-1个字符能够用字典中的单词匹配，那么前i个能不能呢 ​ 假如 0&lt;=j &lt;= i-1, 我们发现j的时候能够匹配，并且s[j:i+1]也在字典中，那么当前的肯定能够匹配成功 ​ 为了匹配第一个字母，dp的长度是len(s)+1 ​ 举个例子， 1s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;] 12345678910111213dp = [True, False, False, False, False, False, False, False, False]首先判断第一个字母，&apos;l&apos;,不存在dp = [True, False, False, False, False, False, False, False, False]然后是判断前两个字母，这时候，有两种情况，dp[0] and &quot;le&quot; Falsedp[1] and &quot;e&quot; False接着是前三个字母有三种情况dp[0] and &quot;lee&quot; Falsedp[1] and &quot;ee&quot; Falsedp[2] and &quot;e&quot; False以此类推，每一次判断同样是基于前面判断的结果为了加快判断效率，一旦遇到True，直接break 1234567891011121314151617181920212223242526class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ word_dict = &#123;&#125; for i in wordDict: word_dict[i] = 1 length = len(s) dp = [False] * (length + 1) dp[0] = True for i in range(1, length + 1): temp = False for j in range(i): temp = dp[j] and s[j:i] in word_dict if temp: break dp[i] = temp return dp[len(s)]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 142. 环形链表 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20142.%C2%A0%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 说明：不允许修改给定的链表。 进阶： 你是否可以不用额外空间解决此题？ 2、解题思路​ 在前面循环链表中，使用快慢指针的技巧，判断是否存在环，这道题可以分为两步： 是否存在环 使用快慢指针来做 找出环的第一个节点 如果存在环，那么快指针比慢指针肯定是多走了一圈，那么记住相遇的节点，头结点与这个节点同时开始走，相遇的地方，就是环的第一个节点 123456789101112131415161718192021222324252627282930313233343536373839# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return head faster = head slower = head meeting = None while faster: faster = faster.next if faster: faster = faster.next slower = slower.next else: return None if faster == slower: meeting = faster break if meeting is not None: while meeting != head: meeting = meeting.next head = head.next return meeting]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 143. 重排链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20143.%C2%A0%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个单链表 L：L0→L1→…→L**n-1→Ln ，将其重新排列后变为： L0→L**n→L1→L**n-1→L2→L**n-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1: 1给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2: 1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 2、解题思路​ 这道题目首先确定需要找到中间节点，然后从前面开始，每一个节点都需要插入一个节点 ​ 一种做法是先找到中间节点，然后将后面的一半反转，从前面开始向后插入 ​ 还可以直接放到堆栈中，每一次从堆栈里面取一个节点插入 123456789101112131415161718192021222324252627282930313233343536# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reorderList(self, head): """ :type head: ListNode :rtype: void Do not return anything, modify head in-place instead. """ if not head: return head d = [] temp = head while temp: d.append(temp) temp = temp.next length = len(d) current = head next_node = current.next for i in range((length - 1) // 2): node = d.pop() current.next = node node.next = next_node current = next_node next_node = current.next if length % 2 == 0: next_node.next = None else: current.next = None ​ 在python3中，有queue，不过在python2中，直接使用list模拟即可]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 144. 二叉树的前序遍历]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20144.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 2、解题思路2.1 递归法​ 递归法已经做了很多遍了，直接写出来就好 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] result = [] self.dfs(root, result) return result def dfs(self, node, result): if node: result.append(node.val) else: return self.dfs(node.left, result) self.dfs(node.right, result) 2.2 迭代法​ 迭代法借助队列来做 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] result = [] stack = [root] while stack: node = stack.pop() result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 147. 对链表进行插入排序]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20147.%C2%A0%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述对链表进行插入排序。 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1： 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2： 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 2、 解题思路​ 这个与直接的插入排序没有区别，只是需要注意不能直接赋值而已 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head result = ListNode(0) result.next = head sort_node = head.next temp = sort_node head.next = None while temp: temp = temp.next find = result.next prev = result while find: if sort_node.val &lt; find.val: prev.next = sort_node sort_node.next = find break prev = find find = find.next if not find: prev.next = sort_node sort_node.next = None sort_node = temp return result.next ​ 这道题的解题思路很多，后面再来补充]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 148. 排序链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20148.%C2%A0%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 2、解题思路​ 前面刚刚过做了插入排序，可惜插入排序的时间复杂度是$O(n^2)$的，并不是题目要求的 ​ 题目要求的时间复杂度，一般能想到三种排序，快排，堆排序，归并排序，堆排序很复杂，也需要额外空间，快排引入了递归，所以归并排序是比较合适的 ​ 首先我们要获取链表的长度，然后归并的步伐从1开始，然后是2，4，8，16 ​ 不过这样实现有点麻烦，换个思路 首先给定一个链表，分成两部分，假定这两部分已经排序好，调用归并排序 左面这一部分，递归调用归并排序 右面这部分，递归调用归并排序 返回归并排序结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head first = head faster = head slower = head # 将链表分成两部分 while faster: faster = faster.next if faster: faster = faster.next if faster: slower = slower.next second = slower.next slower.next = None part1 = self.sortList(first) part2 = self.sortList(second) return self.merge(part1, part2) # 链表归并 def merge(self, first, second): result = ListNode(0) result.next = first prev = result while first or second: if first and second: if first.val &lt; second.val: prev.next = first first = first.next else: prev.next = second second = second.next prev = prev.next if not first: prev.next = second break if not second: prev.next = first break return result.next]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 15. 三数之和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2015.%C2%A0%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 2、解题思路​ 首先是统计数量，分成两种情况讨论，一种是结果中有重复值，另一种没有 ​ 然后进行排序，固定左面的值，在右面的值中，寻找两数之和为当前值的负数，这个可以利用leetcode的第一题的思路来寻找 ​ 123456789101112131415161718192021222324252627282930313233343536class Solution: def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) &lt; 3: return [] result = [] t = collections.Counter(nums) # count_big_two = [v for v in t if t[v] &gt;= 2] count_equal_one = sorted(list(t)) if t[0] &gt;= 3: result.append([0, 0, 0]) for i in range(len(count_equal_one)): if count_equal_one[i] &gt;= 0: break if count_equal_one[i] != 0 and t[count_equal_one[i]] &gt;= 2 and t[-count_equal_one[i] * 2] &gt; 0: result.append([count_equal_one[i], count_equal_one[i], -2 * count_equal_one[i]]) if count_equal_one[i] != 0 and count_equal_one[i] % 2 == 0 and t[-count_equal_one[i] // 2] &gt;= 2: result.append([count_equal_one[i], -count_equal_one[i] // 2, -count_equal_one[i] // 2]) temp = &#123;&#125; for j in range(i + 1, len(count_equal_one)): if count_equal_one[j] in temp: result.append([count_equal_one[i], count_equal_one[j], temp[count_equal_one[j]]]) else: temp[-count_equal_one[i] - count_equal_one[j]] = count_equal_one[j] return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 150. 逆波兰表达式求值]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20150.%C2%A0%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 123输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9 示例 2： 123输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6 示例 3： 12345678910输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 2、解题思路​ 逆波兰表达式就是后缀表达式，直接利用栈求解即可 ​ 有几个细节需要注意，数字符号的判断 ​ 还有如果只有一个数字，需要将结果转换为int 12345678910111213141516171819202122232425class Solution: def evalRPN(self, tokens): """ :type tokens: List[str] :rtype: int """ stack = [] for i in tokens: if i.isalnum() or i[0] == '-' and i[1:].isalnum(): stack.append(i) else: num1 = int(stack.pop()) num2 = int(stack.pop()) if i == '+': stack.append(num1 + num2) elif i == '-': stack.append(num2 - num1) elif i == '*': stack.append(num1 * num2) elif i == '/': stack.append(num2 / num1) return int(stack.pop())]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 151. 翻转字符串里的单词]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20151.%C2%A0%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串，逐个翻转字符串中的每个单词。 示例: 12输入: &quot;the sky is blue&quot;,输出: &quot;blue is sky the&quot;. 说明: 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 进阶: 请选用C语言的用户尝试使用 O(1) 时间复杂度的原地解法。 2、解题思路​ 如果用python，当然是很简单就做出来了，不过题目要求如果用C的话，就写一下基本思路好了 ​ 一遍扫描肯定是不好做的，因为还不知道单词的分界线 ​ 分两步 预处理，将单词反转，并去掉多余的空格 整个数组反转，找到头结点，返回 示例 123456789&quot;the sky is blue&quot;上面是输入，我们两个指针，第一个指向单词的首部，第二个指向尾部，找到单词以后，反转，然后放到头上&quot;eht sky is blue&quot;如果有多个空格，只保留一个即可扫描到最后，整个数组应该长成这样子&quot;eht yks si eulb&quot;然后，整个数组反转就得到结果了&quot;blue is sky the&quot; 基本思路就是这样，需要注意返回的位置 下面直接用python做一下 1234567class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ return " ".join(reversed([v for v in s.split(" ") if v != ""])) ​ 用C语言要写这么多，用python只有一行，哈哈哈，超过99.29%，其实没差了]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 152. 乘积最大子序列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20152.%C2%A0%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 2、解题思路​ 看到这道题，首先就想到动态规划，难点就是需要确认一下转换方程是什么 ​ 因为数字有正有负，如果要判断当前节点之前，最大的子序列的乘积，可以这样做 判断不包含当前节点的最大的乘积，包含前面一个节点的最大乘积，最小乘积，分别乘以当前数，找出其中最大的 更新包含当前节点的最大乘积，最小乘积 ​ 状态转换方程如下：$$dp[i] = max(dp[i-1],prevMax nums[i], prevMinnums[i],nums[i])\prevMax=max(prevMaxnums[i], prevMinnums[i],nums[i])\prevMin=min(prevMaxnums[i], prevMinnums[i],nums[i])$$ 12345678910111213141516171819202122class Solution: def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ length = len(nums) dp = [0] * length dp[0] = nums[0] prev_max = nums[0] prev_min = nums[0] for i in range(1, length): temp_max = prev_max * nums[i] temp_min = prev_min * nums[i] dp[i] = max(dp[i - 1], temp_max, temp_min, nums[i]) prev_max = max(temp_max, temp_min, nums[i]) prev_min = min(temp_max, temp_min, nums[i]) return dp[-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 153. 寻找旋转排序数组中的最小值]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20153.%C2%A0%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 12输入: [3,4,5,1,2]输出: 1 示例 2: 12输入: [4,5,6,7,0,1,2]输出: 0 2、解题思路​ 难道这道题就是要找到最小值？ ​ 虽然通过了。。 1234567class Solution: def findMin(self, nums): """ :type nums: List[int] :rtype: int """ return min(nums)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 16. 最接近的三数之和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2016.%C2%A0%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 2、解题思路​ 这道题与第15题有相似之处，找到3个数之和，使得他们的和最接近给定的数 ​ 假如我们将整个数组排序了，每次固定第一个数，在后面进行查找 ​ 如果diff变小，更新结果值 ​ 3数之和小于target，left增加 ​ 3数之和大于target，right减一，表示需要减小 123456789101112131415161718192021222324252627282930313233class Solution: def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ sorted_num = sorted(nums) diff = 0xffffffff result = 0 for i in range(len(sorted_num)): left = i + 1 right = len(sorted_num) - 1 while left &lt; right: temp_sum = sorted_num[i] + sorted_num[left] + sorted_num[right] temp_diff = abs(target - temp_sum) if temp_diff == 0: return temp_sum if temp_diff &lt; diff: diff = temp_diff result = temp_sum if temp_sum &lt; target: left += 1 else: right -= 1 return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 160 . 相交链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20160%20.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个程序，找到两个单链表相交的起始节点。 例如，下面的两个链表： 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 在节点 c1 开始相交。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 2、解题思路2.1 哈希表法​ 直接将第一个表的所有的节点的地址放到哈希表中，然后第二链表从头开始，如果当前地址已经存在在哈希表中，表示找到了，返回该地址 ​ 不过这种办法的空间复杂度是$O(m)$的，并不是$O(1)$ 2.2 长度查找法​ 首先明确一个问题，就是加入两个单链表相交，那么最后面的节点肯定是相同的，也就是从相交节点后，一定是相同的，因此，从头找到两个链表的长度，m，n，假设n&gt;m ​ 让第二个链表先走n-m步，然后两个链表开始匹配，如果匹配到了，表示找到了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123; int length_a = 0; int length_b = 0; struct ListNode *dir_a = headA; struct ListNode *dir_b = headB; while (dir_a || dir_b) &#123; if (dir_a) &#123; length_a++; dir_a = dir_a-&gt;next; &#125; if (dir_b) &#123; length_b++; dir_b = dir_b-&gt;next; &#125; &#125; if (length_a &lt;= 0 || length_b &lt;= 0) &#123; return NULL; &#125; dir_a = headA; dir_b = headB; int differ = length_a &gt; length_b ? length_a - length_b : length_b - length_a; int equal = length_a &gt; length_b ? length_b : length_a; if (length_a &gt; length_b) &#123; while (differ-- &gt; 0) &#123; dir_a = dir_a-&gt;next; &#125; &#125; else &#123; while (differ-- &gt; 0) &#123; dir_b = dir_b-&gt;next; &#125; &#125; while (equal-- &gt; 0) &#123; if (dir_a == dir_b) &#123; return dir_a; &#125; else &#123; dir_a = dir_a-&gt;next; dir_b = dir_b-&gt;next; &#125; &#125; return NULL;&#125; 2.3 回环法​ 回环法则是将第一个链表的末尾放到第二个链表的头上，如果两个链表相交，就找那个回环节点 ​ 实际上，回环法有问题的，因为找到的回环点不一定是第一个相交点 ​ 回环法可以用来检测是否有回环，但不能用来找到第一个相交点 ==注意：！！！== ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 162. 寻找峰值]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20162.%C2%A0%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1: 123输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2: 1234输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明: 你的解法应该是 O(logN) 时间复杂度的。 2、解题思路​ 直接找最大值，返回索引 1234567class Solution: def findPeakElement(self, nums): """ :type nums: List[int] :rtype: int """ return nums.index(max(nums)) ​ 刚刚找最大值，是一个取巧的方式，可以使用递归来做，首选进行二分，然后在如果中间值不是，就在左面和右面寻找 ​ 如果找到一个，就返回 ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 165. 比较版本号]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20165.%C2%A0%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述比较两个版本号 version1 和 version2。如果 *version1* &gt; *version2* 返回 1，如果 *version1* &lt; *version2* 返回 -1， 除此之外返回 0。 你可以假设版本字符串非空，并且只包含数字和 . 字符。 . 字符不代表小数点，而是用于分隔数字序列。 例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。 示例 1: 12输入: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;输出: -1 示例 2: 12输入: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;输出: 1 示例 3: 12输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;输出: -1 2、解题思路​ 转换成数组 首先，判断两个数组中，小的那个数组的部分 判断完以后，如果是相等的，继续判断大的数组中，剩余部分是不是都是0，如果是，结果为0 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def compareVersion(self, version1, version2): """ :type version1: str :type version2: str :rtype: int """ v1 = [int(v) for v in version1.split(".")] v2 = [int(v) for v in version2.split(".")] l1 = len(v1) l2 = len(v2) result = 0 judge_times = min(l1, l2) for i in range(judge_times): if v1[i] == v2[i]: continue elif v1[i] &gt; v2[i]: result = 1 break elif v1[i] &lt; v2[i]: result = -1 break if result == 0: if l1 &gt; l2: for i in range(l2, l1): if v1[i] &gt; 0: result = 1 break elif l1 &lt; l2: for i in range(l1, l2): if v2[i] &gt; 0: result = -1 break return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 166. 分数到小数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20166.%C2%A0%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1: 12输入: numerator = 1, denominator = 2输出: &quot;0.5&quot; 示例 2: 12输入: numerator = 2, denominator = 1输出: &quot;2&quot; 示例 3: 12输入: numerator = 2, denominator = 3输出: &quot;0.(6)&quot; 2、解题思路​ 再找思路的过程中，反向思考，如果是无限循环小数，如何变成分数呢？ 123456789101112步骤1.将无限循环小数分为2个部分,0.3454545...45为例,将其分0.3+0.04545...45这2个部分.步骤2.将这2个部分分别化成分数,0.3=3/10,0.0454545...45的划分方法.先设它为a,那么就有：10a=0.454545...451000a=45.4545.451000a-10a=45990a=45a=45/990=1/22所以0.0454545...45=1/22步骤3.再将2个部分相加就得到该无限循环小数化成分数的结果了3/10+1/22=66/220+10/220=76/220=19/55所以0.3454545...45=19/55 ​ 这个题目可以这样做，首先将数据分成两部分，整数部分和小数部分， 建立一个哈希，缓存余数 对小数部分进行判断，是不是循环的，如果余数不为0，表示要继续计算下去 如果余数出现过了，表示这个就是循环的，当前的数字不需要加入结果集中 有一点需要注意，符号的问题，先把结果的正负号保存下来，然后计算的都用正数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution: def fractionToDecimal(self, numerator, denominator): """ :type numerator: int :type denominator: int :rtype: str """ sign = 1 if (numerator &gt; 0 and denominator &lt; 0) or (numerator &lt; 0 and denominator &gt; 0): sign = -1 numerator = abs(numerator) denominator = abs(denominator) integer_part = numerator // denominator remainder = numerator % denominator if sign == 1: result = "" else: result = "-" if remainder == 0: return result + str(integer_part) remainder_hash = &#123;&#125; decimal_cache = [] is_cycle = False cycle_index = 0 while remainder != 0: temp = remainder = remainder cur_num = remainder * 10 // denominator remainder = remainder * 10 % denominator if remainder_hash.get(temp) is None: remainder_hash[temp] = cycle_index decimal_cache.append(cur_num) cycle_index += 1 else: cycle_index = remainder_hash[temp] is_cycle = True break if not is_cycle: result += str(integer_part) + "." + "".join([str(i) for i in decimal_cache]) else: result += str(integer_part) + "." + "".join([str(i) for i in decimal_cache[:cycle_index]]) + "(" + "".join( [str(i) for i in decimal_cache[cycle_index:]]) + ")" return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 167. 两数之和 II - 输入有序数组]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20167.%C2%A0%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 2、解题思路​ 因为是升序数组，那么直接设置两个下标数，从两边进行逼近 12345678910111213141516171819202122232425262728/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* numbers, int numbersSize, int target, int* returnSize) &#123; int left_index = 1; int right_index = numbersSize; int temp = 0; for (int i = 0; i &lt; numbersSize; i++) &#123; temp =numbers[left_index - 1] + numbers[right_index - 1]; if (temp == target) &#123; break; &#125; else if (temp &gt; target) &#123; right_index--; &#125; else if (temp &lt; target) &#123; left_index++; &#125; &#125; int *result = (int*)malloc(sizeof(int)*2); result[0] = left_index; result[1] = right_index; *returnSize = 2; return result; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 168. Excel表列名称]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20168.%C2%A0Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述123456789101112131415161718192021222324给定一个正整数，返回它在 Excel 表中相对应的列名称。例如， 1 -&gt; A 2 -&gt; B 3 -&gt; C ... 26 -&gt; Z 27 -&gt; AA 28 -&gt; AB ...示例 1:输入: 1输出: &quot;A&quot;示例 2:输入: 28输出: &quot;AB&quot;示例 3:输入: 701输出: &quot;ZY&quot; 2、解题思路​ 首先，我们判断这个数需要几位存储，然后判断完以后，从后向前依次计算 ​ 这里有一点需要注意，就是他不是从0开始的，是从1开始的 ​ 怎样进行转换呢 ​ 首先是26以下的数： 末位数 末位数是1~26，对应着A~Z 我们想要将之变成字符，通过加A的形式，所以，将1~26与0~25一一对应 因此，我们将这个数减一，然后取26的余，就能得到想要的字符 非末位数 例如，导数第二位数，这个数表示有多少个26，由于是从1开始计数的，需要减去1才行 如52，正确结果应该是AZ 12345678910111213141516171819char* convertToTitle(int n) &#123; char *result; int length = 1; int temp = n; while ( (temp-1)/26 &gt; 0 ) &#123; temp = (temp-1)/26; length++; &#125; result = (char *) malloc(sizeof(char) * length + 1); result[length--] = '\0'; while (length &gt;= 0) &#123; result[length] = (n-1) % 26 + 'A'; n = (n-1) / 26 ; length--; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 169. 求众数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20169.%20%E6%B1%82%E4%BC%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 12输入: [3,2,3]输出: 3 示例 2: 12输入: [2,2,1,1,1,2,2]输出: 2 2、解题思路2.1 循环扫描法​ 使用双重循环，找到次数大于数组长度一般的元素，返回该值 ​ 代码没什么问题，但是在leetcode上面运行，发现超时了，超时的数组长度是50000，所以还需要使用其他方法 123456789101112131415161718int majorityElement(int* nums, int numsSize) &#123; int count = 0; int result = 0; for (int i = 0; i &lt;= numsSize / 2; i++) &#123; result = nums[i]; for (int j = 0; j &lt; numsSize; j++) &#123; if (nums[i] == nums[j]) &#123; count++; &#125; &#125; if (count &gt; numsSize / 2) &#123; break; &#125; count = 0; &#125; return result;&#125; ​ 2.2 次数统计法​ 也称之为摩尔投票法 ​ 首先根据题意，假如每一个元素手里面有一票，只投给自己，其他元素都会给自己减一票，那么，最终剩下的，票数大于0的那个，肯定是超过半数的那个 ​ 123456789101112131415161718192021int majorityElement(int* nums, int numsSize) &#123; int count = 0; int result = nums[0]; for (int i = 0; i &lt; numsSize; i++) &#123; if (count == 0) &#123; result = nums[i]; count = 1; &#125; else &#123; if (nums[i] == result) &#123; count++; &#125; else &#123; count--; &#125; &#125; &#125; return result; &#125; ###]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 17.电话号码的字母组合]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 2、解题思路​ 实际上这道题是求解一个笛卡尔积的过程，不断地求解，直到最后 123456789101112131415class Solution: def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ if len(digits) &lt;= 0: return [] num_alpha = &#123;"2": "abc", "3": "def", "4": "ghi", "5": "jkl", "6": "mno", "7": "pqrs", "8": "tuv", "9": "wxyz"&#125; result = list(num_alpha[digits[0]]) for i in digits[1:]: result = ["".join(v) for v in itertools.product(result, num_alpha[i])] return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 171. Excel表列序号]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20171.%20Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个Excel表格中的列名称，返回其相应的列序号。 例如， 12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... 示例 1: 12输入: &quot;A&quot;输出: 1 示例 2: 12输入: &quot;AB&quot;输出: 28 示例 3: 12输入: &quot;ZY&quot;输出: 701 2、 解题思路​ 因为是从1开始的，因此，我们我们将这个数减去’A’，加上1，然后乘以26对应的阶数就得到了 123456789101112131415int titleToNumber(char* s) &#123; if (!s) &#123; return 0; &#125; int length = strlen(s); int orderNUmber = 1; int result = 0; for (int i = length - 1; i &gt;= 0; i--) &#123; result += (s[i] - 'A' + 1) * orderNUmber; orderNUmber *= 26; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 172. 阶乘后的零]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20172.%C2%A0%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 123输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2: 123输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 2、解题思路​ 我们知道，如果想要在默认有0，表示是10的倍数，可以看成是5*2的倍数，因此，每一个0，都可以看成是一个因子5，乘以一个偶数的形式 ​ 因此，如果想要得到阶乘后面有多少个0，就找出有多少个因子5就可以了 举个例子，假如我们想要求解 n的阶乘后面有多少个0，也就是因子5 当n&lt;5 ​ 没有因子5，没有0； 当n&gt;=5 ​ 我们将这个很大的数进行因式分解，可以看到$$5k 5(k-1)…5 a$$其中，a表示不能被5整除的数， ​ k表示最大的那个可以被5整除的数，也就是说已经能够得到k个因子5 ​ 然后，我们看到，从1到k又构成了一个阶乘，然后这里面可能也有因子5 ​ 同样得到了，k继续往下分 12345678int trailingZeroes(int n) &#123; int result = 0; while (n &gt;= 5) &#123; result += n / 5; n /= 5; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 173. 二叉搜索树迭代器]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20173.%C2%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。 调用 next() 将返回二叉搜索树中的下一个最小的数。 注意: next() 和hasNext() 操作的时间复杂度是O(1)，并使用 O(h) 内存，其中 h 是树的高度。 2、解题思路​ 想要得到下一个数值，我们使用栈来存储，因为要得到最小值，所以是中遍历，放到栈里面，顺序相反，因此遍历的顺序应该是右-》根 -》左 ​ 这样就能够不断地pop了 1234567891011121314151617181920212223242526272829303132333435363738394041# Definition for a binary tree node# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass BSTIterator(object): def __init__(self, root): """ :type root: TreeNode """ self.buff = [] self.dfs(root) print(self.buff) def hasNext(self): """ :rtype: bool """ if self.buff: return True def next(self): """ :rtype: int """ return self.buff.pop() def dfs(self, node): if not node: return self.dfs(node.right) self.buff.append(node.val) self.dfs(node.left) # Your BSTIterator will be called like this:# i, v = BSTIterator(root), []# while i.hasNext(): v.append(i.next()) ​ 或者说另一个思路，不必一次缓冲所有的，直接按照非递归中序遍历，缓存前面的节点即可]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 175 . 组合两个表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20175%20.%C2%A0%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述表1: Person 12345678+-------------+---------+| 列名 | 类型 |+-------------+---------+| PersonId | int || FirstName | varchar || LastName | varchar |+-------------+---------+PersonId 是上表主键 表2: Address 123456789+-------------+---------+| 列名 | 类型 |+-------------+---------+| AddressId | int || PersonId | int || City | varchar || State | varchar |+-------------+---------+AddressId 是上表主键 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息： 1FirstName, LastName, City, State 2、解题思路12# Write your MySQL query statement belowSelect FirstName, LastName,City,State from Person as p left join Address as a on p.PersonId = a.PersonId]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 176. 第二高的薪水]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20176.%C2%A0%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ 例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。 12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ 2、解题思路12# Write your MySQL query statement belowSelect Salary as "SecondHighestSalary" from Employee group by Salary union all (select null ) order by SecondHighestSalary DESC limit 1,1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 177. 第N高的薪水]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20177.%C2%A0%E7%AC%ACN%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ 例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。 12345+------------------------+| getNthHighestSalary(2) |+------------------------+| 200 |+------------------------+ 2、解题思路12345678910111213CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGINdeclare M INT;set M = N-1; RETURN ( # Write your MySQL query statement below. select distinct Salary from Employee order by Salary DESC limit M,1 );END]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 178.分数排名]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20178.%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。 12345678910+----+-------+| Id | Score |+----+-------+| 1 | 3.50 || 2 | 3.65 || 3 | 4.00 || 4 | 3.85 || 5 | 4.00 || 6 | 3.65 |+----+-------+ 例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）： 12345678910+-------+------+| Score | Rank |+-------+------+| 4.00 | 1 || 4.00 | 1 || 3.85 | 2 || 3.65 | 3 || 3.65 | 3 || 3.50 | 4 |+-------+------+ 2、解题思路​ 直接一看， 有一点蒙，实际上，这道题考察的是，给定一个分数，有多少个大于等于，每个分数只计算一次 123# Write your MySQL query statement belowselect Score , (select count(distinct Score) from Scores s2 where s1.Score &lt;= s2.Score ) Rank from Scores s1 order by Score DESC]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 179. 最大数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20179.%C2%A0%E6%9C%80%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1: 12输入: [10,2]输出: 210 示例 2: 12输入: [3,30,34,5,9]输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 2、解题思路​ 基本思路首先是将所有数字进行排序，排序规则自定义，如何取定两个数的顺序呢，就是如果数字1放到数字2之前，得到的数字比起数字2放到数字1之前更大，放回整数 ​ python3中，sorted函数取消了对cmp的支持，不过在functiontool里面还能转换使用 ​ 这道题是求解最大的数，如果是求解最小的数，只需要将compare的比较反转即可 1234567891011121314151617import functoolsclass Solution(object): def largestNumber(self, nums): """ :type nums: List[int] :rtype: str """ cmpkey = functools.cmp_to_key(self.compare) nums.sort(key=cmpkey) if str(nums[0])[0] == '0': return '0' return "".join([str(v) for v in nums]) def compare(self, num1, num2): return int(str(num2) + str(num1)) - int(str(num1) + str(num2)) ​ 下面是python2的解法 12345678910111213141516class Solution(object): def largestNumber(self, nums): """ :type nums: List[int] :rtype: str """ nums.sort(cmp = self.compare) if str(nums[0])[0] == '0': return '0' return "".join([str(v) for v in nums]) def compare(self, num1, num2): return int(str(num2) + str(num1)) - int(str(num1) + str(num2))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 18.四数之和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，**b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 2、解题思路​ 借助前面的3数之和，进行求解 ​ 3数之和借助2数之和进行求解 ​ 所以，实际上也可以借助递归进行求解，这样不管是几个数之和，都能求解出来 12345678910111213141516171819202122232425262728293031323334353637class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] sorted_nums = sorted(nums) result = [] for i in range(len(nums)): temp = self.threeSum(sorted_nums[i + 1:], target - sorted_nums[i]) if temp != None: for k in temp: if [sorted_nums[i]]+k not in result: result.append([sorted_nums[i]]+ k) return result def threeSum(self, nums, target): if len(nums) &lt; 3: return [] result = [] count_equal_one = nums for i in range(len(count_equal_one)): temp = &#123;&#125; for j in range(i + 1, len(count_equal_one)): if count_equal_one[j] in temp: result.append([count_equal_one[i], count_equal_one[j], temp[count_equal_one[j]]]) else: temp[target - count_equal_one[i] - count_equal_one[j]] = count_equal_one[j] return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 181. 超过经理收入的员工]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20181.%C2%A0%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。 12345678+----+-------+--------+-----------+| Id | Name | Salary | ManagerId |+----+-------+--------+-----------+| 1 | Joe | 70000 | 3 || 2 | Henry | 80000 | 4 || 3 | Sam | 60000 | NULL || 4 | Max | 90000 | NULL |+----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。 12345+----------+| Employee |+----------+| Joe |+----------+ 2、解题思路12# Write your MySQL query statement belowselect e1.Name as "Employee" from Employee e1,Employee e2 where e1.ManagerId = e2.Id and e1.Salary&gt;e2.Salary]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 180. 连续出现的数字]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20180.%C2%A0%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个 SQL 查询，查找所有至少连续出现三次的数字。 1234567891011+----+-----+| Id | Num |+----+-----+| 1 | 1 || 2 | 1 || 3 | 1 || 4 | 2 || 5 | 1 || 6 | 2 || 7 | 2 |+----+-----+ 例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。 12345+-----------------+| ConsecutiveNums |+-----------------+| 1 |+-----------------+ 2、解题思路123# Write your MySQL query statement belowselect distinct l1.Num as "ConsecutiveNums" from Logs l1 ,Logs l2 ,Logs l3 where l1.Id = l2.Id-1 and l2.Id = l3.Id-1 and l1.Num = l2.Num and l1.Num = L3.Num]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 182. 查找重复的电子邮箱]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20182.%C2%A0%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。 示例： 1234567+----+---------+| Id | Email |+----+---------+| 1 | a@b.com || 2 | c@d.com || 3 | a@b.com |+----+---------+ 根据以上输入，你的查询应返回以下结果： 12345+---------+| Email |+---------+| a@b.com |+---------+ 说明：所有电子邮箱都是小写字母。 2、解题思路12# Write your MySQL query statement belowselect Email from Person group by Email having count(Email) &gt; 1 3、附录Having与Where的区别 where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，where条件中不能包含聚组函数，使用where条件过滤出特定的行。 having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件过滤出特定的组，也可以使用多个分组标准进行分组。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 183. 从不订购的客户]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20183.%C2%A0%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表： 12345678+----+-------+| Id | Name |+----+-------+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+----+-------+ Orders 表： 123456+----+------------+| Id | CustomerId |+----+------------+| 1 | 3 || 2 | 1 |+----+------------+ 例如给定上述表格，你的查询应返回： 123456+-----------+| Customers |+-----------+| Henry || Max |+-----------+ 2、解题思路12# Write your MySQL query statement belowselect Name as "Customers" from Customers where Id not in (select CustomerId from Orders )]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 184. 部门工资最高的员工]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20184.%C2%A0%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。 12345678+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 70000 | 1 || 2 | Henry | 80000 | 2 || 3 | Sam | 60000 | 2 || 4 | Max | 90000 | 1 |+----+-------+--------+--------------+ Department 表包含公司所有部门的信息。 123456+----+----------+| Id | Name |+----+----------+| 1 | IT || 2 | Sales |+----+----------+ 编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。 123456+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT | Max | 90000 || Sales | Henry | 80000 |+------------+----------+--------+ 2、解题思路​ 在员工所属的部门中，找出最高工资，然后判断当前员工是不是，如果是，就把他选出来 12# Write your MySQL query statement belowselect d.Name as Department , e.Name as Employee , e.Salary as Salary from Employee e, Department d where e.DepartmentId = d.Id and e.Salary = (select max(Salary) from Employee em where em.DepartmentId = d.Id)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 187. 重复的DNA序列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20187.%C2%A0%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。 示例: 123输入: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;输出: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] 2、解题思路​ 直接用哈希来做，很简单 1234567891011121314151617class Solution(object): def findRepeatedDnaSequences(self, s): """ :type s: str :rtype: List[str] """ length = len(s) hash_buff = &#123;&#125; for i in range(length - 9): if hash_buff.get(s[i:i + 10]) is None: hash_buff[s[i:i + 10]] = 1 else: hash_buff[s[i:i + 10]] += 1 return [ k for k,v in hash_buff.items() if v &gt;= 2]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 189.旋转数组]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 2、解题思路2.1 缓冲数组法​ 设置一个与当前数组同样大小的数组，将原数组中的所有的元素使用取余，计算出位置，直接赋值 2.2 单步移动法​ 每一次右旋移动一次，根据需要移动的数量，多次移动 2.3 分组法​ 分组法较为巧妙 例如，1，2，3，4，5，6，7 ​ 我们想要右移3位，那么实际上可以如何实现呢？ ​ 我们将1，2，3，4只有移动到右面底部，然后将5，6，7平移到左面，就得到结果了 ​ 但是，如果想要不借助其他的空间移动，我们发现，直接取反就可以做到，不过1，2，3，4的位置是反着的，5，6，7的位置也是反着的 ​ 因此，根据移动的步数，进行分组，然后将组内部元素取反，再整体取反，就得到想要的结果了 1234567891011121314151617181920212223void reverse(int *nums, int left, int right) &#123; int length = right - left + 1; if (length &lt;= 1) &#123; return; &#125; for (int i = 0; i &lt; length / 2; i++) &#123; nums[left + i] ^= nums[right - i]; nums[right - i] ^= nums[left + i]; nums[left + i] ^= nums[right - i]; &#125;&#125;void rotate(int *nums, int numsSize, int k) &#123; int step = k % numsSize; if (step == 0) &#123; return; &#125; reverse(nums, 0, numsSize - step - 1); reverse(nums, numsSize - step, numsSize - 1); reverse(nums, 0, numsSize - 1);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 185. 部门工资前三高的员工]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20185.%C2%A0%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E5%89%8D%E4%B8%89%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id 。 12345678910+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 70000 | 1 || 2 | Henry | 80000 | 2 || 3 | Sam | 60000 | 2 || 4 | Max | 90000 | 1 || 5 | Janet | 69000 | 1 || 6 | Randy | 85000 | 1 |+----+-------+--------+--------------+ Department 表包含公司所有部门的信息。 123456+----+----------+| Id | Name |+----+----------+| 1 | IT || 2 | Sales |+----+----------+ 编写一个 SQL 查询，找出每个部门工资前三高的员工。例如，根据上述给定的表格，查询结果应返回： 123456789+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT | Max | 90000 || IT | Randy | 85000 || IT | Joe | 70000 || Sales | Henry | 80000 || Sales | Sam | 60000 |+------------+----------+--------+ 2、解题思路​ 之前，我们找出了部门第N高的薪水，这里使用的思路差不多，如果在部门里面，大于当前工资的数量少于3个，就表示当前工资是前3高的 12# Write your MySQL query statement belowselect d.Name as Department , e.Name as Employee , e.Salary from Employee e , Department d where e.DepartmentId = d.Id and (select count(distinct Salary) from Employee where DepartmentId = d.id and Salary &gt; e.Salary ) &lt; 3 order by Department]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 19. 删除链表的倒数第N个节点]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2019.%C2%A0%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 2、解题思路​ ​ 这个题目有一个小技巧在里面，就是如何使用一趟扫描找到想要找的元素呢，就是使用双指针 ​ 先让第二个指针走n步，然后两个指针一起走，这样第一个指针指向的就是待删除的元素 ​ 下面的处理方式是让走N+1步，这样就知道待删除的前面的一个元素， ​ 不过还需要判断一下如果待删除的长度与整个链表长度一样，表示要删除的是头结点 ​ 如果不一样，就是要删除头结点下一个节点 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ count = -1 length = 0 temp = head target = head while temp: if count &gt;= n: target = target.next else: count += 1 temp = temp.next length += 1 if length == n: return head.next else: target.next = target.next.next return head]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 190. 颠倒二进制位]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20190.%C2%A0%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述颠倒给定的 32 位无符号整数的二进制位。 示例: 1234输入: 43261596输出: 964176192解释: 43261596 的二进制表示形式为 00000010100101000001111010011100 ， 返回 964176192，其二进制表示形式为 00111001011110000010100101000000 。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 2、解题思路2.1 移位交换法​ 我们可以这样进行考虑，先将高16位和第16位进行交换 ​ 然后将高低16位中的高低8位进行交换 ​ 然后每8位中的4位进行交换 ​ 然后是每4位中的2位交换位置 ​ 然后是每两位交换位置 ​ ​ 总结起来，以最高位为例，先右移6位，然后是8位，在来4位，2位，1位 12345678910uint32_t reverseBits(uint32_t n) &#123; uint32_t temp = n; temp = (temp &amp; 0xffff0000) &gt;&gt; 16 | (temp &amp; 0x0000ffff) &lt;&lt; 16; temp = (temp &amp; 0xff00ff00) &gt;&gt; 8 | (temp &amp; 0x00ff00ff) &lt;&lt; 8; temp = (temp &amp; 0xf0f0f0f0) &gt;&gt; 4 | (temp &amp; 0x0f0f0f0f) &lt;&lt; 4; temp = (temp &amp; 0xcccccccc) &gt;&gt; 2 | (temp &amp; 0x33333333) &lt;&lt; 2; temp = (temp &amp; 0xaaaaaaaa) &gt;&gt; 1 | (temp &amp; 0x55555555) &lt;&lt; 1; return temp;&#125; 2.2 依次移位法12345678uint32_t reverseBits(uint32_t n) &#123; uint32_t temp = 0; for (int i = 0; i &lt; 32; i++) &#123; temp = (temp &lt;&lt; 1) + n % 2; n = n &gt;&gt; 1; &#125; return temp;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 191. 位1的个数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20191.%C2%A0%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 示例 : 123输入: 11输出: 3解释: 整数 11 的二进制表示为 00000000000000000000000000001011 示例 2: 123输入: 128输出: 1解释: 整数 128 的二进制表示为 00000000000000000000000010000000 2、解题思路12345678int hammingWeight(uint32_t n) &#123; int result = 0; for (int i = 0;i&lt;32;i++)&#123; result += n&amp;1; n = n&gt;&gt;1; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 196. 删除重复的电子邮箱]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20196.%C2%A0%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。 12345678+----+------------------+| Id | Email |+----+------------------+| 1 | john@example.com || 2 | bob@example.com || 3 | john@example.com |+----+------------------+Id 是这个表的主键。 例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行: 123456+----+------------------+| Id | Email |+----+------------------+| 1 | john@example.com || 2 | bob@example.com |+----+------------------+ 2、解题思路12# Write your MySQL query statement belowdelete p1 from Person p1, Person p2 where p1.Email = p2.Email and p1.Id &gt; p2.Id 12# Write your MySQL query statement belowdelete from Person where Id not in (select Id from (select min(Id) Id from Person group by Email) p)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 197. 上升的温度]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20197.%C2%A0%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%A9%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。 12345678+---------+------------------+------------------+| Id(INT) | RecordDate(DATE) | Temperature(INT) |+---------+------------------+------------------+| 1 | 2015-01-01 | 10 || 2 | 2015-01-02 | 25 || 3 | 2015-01-03 | 20 || 4 | 2015-01-04 | 30 |+---------+------------------+------------------+ 例如，根据上述给定的 Weather 表格，返回如下 Id: 123456+----+| Id |+----+| 2 || 4 |+----+ 2、解题思路​ 这里有一点需要注意，就是每一次比较，是今天的时间和昨天的时间进行比较 ​ 所以将日期转换为天数，得到差值为1的记录，并且过滤掉第一个，前面没有温度的 12# Write your MySQL query statement belowselect w1.Id from Weather w1 left join Weather w2 on to_days(w1.RecordDate) - to_days(w2.RecordDate) =1 and w1.Temperature &gt; w2.Temperature where w2.Id is not null;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 198.打家劫舍]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 2、解题思路​ 例如： ​ 1，4，3，5，7 ​ 我们直接可以看出来，答案应该是11，1+3+7 ​ 首先我们要判断当前的值是不是应该添加进去，如何判断呢 ​ ​ 假设我们已经计算出了，在这个位置上，前一个值被加上去了，那么当前值不应被加上， ​ 那么我们保存前一次的值，还有更前一次的值，更前一次的值就可以加上当前的值，如果加上以后，结果变大，更新一下，将这个值加上去 ​ 前一次和前两次的值都更新 假设prev表示前两次的值，cur表示前一次的值 1，4，3，5，7 一开始，prev=0，cur=0 prev cur nums[i] 0 1 1 1 4 4 4 4 3 4 9 5 9 11 7 实际上，cur表示在前一个位置上能够取到的最大的值 ​ prev表示在更前一个位置上能够取到的最大的值 例如（prev = 0）（cur=0）1，2，3，4，5 一开始，我先想要判断1这个位置能够取到的最大的值，就用当前位置的值，加上prev，然后与cur进行比较，取更大的那个 ​ 然后prev与cur向右移动 ​ 不断的移动，最终，我们得到了当前位置能够取到的最大的值 （prev=0）（cur=0）9，1，1，9 ​ 一开始，9+0 &gt; , cur 变成了9， prev还是0 ​ 然后，判断1，1+0 &lt;9 , cur 不变，还是9，prev向前移动，变成了9 ​ 然后，判断1，1+9 &gt; 9, cur更新成了 10，prev还是9 ​ 最后，判断9，9+9&gt;10,cur变成了18，prev变成10 实际上，prev和cur能够延伸当前位置的感知，最多向前感知3个元素，因此覆盖了所有情况 12345678910111213int rob(int* nums, int numsSize) &#123; int prev = 0; int cur = 0; int temp; for (int i = 0; i &lt; numsSize; i++) &#123; temp = cur; cur = prev + nums[i] &gt; cur ? prev + nums[i] : cur; prev = temp; &#125; return cur;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 199. 二叉树的右视图]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20199.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例: 123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- 2、解题思路​ 这道题很好解，就是所有层次遍历的时候，将最后一个元素放到里面即可 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneimport queueclass Solution: def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] result = [] d = queue.deque() d.append(root) while d: result.append(d[-1].val) size = len(d) for i in range(size): node = d.popleft() if node.left: d.append(node.left) if node.right: d.append(node.right) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2. 两数相加]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%202.%C2%A0%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述123456789You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.ExampleInput: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. ​ 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 2、解题思路​ 这个问题很简单，我们设计两个指针，指向两个链表，并且保存一个进位就可以了，在不断的前进过程中，不断地更新当前位置与进位 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123; struct ListNode *result=NULL,*temp,*p1,*p2; int carry=0,sum,x,y; for(p1=l1,p2=l2;p1 || p2;)&#123; x = p1!=NULL?p1-&gt;val:0; y = p2!=NULL?p2-&gt;val:0; if(result == NULL)&#123; result = temp = (struct listNode*)malloc(sizeof(struct ListNode)); &#125; else&#123; temp = temp-&gt;next = (struct listNode*)malloc(sizeof(struct ListNode)); &#125; temp-&gt;val = (x+y+carry)%10; temp-&gt;next = NULL; carry = (x+y+carry)&gt;9?1:0; if(p1)&#123; p1 = p1-&gt;next; &#125; if(p2)&#123; p2 = p2-&gt;next; &#125; &#125; if (carry)&#123; temp = temp-&gt;next = (struct listNode*)malloc(sizeof(struct ListNode)); temp-&gt;val = 1; temp-&gt;next = NULL; &#125; return result; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 200. 岛屿的个数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20200.%C2%A0%E5%B2%9B%E5%B1%BF%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 2、解题思路​ 这道题目比较简单，直接只用深度优先搜索就可以了 建立访问路径数组 遇到1，并且未访问过，就调用深度优先访问，将所有的相邻节点进行标记 12345678910111213141516171819202122232425262728class Solution: def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ row = len(grid) if row &lt;= 0: return 0 col = len(grid[0]) visited = [[0] * col for i in range(row)] result = 0 for i in range(row): for j in range(col): if grid[i][j] == '1' and visited[i][j] == 0: self.dfs(i, j, row, col, grid, visited) result += 1 return result def dfs(self, i, j, row, col, grid, visited): if i &gt;= 0 and i &lt; row and j &gt;= 0 and j &lt; col and grid[i][j] == '1' and visited[i][j] == 0: visited[i][j] = 1 self.dfs(i - 1, j, row, col, grid, visited) self.dfs(i, j - 1, row, col, grid, visited) self.dfs(i + 1, j, row, col, grid, visited) self.dfs(i, j + 1, row, col, grid, visited)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 20. 有效的括号]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2020.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述1234567891011121314151617181920212223242526272829给定一个只包括 &apos;(&apos;，&apos;)&apos;，&apos;&#123;&apos;，&apos;&#125;&apos;，&apos;[&apos;，&apos;]&apos; 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例 1:输入: &quot;()&quot;输出: true示例 2:输入: &quot;()[]&#123;&#125;&quot;输出: true示例 3:输入: &quot;(]&quot;输出: false示例 4:输入: &quot;([)]&quot;输出: false示例 5:输入: &quot;&#123;[]&#125;&quot;输出: true 2、解题思路​ 判断字符串长度，奇数肯定是错误的 ​ 创建一个缓冲数组，用作栈的作用，将每一个左括号，都将其入栈，右括号弹出 ​ 如果不能弹出，表示有问题，返回失败 ​ 最后判断栈指针是不是在哨兵上，如果是，则返回成功，不是则是失败 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091bool isValid(char* s) &#123; int length = strlen(s); // 奇数个括号肯定是不正确的 if (length % 2) &#123; return false; &#125; if (!*s) &#123; return true; &#125; // 创建一个缓冲的数组，实现类似于栈的操作，不过最多需要字符串的一半空间 // 多出一个元素，是考虑到后面的指针有可能越界，所以多放了一个 char *stack = (char *) malloc(sizeof(char) * (length / 2)); // 这个是栈的指元素，开始的时候，如果需要放入元素，就放入一个元素，并且将指针加一 int head = -1; while (*s) &#123; switch (*s) &#123; case '[': if (*(s + 1)) &#123; if (*(s + 1) == ']') &#123; s += 2; &#125; else &#123; stack[++head] = *s; s++; &#125; &#125; else &#123; return false; &#125; break; case '(': if (*(s + 1)) &#123; if (*(s + 1) == ')') &#123; s += 2; &#125; else &#123; stack[++head] = *s; s++; &#125; &#125; else &#123; return false; &#125; break; case '&#123;': if (*(s + 1)) &#123; if (*(s + 1) == '&#125;') &#123; s += 2; &#125; else &#123; stack[++head] = *s; s++; &#125; &#125; else &#123; return false; &#125; break; case ']': if (stack[head] == '[') &#123; s++; head--; &#125; else &#123; return false; &#125; break; case ')': if (stack[head] == '(') &#123; s++; head--; &#125; else &#123; return false; &#125; break; case '&#125;': if (stack[head] == '&#123;') &#123; s++; head--; &#125; else &#123; return false; &#125; break; default: return false; &#125; &#125; if (head &lt; 0) &#123; return true; &#125; return false;&#125; ​ 上面的判断太多了，效率不高，下面是改进版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556bool isValid(char* s) &#123; int length = strlen(s); // 奇数个括号肯定是不正确的 if (length % 2) &#123; return false; &#125; if (!*s) &#123; return true; &#125; // 创建一个缓冲的数组，实现类似于栈的操作，不过最多需要字符串的一半空间 // 多出一个元素，是考虑到后面的指针有可能越界，所以多放了一个 char *stack = (char *) malloc(sizeof(char) * (length / 2 + 1)); // 这个是栈的指元素，开始的时候，如果需要放入元素，就放入一个元素，并且将指针加一 int head = 0; // 哨兵 stack[0] = 0; while (*s) &#123; switch (*s) &#123; case ']': if (stack[head] == '[') &#123; s++; head--; &#125; else &#123; return false; &#125; break; case ')': if (stack[head] == '(') &#123; s++; head--; &#125; else &#123; return false; &#125; break; case '&#125;': if (stack[head] == '&#123;') &#123; s++; head--; &#125; else &#123; return false; &#125; break; default: stack[++head] = *s; s++; break; &#125; if (head &gt; length / 2) &#123; return false; &#125; &#125; if (head &lt;= 0) &#123; return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 201. 数字范围按位与]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20201.%C2%A0%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。 示例 1: 12输入: [5,7]输出: 4 示例 2: 12输入: [0,1]输出: 0 2、解题思路​ 首先确定这样一个问题，肯定是不能一步一步计算的，应该如何算呢 ​ 每个数字都是32位的， 第0位的数字，他是重复的，每两个数字重复一次 第1位数字，也是重复的，每4个数字重复一次 第1位数字，也是重复的，每4个数字重复一次 举个例子 从0-20 12345678910111213141516171819200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000100000000000000000000000000000001100000000000000000000000000000100000000000000000000000000000001010000000000000000000000000000011000000000000000000000000000000111000000000000000000000000000010000000000000000000000000000000100100000000000000000000000000001010000000000000000000000000000010110000000000000000000000000000110000000000000000000000000000001101000000000000000000000000000011100000000000000000000000000000111100000000000000000000000000010000000000000000000000000000000100010000000000000000000000000001001000000000000000000000000000010011 从0到20，一共是 21个数，如果按位与，肯定是0 分析第0位，如果长度超过1，就会出现0，肯定是0 第1位，长度超过2，会出现0 第2位，长度超过4，出现0 以此类推，如果长度没有超过，就判断这两个数的当前位是不是都是1，如果是，这一位就是1 1234567891011121314151617181920class Solution: def rangeBitwiseAnd(self, m, n): """ :type m: int :type n: int :rtype: int """ result = "" nums = n - m + 1 for i in range(32): if nums &gt; (2 ** i): result += '0' else: if n &amp; (1 &lt;&lt; i) != 0 and m &amp; (1 &lt;&lt; i) != 0: result += '1' else: result += '0' return int("".join(list(reversed(result))), 2) ​ 本来觉得这个思路还不错，不过运行太慢 ​ 我们在来分析一下 ​ 如果两个数， 11110000 11110101 这个范围的结果，实际上就是两个数高的，相等的位 只要将1111取出来就好了，剩下的置零 结果为11110000 如果是 00001111 11110000 高位没有相同的，结果就是 00000000 123456789101112131415class Solution: def rangeBitwiseAnd(self, m, n): """ :type m: int :type n: int :rtype: int """ left_move = 0 while n &gt; m: n = n &gt;&gt; 1 m = m &gt;&gt; 1 left_move += 1 return n &lt;&lt; left_move]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 202.快乐数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20202.%E5%BF%AB%E4%B9%90%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目表述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 1234567输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 $$1^2+9^2=82\8^2+2^2=68\6^2+8^2=100\1^2+0^2+0^2=1$$ 2、解题思路​ 首先，我们来判断一个数快不快乐，如果不能够得到一，就会一直计算下去， 首先，我们知道，一个一位数，最大是9，两位，99，三位，999 位数 最大值 最大值下一个数 1 9 81 2 99 162 3 999 243 4 9999 324 5 99999 405 6 999999 486 7 9999999 567 13位 1053 ​ 我们可以看到，当位数超过3的时候，也就是数字超过1000，下一个数字相比位数的增加，增加很缓慢，远远小于当前值，并且，大于1000的数，超过13位的时候，最大才超过1053，也就是说，所有的数字，经过几次变换，肯定会变换到小于1000的数，小于1000的最大就是243，最终，任何一个数，变换几次以后，都不会大于243 2.1 缓存法​ 一种思路，我们将小于243的欢乐数缓存起来，将这个数进行变换，如果数值小于243了，就与缓存数组中的数进行判断，如果不匹配，返回假，匹配则返回真 ​ 实际上，只需要162个就够用了 123456789101112131415161718192021222324252627282930313233343536373839404142int countPowNumber(int n) &#123; int result = 0; while (n / 10 &gt; 0 || n % 10 &gt; 0) &#123; result += (n % 10) * (n % 10); n /= 10; &#125; return result;&#125;bool isHappy(int n) &#123; bool cycle = true; int result = n; int *buff = (int *) malloc(sizeof(int) * 163); for (int i = 0; i &lt; 163; i++) &#123; buff[i] = 0; &#125; while (cycle) &#123; if (result &gt;= 163) &#123; result = countPowNumber(result); &#125; else if (result == 1) &#123; cycle = false; &#125; else &#123; if (buff[result] == 0) &#123; buff[result]++; result = countPowNumber(result); &#125; else &#123; cycle = false; &#125; &#125; &#125; free(buff); if (result == 1) &#123; return true; &#125; else &#123; return false; &#125;&#125; 2.2 重复判断法​ 我们知道，数字可能性就是0~9，平方值分别是 数字 平方 0 0 1 1 2 4 3 9 4 16 5 25 6 36 7 49 8 64 9 81 ​ 根据之前的分析，当数值大于1000，每次增加1位，位数的平方和最多增加81，因此，最终大于1000的数都会慢慢变小，变成1000以内的数，而1000以内的数，最大的是243 ​ 因此，也就是3位中，哪些组合肯定不能变成快乐数呢？ ​ 根据快乐数的说法，如果平方加起来是1，10，100，就是平方数 ​ 我们就在这里面找出，一旦出现，就肯定不是平方数的那个数，最少一个，最多3个数（考虑243） 1肯定可以 判断10以内的数，加起来能不能变成10 0，1，9都可以，4不可以 判断100以内的数 36+64是可以的 由于平方数可以多次计算，因此，下一次加起来能够得到 1，10， 13，31，13，68，86，也是平方数 那么哪个数字的平方数加起来能够得到呢（最多加3次） 我们发现， 1+9 = 10，表示1，3的组合都是可以的 1+9+0=10，表示1，3，0的组合都是可以的 4+9 = 13，表示2，3的组合都是可以的 4+9 +0 = 13，表示2，3，0的组合都是可以的 16+16+36 = 68， 表示 4，4，6，的组合是可以的 36+16+16 = 68，6，4，4，的组合都可以 49+16+1 = 68， 7，4，1的组合都可以 64+4+0 = 68 ， 表示2，8，0的组合都是可以的 25+25+36 = 86，表示5，5，6的组合都可以 49+36+1 = 86，表示7，6，1的组合都可以 不过，能够得到这些数的也都是可以的 根据一般结论，如果出现4，肯定不是快乐数，也可以这样判断]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 203. 删除链表中的节点]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20203.%C2%A0%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述删除链表中等于给定值 val 的所有节点。 示例: 12输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 2、解题思路1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* removeElements(struct ListNode* head, int val) &#123; if (!head) &#123; return head; &#125; while (head &amp;&amp; head-&gt;val == val) &#123; head = head-&gt;next; &#125; struct ListNode *prev_node; struct ListNode *cur_node; if (head) &#123; prev_node = head; cur_node = head-&gt;next; &#125; else &#123; return head; &#125; while (cur_node) &#123; if (cur_node-&gt;val == val) &#123; prev_node-&gt;next = cur_node-&gt;next; cur_node = cur_node-&gt;next; &#125; else &#123; cur_node = cur_node-&gt;next; prev_node = prev_node-&gt;next; &#125; &#125; return head; &#125; 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* removeElements(struct ListNode* head, int val) &#123; if (!head) &#123; return head; &#125; struct ListNode *prev_node = head; struct ListNode *cur_node = head-&gt;next; while (cur_node) &#123; if (cur_node-&gt;val == val) &#123; prev_node-&gt;next = cur_node-&gt;next; cur_node = cur_node-&gt;next; &#125; else &#123; cur_node = cur_node-&gt;next; prev_node = prev_node-&gt;next; &#125; &#125; if(head-&gt;val==val)&#123; head = head-&gt;next; &#125; return head; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 204.计数质数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20204.%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述统计所有小于非负整数 n 的质数的数量。 示例: 123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 2、解题思路2.1 链表缓存​ 使用一个链表，缓存所有小于n的质数，判断质数的时候，用这些质数判断 ​ 不够遗憾的是，在leetcode上，这种方法时间太长了 ==不通过== 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int countPrimes(int n) &#123; if (n &lt;= 2) &#123; return 0; &#125; // 2 直接写到里面去 int count = 1; struct ListNode *primes = (struct ListNode *) malloc(sizeof(struct ListNode)); struct ListNode *tail = primes; struct ListNode *temp = primes; primes-&gt;val = 2; primes-&gt;next = NULL; bool flag; for (int i = 3; i &lt; n; i++) &#123; flag = true; while (temp) &#123; if (i % temp-&gt;val == 0) &#123; flag = false; break; &#125; temp = temp-&gt;next; &#125; if (flag) &#123; tail-&gt;next = (struct ListNode *) malloc(sizeof(struct ListNode)); tail = tail-&gt;next; tail-&gt;val = i; tail-&gt;next = NULL; count++; &#125; temp = primes; &#125; temp = primes-&gt;next; while (temp) &#123; free(primes); primes = temp; temp = temp-&gt;next; &#125; free(primes); return count;&#125; 2.2 标记法​ 创建一个数组，每一次将2的倍数，倍数，5的倍数依次进行标记，直到标记到这个数为止 ​ 统计有多少没有被标记的，得到结果 ​ ==埃拉托斯特尼筛法 Sieve of Eratosthenes== 1234567891011121314151617181920212223242526272829303132333435363738394041int countPrimes(int n) &#123; if (n &lt;= 2) &#123; return 0; &#125; bool buf[n + 1]; memset(buf,true,n+1); buf[0] = false; buf[1] = false; // 这个是哨兵 buf[n] = true; int count = 0; int sign_pos = 2; while (sign_pos &lt; n) &#123; // 将sign_pos所有的倍数都标记为false for (int i = 2 * sign_pos; i &lt; n; i += sign_pos) &#123; if (i % sign_pos == 0) &#123; buf[i] = false; &#125; &#125; buf[n] = true; while (!buf[++sign_pos]); &#125; buf[n] = false; for (int i = 0; i &lt; n; i++) &#123; if (buf[i]) &#123; count++; &#125; &#125; return count; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 205. 同构字符串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20205.%C2%A0%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个字符串 *s* 和 t，判断它们是否是同构的。 如果 *s* 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1: 12输入: s = &quot;egg&quot;, t = &quot;add&quot;输出: true 示例 2: 12输入: s = &quot;foo&quot;, t = &quot;bar&quot;输出: false 示例 3: 12输入: s = &quot;paper&quot;, t = &quot;title&quot;输出: true 说明:你可以假设 *s* 和 t 具有相同的长度。 2、解题思路​ 这里需要说明的就是，字符串中，相同的字符，不管出现在什么位置上，都应该是相同的字符，不相同的字符不用管 ​ 创建一个映射数组，第一个字符串的一个字母映射到第二个字符串，遇到了以后就来判断，不相等，返回false； 123456789101112131415161718192021222324252627bool isIsomorphic(char* s, char* t) &#123; int sTot[256] = &#123;0&#125;; int tTos[256] = &#123;0&#125;; int size = strlen(s); for (int i = 0; i &lt; size; i++) &#123; if (sTot[s[i]] == 0) &#123; sTot[s[i]] = t[i]; &#125; if(tTos[t[i]] == 0)&#123; tTos[t[i]] = s[i]; &#125; if(sTot[s[i]] != t[i] || tTos[t[i]] != s[i])&#123; return false; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 206. 反转链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 2、解题思路2.1 迭代法​ 需要注意的是每一次保存下一个指针 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* reverseList(struct ListNode* head) &#123; if (!head || !head-&gt;next) &#123; return head; &#125; struct ListNode *node_next = head-&gt;next; struct ListNode *node_prev = NULL; while (node_next) &#123; head-&gt;next = node_prev; node_prev = head; head = node_next; node_next = node_next-&gt;next; &#125; head-&gt;next = node_prev; return head;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 207. 课程表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20207.%C2%A0%E8%AF%BE%E7%A8%8B%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 示例 1: 123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 说明: 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。 2、解题思路​ 首先回复一下图的基本知识，如何表示一个图呢 1、邻接矩阵 2、邻接表 ​ 具体的表示方法可以参考相关书籍 一般利用深度优先搜索和广度优先搜索来做 ​ 我们将这个图的拓扑序检测出来，如果存在拓扑序，表示能够学完所有课程，否则不能 ​ dfs和bfs都是根据节点的度来做的，bfs是入度，dfs是出度 ​ 使用dfs 基本的解题思路就是，首先表示出这个图，并且将每个节点的出度计算出来 将所有的出度为0的节点当度放到队列中，然后将他的前面节点的出度减一，如果出度减到0，放到队列中 设置一个计数器，每一次将出度为0的弹出，就将计数器加一 如果队列为空，表示已经遍历完成 这时候，判断计数器的值与所有课程是不是相等，如果相等，表示拓扑序存在，也就能够完成所有课程 ​ ​ 使用两个字典，一个字典存放每个节点度的值，另一个字典存放每个节点的前向节点列表，如果把这个出度为0的点移除，就将他的前驱节点的入度减一 123456789101112131415161718192021222324252627282930313233343536373839404142434445import queueclass Solution: def canFinish(self, numCourses, prerequisites): """ :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool """ degree = &#123;&#125; pre_class = &#123;&#125; for i in prerequisites: if pre_class.get(i[0]) is None: pre_class[i[0]] = [i[1]] else: pre_class[i[0]] += [i[1]] if degree.get(i[1]) is None: degree[i[1]] = 1 else: degree[i[1]] += 1 d = queue.deque() for i in range(numCourses): if i not in degree: d.append(i) count = 0 while d: size = len(d) for i in range(size): node = d.pop() count += 1 if pre_class.get(node) is not None: for j in pre_class[node]: degree[j] -= 1 if degree[j] == 0: d.append(j) if count == numCourses: return True else: return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 208. 实现 Trie (前缀树)]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20208.%C2%A0%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: 12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 truetrie.search(&quot;app&quot;); // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 2、解题思路​ 直接用哈希来做，python的话，就用字典实现即可 初始化 一开始，头指针，指向一个字典，字典里面什么都没有 插入的时候，就判断字符在不在，如果不在，就加入一个字符，值为{} 如果插入到最后一个字符，就在下一个字典中放入一个”end”，用来标识单词结束 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Trie: def __init__(self): """ Initialize your data structure here. """ self.head = &#123;&#125; def insert(self, word): """ Inserts a word into the trie. :type word: str :rtype: void """ cur = self.head for i in word: if cur.get(i) is None: cur[i] = &#123;&#125; cur = cur[i] if cur.get("end") is None: cur["end"] = 1 def search(self, word): """ Returns if the word is in the trie. :type word: str :rtype: bool """ cur = self.head for i in word: if i not in cur: return False cur = cur[i] if cur.get("end") is not None: return True else: return False def startsWith(self, prefix): """ Returns if there is any word in the trie that starts with the given prefix. :type prefix: str :rtype: bool """ cur = self.head for i in prefix: if i not in cur: return False cur = cur[i] return True # Your Trie object will be instantiated and called as such:# obj = Trie()# obj.insert(word)# param_2 = obj.search(word)# param_3 = obj.startsWith(prefix)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 209. 长度最小的子数组]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20209.%C2%A0%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的子数组。如果不存在符合条件的子数组，返回 0。 示例: 123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 2、解题思路​ 设置双指针，如果小于s，就将right加一，字数组之和加上新的数字 ​ 如果大于s，就更新result，并且减去left指向的值，left加一 123456789101112131415161718192021222324252627282930313233class Solution: def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ if len(nums) &lt;= 0: return 0 length = len(nums) result = length + 1 num_sums = nums[0] left = 0 right = 1 while left &lt; length: if num_sums &gt;= s: result = min(result, right - left) num_sums -= nums[left] left += 1 else: if right &lt; length: num_sums += nums[right] right += 1 else: break if result == length + 1: result = 0 return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 21. 合并两个有序链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2021.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述123456将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 2、解题思路2.1 向前判断​ 设置头指针和临时指针 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123; // 返回用的头指针，指向数据小的元素的头元素 struct ListNode *head; if (l1 == NULL || l2 == NULL) &#123; if (l1 == NULL) &#123; head = l2; &#125; else &#123; head = l1; &#125; return head; &#125; head = l1-&gt;val &gt; l2-&gt;val ? l2 : l1; struct ListNode *temp = head; if (l1-&gt;val &gt; l2-&gt;val) &#123; l2 = l2-&gt;next; &#125; else &#123; l1 = l1-&gt;next; &#125; while (l1 != NULL || l2 != NULL) &#123; if (l1 != NULL &amp;&amp; l2 == NULL) &#123; temp-&gt;next = l1; break; &#125; else if (l1 == NULL &amp;&amp; l2 != NULL) &#123; temp-&gt;next = l2; break; &#125; else &#123; if (l1-&gt;val &gt; l2-&gt;val) &#123; temp = temp-&gt;next = l2; l2 = l2-&gt;next; &#125; else &#123; temp = temp-&gt;next = l1; l1 = l1-&gt;next; &#125; &#125; &#125; return head; &#125; 2.2 递归法12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode *mergeTwoLists(struct ListNode *l1, struct ListNode *l2) &#123; if (l1 == NULL)&#123; return l2; &#125; if (l2 == NULL)&#123; return l1; &#125; if (l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next,l2); return l1; &#125;else&#123; l2-&gt;next = mergeTwoLists(l2-&gt;next,l1); return l2; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 210. 课程表 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20210.%C2%A0%E8%AF%BE%E7%A8%8B%E8%A1%A8%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例 1: 123输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2: 1234输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 说明: 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。 2、解题思路​ 这道题和前面207没什么区别，主要是最后的结果需要保存一下 使用两个字典，一个字典保存课的前向节点，一个字典保存出度 将出度为0的节点先放到队列中 遍历队列，将节点的所有的前向节点的度减一 节点放入结果集中 如果队列为空，跳出循环 判断结果集中的课程数量是不是等于n，是的话，将result逆序，返回，不然返回空集 123456789101112131415161718192021222324252627282930313233343536373839404142434445import queueclass Solution: def findOrder(self, numCourses, prerequisites): """ :type numCourses: int :type prerequisites: List[List[int]] :rtype: List[int] """ degree = &#123;&#125; pre_class = &#123;&#125; result = [] for i in prerequisites: if pre_class.get(i[0]) is None: pre_class[i[0]] = [i[1]] else: pre_class[i[0]] += [i[1]] if degree.get(i[1]) is None: degree[i[1]] = 1 else: degree[i[1]] += 1 d = queue.deque() for i in range(numCourses): if i not in degree: d.append(i) count = 0 while d: size = len(d) for i in range(size): node = d.pop() count += 1 result.append(node) if pre_class.get(node) is not None: for j in pre_class[node]: degree[j] -= 1 if degree[j] == 0: d.append(j) if count == numCourses: return list(reversed(result)) else: return []]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 211. 添加与搜索单词 - 数据结构设计]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20211.%C2%A0%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D%20-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述设计一个支持以下两种操作的数据结构： 12void addWord(word)bool search(word) search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。 示例: 1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true 说明: 你可以假设所有单词都是由小写字母 a-z 组成的。 2、解题思路​ 这道题目和前面的前缀树Trie差不多，只是在前面的基础上，增加一个.的判断，也就是正则 ​ 如果遇到的是点，就将当前的那个字符的左右的后续字符全部判断一遍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class WordDictionary: def __init__(self): """ Initialize your data structure here. """ self.head = &#123;&#125; self.head['.'] = [] def addWord(self, word): """ Adds a word into the data structure. :type word: str :rtype: void """ cur = self.head for i in word: if cur.get(i) is None: cur[i] = &#123;&#125; cur['.'].append(cur[i]) cur[i]['.'] = [] cur = cur[i] if cur.get("end") is None: cur["end"] = 1 def search(self, word): """ Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. :type word: str :rtype: bool """ return self.getWord(word, self.head, 0) def getWord(self, word, d, index): if index &gt;= len(word): if d.get("end") is not None: return True else: return False if d.get(word[index]) is None: return False else: if word[index] == '.': for i in d.get('.'): if self.getWord(word, i, index + 1): return True return False else: return self.getWord(word, d.get(word[index]), index + 1) # Your WordDictionary object will be instantiated and called as such:# obj = WordDictionary()# obj.addWord(word)# param_2 = obj.search(word)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 215. 数组中的第K个最大元素]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20215.%C2%A0%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 2、解题思路​ 一般直接想到的就是排序，然后找出来，但是快排的的话，时间复杂度也是$O(nlog(n))$的，这个时间复杂度，有堆排序，快排，还有归并排序，考虑不同的排序的特点，我们发现，堆排序在排序的过程中，就能找出第K个元素 ​ 堆是完全二叉树， 堆排序的基本思路是建立一个最大堆，然后将最前面的元素，也就是最大的元素与最后一个元素交换位置，然后将前面的元素调整成堆，不断地循环，最后得到排序数组 ​ 调整成堆在于将后面的每一个子树都调整成堆，然后整棵树就变成了堆 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ size = len(nums) self.build_heap(nums, size) cur = size - 1 for i in range(k-1): nums[0], nums[cur] = nums[cur], nums[0] self.heapify(nums, 0, cur) cur -= 1 return nums[0] def build_heap(self, nums, size): heap_size = (size - 1) // 2 while heap_size &gt;= 0: self.heapify(nums, heap_size, size) heap_size -= 1 def heapify(self, nums, node, size): left_child = 2 * node + 1 right_child = 2 * node + 2 max_node = node if left_child &lt; size and nums[max_node] &lt; nums[left_child]: max_node = left_child if right_child &lt; size and nums[max_node] &lt; nums[right_child]: max_node = right_child if max_node != node: nums[node], nums[max_node] = nums[max_node], nums[node] self.heapify(nums, max_node, size) ​ 写完以后，看了一下其他人的解答， 直接使用的库函数。。。。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 213. 打家劫舍 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20213.%C2%A0%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2: 1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 2、解题思路​ 这道题目与打家劫舍不同的就在于，现在需要考虑租后一个房间和最后一个房间的情况，于是，我们可以将这个问题分解，分解成两个打家劫舍问题 举个例子， 123456输入：[1 2 3]我们分成两种情况，一种是冲第一个开始，到倒数第二个结束，一种是从第2个开始，到最后一个结束[1 2][2 3]分别用动态规划判断，找出最大的那个即可 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def rob(self, nums): """ :type nums: List[int] :rtype: int """ length = len(nums) if length == 0: return 0 elif length == 1: return nums[0] temp = nums[1:] nums = nums[:-1] pre_pre1 = 0 pre1 = nums[0] pre_pre2 = 0 pre2 = temp[0] result1 = nums[0] result2 = temp[0] for i in range(1, len(nums)): cur1 = pre_pre1 + nums[i] cur2 = pre_pre2 + temp[i] result1 = max(cur1, pre1) result2 = max(cur2, pre2) pre_pre1 = pre1 pre1 = result1 pre_pre2 = pre2 pre2 = result2 return max(result1, result2)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 216. 组合总和 III]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20216.%C2%A0%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述找出所有相加之和为 *n* 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 12输入: k = 3, n = 7输出: [[1,2,4]] 示例 2: 12输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 2、解题思路​ 题目里面要求每种组合不包含重复数字，1-9的组合数可以直接使用库函数来求出来 1234567891011121314class Solution: def combinationSum3(self, k, n): """ :type k: int :type n: int :rtype: List[List[int]] """ result = [] for i in itertools.combinations(range(1, 10), k): if sum(i) == n: result.append(list(i)) return result ​ ​ 还有一个思路，深度优先搜索，从1开始，假如和是5，那么从1开始判断，如果找到和是5的了，就将组合加进去，没找到的话，就去掉，如果是使用和的形式，判断和小于0，就表示不存在，返回 ​ 如果等于0，就将当前结果放入结果集中]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 217. 存在重复元素]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 12输入: [1,2,3,1]输出: true 示例 2: 12输入: [1,2,3,4]输出: false 示例 3: 12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 2、解题思路2.1 异或​ 还记得前面求解众数的题目，使用了异或的思想，这里也可以使用，如果异或以后，与前一个值相等，表示找到了相等的值 ​ 这个使用了双重循环，很慢 123456789101112bool containsDuplicate(int *nums, int numsSize) &#123; for (int i = 0; i &lt; numsSize; i++) &#123; for (int j = i + 1; j &lt; numsSize; j++) &#123; if ((nums[i] ^ nums[j] )== 0) &#123; return true; &#125; &#125; &#125; return false;&#125; 2.2 排序法​ 先排序，在查找一遍 12345678910111213141516171819int compare(int *a, int *b) &#123; return *a - *b;&#125;bool containsDuplicate(int *nums, int numsSize) &#123; if (!nums || numsSize &lt;= 1) &#123; return false; &#125; qsort(nums, numsSize, sizeof(int), compare); for (int i = 0; i &lt; numsSize - 1; i++) &#123; if(nums[i] == nums[i+1])&#123; return true; &#125; &#125; return false;&#125; 2.3 哈希表法​ 将数字放到哈希表中，每个数字判断一次，如果存在，表示 2.4 去重长度比较​ 这个用python实现，非常简单 1234567class Solution: def containsDuplicate(self, nums): """ :type nums: List[int] :rtype: bool """ return len(nums) != len(set(nums)) ​ 只有一句话，但是效率不算很高，但是比起双重循环好多了]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 219.存在重复元素 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20219.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II%20%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1: 12输入: nums = [1,2,3,1], k = 3输出: true 示例 2: 12输入: nums = [1,0,1,1], k = 1输出: true 示例 3: 12输入: nums = [1,2,3,1,2,3], k = 2输出: false 2、解题思路​ 2.1 遍历法​ 这种方法比较慢 ​ 1234567891011121314151617181920bool containsNearbyDuplicate(int* nums, int numsSize, int k) &#123; if (!nums || numsSize &lt;= 1) &#123; return false; &#125; for (int i = 0; i &lt; numsSize; i++) &#123; for (int j = 1; j &lt;= k &amp;&amp; (i + j) &lt; numsSize; j++) &#123; if (nums[i] == nums[i + j]) &#123; return true; &#125; &#125; &#125; return false; &#125; 2.2 缓存法​ 在最大值和最小值的差值，创建缓存数组，存储下标 1234567891011121314151617181920212223242526272829303132bool containsNearbyDuplicate(int* nums, int numsSize, int k) &#123; if (!nums || numsSize &lt;= 1) &#123; return false; &#125; int min = INT32_MAX; int max = INT32_MIN; for (int i = 0; i &lt; numsSize; i++) &#123; min = min &gt; nums[i] ? nums[i] : min; max = max &lt; nums[i] ? nums[i] : max; &#125; int *buff_index = (int *) malloc(sizeof(int) * (max - min + 1)); for (int i = 0; i &lt; max - min + 1; ++i) buff_index[i] = -1; for (int i = 0; i &lt; numsSize; i++) &#123; if (buff_index[nums[i] - min] == -1) &#123; buff_index[nums[i] - min] = i; &#125; else &#123; if (i - buff_index[nums[i] - min] &lt;= k) &#123; return true; &#125; else &#123; buff_index[nums[i] - min] = i; &#125; &#125; &#125; return false; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 22. 括号生成]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2022.%C2%A0%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 2、解题思路​ 首先，我们来找一下规律 1： ​ () 2: ​ ()() ​ (()) 3: ​ ()()() ​ (()()) ​ (())() ​ ()(()) ​ ((())) ​ 我们可以这样考虑，设置计数器，也就是做括号与右括号的计数， 首先，如果左右括号数相等，添加左括号 如果左括号大于右括号数并且小于n，两种情况，添加左括号，添加右括号 最后，如果左括号数等于右括号数，并且和为2n，添加到结果集中 1234567891011121314151617181920212223242526class Solution: def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ if n &lt;= 0: return [] result = set() self.generate("", n, 0, 0, result) return list(result) def generate(self, current, n, left, right, ans): if left + right == 2 * n: ans.add(current) return if left &lt; n: self.generate(current + "(", n, left + 1, right, ans) if left &gt; right: self.generate(current + ")", n, left, right + 1, ans) else: self.generate(current + ")", n, left, right + 1, ans)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 220. 存在重复元素 III]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20220.%C2%A0%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20III%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。 示例 1: 12输入: nums = [1,2,3,1], k = 3, t = 0输出: true 示例 2: 12输入: nums = [1,0,1,1], k = 1, t = 2输出: true 示例 3: 12输入: nums = [1,5,9,1,5,9], k = 2, t = 3输出: false 2、解题思路​ 从题意中看，实际上，我们能够看到，也就是说，假设有一个窗口，能够向前滑动的话，如果当前窗口的元素都判断完毕，那么，窗口向前滑动一个元素，抽口中的所有元素都与最后一个元素进行差运算，如果过满足条件，即可返回True ​ 需要注意的是，第一个窗口较为特殊，每个元素都要与其他的元素进行判断 ​ 这样，等到窗口滑动到最后的时候，我们就能直接得出结果了 ​ 超出时间限制了。。。！ 12345678910111213141516171819202122232425class Solution: def containsNearbyAlmostDuplicate(self, nums, k, t): """ :type nums: List[int] :type k: int :type t: int :rtype: bool """ length = len(nums) if length &lt;= k + 1: for i in range(length): for j in range(i + 1, length): if abs(nums[i] - nums[j]) &lt;= t: return True else: for i in range(k + 1): for j in range(i + 1, k+1): if abs(nums[i] - nums[j]) &lt;= t: return True for i in range(k + 1, length): for j in range(1, k + 1): if abs(nums[i] - nums[i - j]) &lt;= t: return True return False ​ 算法没问题，不过既然超出了时间限制，那么就需要换种思路 ​ ​ 换一种思路，使用桶的思路 ​ 我们找出最小值，将当前值减去最小值，然后除以t+1, 得到t+1个桶，于是，只需要判断当前桶，前后桶即可 ​ 这个桶，可以使用哈希实现 ​ 下面这个通过了。 1234567891011121314151617181920212223242526272829303132333435class Solution: def containsNearbyAlmostDuplicate(self, nums, k, t): """ :type nums: List[int] :type k: int :type t: int :rtype: bool """ length = len(nums) if length &lt;= 1 or t &lt; 0 or k &lt; 1: return False min_value = min(nums) buff = &#123;&#125; for i in range(length): if i &gt; k: key = (nums[i - k - 1] - min_value) // (t + 1) buff.pop(key) key = (nums[i] - min_value) // (t + 1) if buff.get(key) is not None: return True small = buff.get(key - 1) if small is not None and (nums[i] - small) &lt;= t: return True big = buff.get(key + 1) if big is not None and (big - nums[i]) &lt;= t: return True buff[key] = nums[i] return False ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 221. 最大正方形]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20221.%C2%A0%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 2、解题思路​ 看到这道题，首先就想到的是使用动态规划来做 如果左上角的3个都不为0，继续判断 最小值正方形的边长加一 更新最大正方形 123456789101112131415161718192021222324252627282930313233class Solution: def maximalSquare(self, matrix): """ :type matrix: List[List[str]] :rtype: int """ row = len(matrix) if row &lt;= 0: return 0 col = len(matrix[0]) buff = [[0] * col for i in range(row)] result = 0 for i in range(col): if matrix[0][i] == '1': buff[0][i] = 1 result = max(result, 1) for i in range(row): if matrix[i][0] == '1': buff[i][0] = 1 result = max(result, 1) for i in range(1, row): for j in range(1, col): if matrix[i][j] == '1': min_value = min(buff[i - 1][j - 1], buff[i][j - 1], buff[i - 1][j]) if min_value != 0: buff[i][j] = (int(math.sqrt(min_value)) + 1) ** 2 else: buff[i][j] = 1 result = max(result, buff[i][j]) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 222. 完全二叉树的节点个数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20222.%C2%A0%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例: 12345678输入: 1 / \ 2 3 / \ /4 5 6输出: 6 2、解题思路​ 判断当前的二叉树是不是完全二叉树，如果是，返回直接计算出来，返回 1234567891011121314151617181920212223242526272829303132333435363738# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def countNodes(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 left = self.getLeftDepth(root) right = self.getrightDepth(root) if left == right: return 2 ** left - 1 else: return 1 + self.countNodes(root.left) + self.countNodes(root.right) def getLeftDepth(self, root): count = 1 while root.left: count += 1 root = root.left return count def getrightDepth(self, root): count = 1 while root.right: count += 1 root = root.right return count]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 225. 用队列实现栈]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20225.%C2%A0%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述使用队列实现栈的下列操作： push(x) – 元素 x 入栈 pop() – 移除栈顶元素 top() – 获取栈顶元素 empty() – 返回栈是否为空 注意: 你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 2、解题思路​ 因为在C的库里面，没有已经实现的队列，这里主要是写一下实现思路 ​ 想要用队列模拟一个栈，首先我们看到，队列是先入先出，栈是后入先出，先要模拟栈的操作，我们需要使用两个队列 ​ 假设现在有两个队列，队列1，队列2，想在想要入栈， ​ 判断队列1，2为空，将元素放入队列1中， ​ 继续入栈，队列1不为空，将元素放到队列1中 ​ 然后想要出栈，该如何做呢，首先将除了最后一个元素，其他所有的都出队列，放到另一个队列中，然后本队列就只剩下一个元素了，将这个元素弹出，并返回 ​ 继续想要入栈，这时候，队列2不为空，放到队列2里面 ​ 入栈，放到队列2中 ​ 出栈，将队列2中除了最后一个元素其他都出队列，放到第一个队列里面，然后将最后一个返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071typedef struct &#123; int *stack; int size; int head;&#125; MyStack;/** Initialize your data structure here. */MyStack *myStackCreate(int maxSize) &#123; MyStack *s = (MyStack *) malloc(sizeof(MyStack)); s-&gt;stack = (int *) malloc(sizeof(int) * maxSize); s-&gt;size = maxSize; s-&gt;head = -1; return s;&#125;/** Push element x onto stack. */void myStackPush(MyStack *obj, int x) &#123; if (obj-&gt;head &lt; obj-&gt;size - 1) &#123; obj-&gt;stack[++obj-&gt;head] = x; &#125;&#125;/** Removes the element on top of the stack and returns that element. */int myStackPop(MyStack *obj) &#123; if (obj-&gt;head &gt;= 0) &#123; return obj-&gt;stack[obj-&gt;head--]; &#125; else &#123; return -1; &#125;&#125;/** Get the top element. */int myStackTop(MyStack *obj) &#123; if (obj-&gt;head &gt;= 0) &#123; return obj-&gt;stack[obj-&gt;head]; &#125; else &#123; return -1; &#125;&#125;/** Returns whether the stack is empty. */bool myStackEmpty(MyStack *obj) &#123; if (obj-&gt;head &lt;= -1) &#123; return true; &#125; else &#123; return false; &#125;&#125;void myStackFree(MyStack *obj) &#123; if (obj) &#123; if (obj-&gt;stack) &#123; free(obj-&gt;stack); &#125; free(obj); &#125;&#125;/** * Your MyStack struct will be instantiated and called as such: * struct MyStack* obj = myStackCreate(maxSize); * myStackPush(obj, x); * int param_2 = myStackPop(obj); * int param_3 = myStackTop(obj); * bool param_4 = myStackEmpty(obj); * myStackFree(obj); */]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 223. 矩形面积]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20223.%C2%A0%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。 每个矩形由其左下顶点和右上顶点坐标表示，如图所示。 示例: 输入: -3, 0, 3, 4, 0, -1, 9, 2 输出: 45 说明: 假设矩形面积不会超出 int 的范围。 2、解题思路​ 基本思路比较简单，分成两步： 判断有没有相交 如果相交，对横纵坐标分别排序，找出中间的两个，然后得到新的相交矩形 然后用总的面积减去相交面积 1234567891011121314151617181920212223class Solution: def computeArea(self, A, B, C, D, E, F, G, H): """ :type A: int :type B: int :type C: int :type D: int :type E: int :type F: int :type G: int :type H: int :rtype: int """ total = (C - A) * (D - B) + (G - E) * (H - F) if A &gt;= G or C &lt;= E or B &gt;= H or D &lt;= F: return total temp_row = sorted([A, C, E, G])[1:-1] temp_col = sorted([B, D, F, H])[1:-1] intersection = (temp_row[1] - temp_row[0]) * (temp_col[1] - temp_col[0]) return total - intersection]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 226.翻转二叉树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述翻转一棵二叉树。 示例： 输入： 12345 4 / \ 2 7 / \ / \1 3 6 9 输出： 12345 4 / \ 7 2 / \ / \9 6 3 1 备注:这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 2、解题思路123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */struct TreeNode* invertTree(struct TreeNode* root) &#123; if (!root) &#123; return NULL; &#125; struct TreeNode *temp; if (root-&gt;left || root-&gt;right) &#123; temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; &#125; invertTree(root-&gt;left); invertTree(root-&gt;right); return root;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 227. 基本计算器 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20227.%C2%A0%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述实现一个基本的计算器来计算一个简单的字符串表达式的值。 字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格 。 整数除法仅保留整数部分。 示例 1: 12输入: &quot;3+2*2&quot;输出: 7 示例 2: 12输入: &quot; 3/2 &quot;输出: 1 示例 3: 12输入: &quot; 3+5 / 2 &quot;输出: 5 说明： 你可以假设所给定的表达式都是有效的。 请不要使用内置的库函数 eval。 2、解题思路​ 一般的，遇到这样的都能够使用栈来做，我们维护两个栈，一个栈存放数字，另一个栈存放运算符，因为乘法和除法的运算优先级比较高，那么我们在第一遍进行扫描的时候，就将乘除法计算出来，最后，运算符栈中剩下的就是加减法，这时候，每一次取出一个符号，就对数字栈的最后两个元素进行运算即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution: def calculate(self, s): """ :type s: str :rtype: int """ nums = [] sign = [] all_num = &#123;"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9&#125; all_signs = &#123;"+": 10, "-": 11, "*": 12, "/": 13&#125; calculate = False current_sign = -1 for i in s: if calculate and i in all_num: if current_sign == all_signs["*"]: nums[-1] = nums[-1] * all_num[i] else: nums[-1] = nums[-1] // all_num[i] calculate = False continue if i in all_num: nums.append(all_num[i]) if i in all_signs: if all_signs[i] &lt; all_signs["*"]: sign.append(all_signs[i]) else: current_sign = all_signs[i] calculate = True for i in range(len(sign) - 1, -1, -1): num = nums.pop() if sign[i] == all_signs["+"]: nums[-1] = nums[-1] + num else: nums[-1] = nums[-1] - num return nums[0]print(Solution().calculate("1+2+3*6")) ​ ​ 直接写出来，思路没啥问题，不过没理解好，如果是多位数字的话，需要判断的。。。 ​ 上面写出来的是一位的数字的情况 ​ 如果有多位数的话，还是将表达式转换成后缀表达式再来做 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution: def calculate(self, s): """ :type s: str :rtype: int """ nums = [] sign = [] expression = [] all_num = &#123;"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9&#125; all_signs = &#123;"+": 10, "-": 11, "*": 12, "/": 13&#125; low_priority = &#123;"+": 10, "-": 11&#125; high_priority = &#123;"*": 12, "/": 13&#125; is_num = False for i in s: if i in all_num: if is_num: expression[-1] = expression[-1] + i else: expression.append(i) is_num = True if i in all_signs: is_num = False if sign: if sign[-1] in high_priority: expression.append(sign.pop()) if sign and i in low_priority: expression.append(sign.pop()) sign.append(i) expression.extend(reversed(sign)) if len(expression) &lt;= 0: return 0 print(expression) for i in expression: if i not in all_signs: nums.append(int(i)) else: num = nums.pop() if i == "+": nums[-1] += num elif i == "-": nums[-1] -= num elif i == "*": nums[-1] *= num elif i == "/": nums[-1] //= num return nums[-1] ​ ​ 终于通过了，关于运算符的优先级的判断这需要注意 ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 228. 汇总区间]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20228.%C2%A0%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。 示例 1: 123输入: [0,1,2,4,5,7]输出: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。 示例 2: 123输入: [0,2,3,4,6,8,9]输出: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]解释: 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。 2、解题思路​ 题目比较简单，设置两个指针，一个指向区间首部， ​ 另一个指向前面一个数，如果当前数减去前面的数之差不为1，就放到结果集中 1234567891011121314151617181920212223242526272829303132class Solution: def summaryRanges(self, nums): """ :type nums: List[int] :rtype: List[str] """ if len(nums) == 0: return [] result = [] first = nums[0] pre = nums[0] - 1 for i in nums: if i - pre != 1: pre if first == pre: result.append(str(first)) else: result.append(str(first) + "-&gt;" + str(pre)) first = i pre = i if nums[-1] == first: result.append(str(first)) else: result.append(str(first) + "-&gt;" + str(nums[-1])) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 229. 求众数 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20229.%C2%A0%E6%B1%82%E4%BC%97%E6%95%B0%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。 示例 1: 12输入: [3,2,3]输出: [3] 示例 2: 12输入: [1,1,1,3,3,2,2,2]输出: [1,2] 2、解题思路​ 在前面已经做过求众数，之前是超过一半，现在是超过⌊ n/3 ⌋ ，那么最多就会有2个众数 ​ 同样的，使用摩尔投票法，选出两个候选众数 ​ 然后判断他们出现的次数是不是超过限定值 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: def majorityElement(self, nums): """ :type nums: List[int] :rtype: List[int] """ if not nums: return [] m = nums[0] - 1 n = nums[0] - 1 count_m = 0 count_n = 0 for i in nums: if i == m: count_m += 1 elif i == n: count_n += 1 elif count_m &lt;= 0: m = i count_m = 1 elif count_n &lt;= 0: n = i count_n = 1 else: count_m -= 1 count_n -= 1 count_m = 0 count_n = 0 for i in nums: if i == m: count_m += 1 elif i == n: count_n += 1 result = [] if count_m &gt; len(nums) // 3: result.append(m) if count_n &gt; len(nums) // 3: result.append(n) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 23. 合并K个排序链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2023.%C2%A0%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 2、解题思路​ 实际上，这个题目很简单，仅仅需要注意的就是，我们每一次取出来的那个都是值最小的 ​ 因此，我们使用堆排序，每一次取出最小的那个头指针，降低时间复杂度 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype: ListNode """ heap = [(x.val, x) for x in lists if x] heapq.heapify(heap) res = ListNode(0) cur = res while heap: node = heapq.heappop(heap) cur.next = node[1] cur = cur.next next_node = node[1].next if next_node: heapq.heappush(heap, (next_node.val, next_node)) cur.next = None return res.next]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 230. 二叉搜索树中第K小的元素]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20230.%C2%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1: 1234567输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 1 示例 2: 123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1输出: 3 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？ 2、解题思路2.1 中序遍历​ 直接使用中序遍历，进行计数，找出第k个元素 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: count = 0 result = 0 def kthSmallest(self, root, k): """ :type root: TreeNode :type k: int :rtype: int """ self.dfs(root, k) self.count = 0 return self.result def dfs(self, root, k): if not root: return self.dfs(root.left, k) self.count += 1 if self.count == k: self.result = root.val return self.dfs(root.right, k)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 231. 2的幂]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20231.%C2%A02%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 123输入: 1输出: true解释: 20 = 1 示例 2: 123输入: 16输出: true解释: 24 = 16 示例 3: 12输入: 218输出: false 2、解题思路​ 整数如果小于等于0，返回false ​ 如果整数中1的个数不为1，返回假 12345678910111213141516171819202122bool isPowerOfTwo(int n) &#123; if(n&lt;=0)&#123; return false; &#125; int count = 0; for (int i = 0; i &lt; 32; i++) &#123; if (n &amp; 1) &#123; count++; &#125; n = n &gt;&gt; 1; &#125; if (count != 1) &#123; return false; &#125; else &#123; return true; &#125; &#125; ​ 简单写法： 12345if(n &lt;=0)&#123; return false; &#125; return !(n &amp; (n-1));]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 232. 用栈实现队列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20232.%C2%A0%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。 pop() – 从队列首部移除元素。 peek() – 返回队列首部的元素。 empty() – 返回队列是否为空。 示例: 1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 2、解题思路​ 没有直接写一个栈，然后模拟，这里主要写一下基本思路 1 首先，创建两个栈 2 然后现在想要入队一个元素，判断栈1，2都是空，入栈1 3继续入队，判断栈1不为空，入栈1； 4出队，判断栈1不为空，将栈1的每一个元素出栈，放到栈2中，最后将栈2的栈顶元素出栈，就可以，接着，将栈2中的所有元素弹出来，放入栈1 5 入队继续放到栈1 如果需要出队，继续执行第4步 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374typedef struct &#123; int *queue; int head; int rear; int size; int capacity;&#125; MyQueue;/** Initialize your data structure here. */MyQueue *myQueueCreate(int maxSize) &#123; MyQueue *q = (MyQueue *) malloc(sizeof(MyQueue)); q-&gt;queue = (int *) malloc(sizeof(int) * (maxSize)); q-&gt;head = 0; q-&gt;rear = 0; q-&gt;size = 0; q-&gt;capacity = maxSize; return q;&#125;/** Push element x to the back of queue. */void myQueuePush(MyQueue *obj, int x) &#123; if (obj-&gt;size &lt; obj-&gt;capacity) &#123; obj-&gt;queue[obj-&gt;rear] = x; obj-&gt;rear = (obj-&gt;rear + 1) % obj-&gt;capacity; obj-&gt;size++; &#125;&#125;/** Removes the element from in front of queue and returns that element. */int myQueuePop(MyQueue *obj) &#123; int temp = -1; if (obj-&gt;size &gt; 0) &#123; temp = obj-&gt;queue[obj-&gt;head]; obj-&gt;head = (obj-&gt;head + 1) % obj-&gt;capacity; obj-&gt;size--; &#125; return temp;&#125;/** Get the front element. */int myQueuePeek(MyQueue *obj) &#123; return obj-&gt;size &gt; 0 ? obj-&gt;queue[obj-&gt;head] : -1;&#125;/** Returns whether the queue is empty. */bool myQueueEmpty(MyQueue *obj) &#123; return obj-&gt;size == 0;&#125;void myQueueFree(MyQueue *obj) &#123; if (obj) &#123; if (obj-&gt;queue) &#123; free(obj-&gt;queue); &#125; free(obj); &#125;&#125;/** * Your MyQueue struct will be instantiated and called as such: * struct MyQueue* obj = myQueueCreate(maxSize); * myQueuePush(obj, x); * int param_2 = myQueuePop(obj); * int param_3 = myQueuePeek(obj); * bool param_4 = myQueueEmpty(obj); * myQueueFree(obj); */]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 234. 回文链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20234.%C2%A0%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述请判断一个链表是否为回文链表。 示例 1: 12输入: 1-&gt;2输出: false 示例 2: 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 2、解题思路​ 为额尽量实现$O(1)$ 的空间复杂度，而且尽可能降低时间复杂度，选择将链表的左边部分反转，判断完以后，反转回来 确认链表的长度 根据长度，找到开始比较的值，例如，长度是4，如果从1开始计数，就从中间开始比较，先比较第2个和第3个，然后是第1个和第4个 如果是5个，第3个不用比较， 先比较第2个和第3个，然后是第1个和第4个 将前面一半元素进行反转，然后得到两个链表进行比较，她们的末尾都是null 比较完毕得到结果，将前面的一半元素恢复原状 返回结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */bool isPalindrome(struct ListNode* head) &#123; if (!head || !head-&gt;next) &#123; return true; &#125; int length = 0; struct ListNode *node = head; while (node) &#123; length++; node = node-&gt;next; &#125; bool result = true; // 查找需要比较的位置 struct ListNode *left = head; struct ListNode *right = head; int left_pos = length / 2; int right_pos = length - length / 2 + 1; int compare_count = left_pos; while (--left_pos) &#123; left = left-&gt;next; &#125; while (--right_pos) &#123; right = right-&gt;next; &#125; // 反转前面的length/2 struct ListNode *node_next = head-&gt;next; struct ListNode *node_prev = NULL; struct ListNode *current = head; while (current != left) &#123; current-&gt;next = node_prev; node_prev = current; current = node_next; node_next = node_next-&gt;next; &#125; current-&gt;next = node_prev; // 进行比较 while (compare_count--) &#123; if (left-&gt;val != right-&gt;val) &#123; result = false; break; &#125; left = left-&gt;next; right = right-&gt;next; &#125; // 左面反转回来 while (node_prev != NULL) &#123; current-&gt;next = node_next; node_next = current; current = node_prev; node_prev = node_prev-&gt;next; &#125; current-&gt;next = NULL; return result;&#125; ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 235. 二叉搜索树的最近公共祖先]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20235.%C2%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 1234567 _______6______ / \ ___2__ ___8__/ \ / \0 _4 7 9 / \ 3 5 示例 1: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 2、解题思路​ 其实题目很简单，因为是二叉搜索树，所以，给定两个数，如果在同一棵子树，就继续向下寻找 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) &#123; if (!root) &#123; return root; &#125; struct TreeNode *result = root; if (result-&gt;val == p-&gt;val || result-&gt;val == q-&gt;val || result-&gt;val &gt; p-&gt;val &amp;&amp; result-&gt;val &lt; q-&gt;val || result-&gt;val &lt; p-&gt;val &amp;&amp; result-&gt;val &gt; q-&gt;val) &#123; return result; &#125; if (result-&gt;val &gt; p-&gt;val &amp;&amp; result-&gt;val &gt; q-&gt;val) &#123; result = lowestCommonAncestor(result-&gt;left, p, q); &#125; else &#123; result = lowestCommonAncestor(result-&gt;right, p, q); &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 236. 二叉树的最近公共祖先]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20236.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 1234567 _______3______ / \ ___5__ ___1__/ \ / \6 _2 0 8 / \ 7 4 示例 1: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 2、解题思路​ 思路很简单，用递归来做 判断当期节点是否是待判断节点中的一个，如果是，返回当前节点 判断左子树 判断右子树 如果左右子树都不是空，返回root 如果其中一个为空，返回不为空的那个 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if not root or root == p or root == q: return root leftNode = self.lowestCommonAncestor(root.left, p, q) rightNode = self.lowestCommonAncestor(root.right, p, q) if leftNode and rightNode: return root if not leftNode: return rightNode return leftNode]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 237. 删除链表中的节点]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20237.%C2%A0%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9]，它可以表示为: 14 -&gt; 5 -&gt; 1 -&gt; 9 示例 1: 123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 123输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 2、解题思路​ 主要是理解题意很重要，现在给定的是要删除的节点的指针，但是没有给前面的指针，如何保证不断呢？ ​ 通过赋值的形式，将后面的节点覆盖本节点的值，指针也覆盖，就相当于删除了本节点 ​ 1234567891011/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */void deleteNode(struct ListNode* node) &#123; node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 238. 除自身以外数组的乘积]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20238.%C2%A0%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 12输入: [1,2,3,4]输出: [24,12,8,6] 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 2、解题思路​ 如果不考虑时间复杂度和空间复杂度，题目很简单 ​ 考虑的话，就需要一些技巧 将前向乘积放到结果数组中 然后一面计算后向乘积，一面将结果放到数组中 1234567891011121314151617181920class Solution: def productExceptSelf(self, nums): """ :type nums: List[int] :rtype: List[int] """ length = len(nums) result = [0] * length value = 1 for i in range(length): result[i] = value value *= nums[i] value = 1 for i in range(length - 1, -1, -1): result[i] = result[i] * value value *= nums[i] return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 24. 两两交换链表中的节点]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2024.%C2%A0%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例: 1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 说明: 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 2、解题思路​ 设置3个指针， ​ 指向第一个，第二个，第三个节点，然后第一个节点指向第三个节点，第二个节点指向第一个节点，然后向后移动 ​ 直接用递归来做，很简单 ​ 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ result = self.swap(head) return result def swap(self, current): if current: second = current.next if second: third = second.next prev = second second.next = current current.next = self.swap(third) return second else: return current else: return current]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 240. 搜索二维矩阵 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20240.%C2%A0%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 2、解题思路​ 思路很简单，因为行是升序，列也是升序， 按照斜对角线，找出两个元素，这两个元素组成了一个小的矩阵 根据规则，左上角的是矩阵中最小的，右下角的是最大的 如果是方阵，这样就出来了 如果不是方阵，想要定位就要换个方法 同样是从左上角右下角开始寻找，找出两个点， 左上角的那个点要小于target 右下角的那个点要大于target 这两个点要组成与各矩形，并且是左面的在上，右面的在下的话，就满足条件，进行查找 然后，我们就排除了左上角和右下角的元素 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 寻找20 123456从左上角开始，找到小于20的那个元素找到17然后从右下角开始，先向左找到23的时候，就已经不符合矩阵的形成了向上，找到22，也不符合矩阵形成，退出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution: def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ row = len(matrix) if row &lt;= 0: return False col = len(matrix[0]) if col &lt;= 0: return False diagonal = min(row, col) left_up = [0, 0] for i in range(diagonal): if matrix[left_up[0]][left_up[1]] == target: return True if left_up[0] &lt; diagonal - 1 and matrix[left_up[0]][left_up[1]] &lt; target: left_up[0] += 1 left_up[1] += 1 else: if left_up[0] &gt; 0: left_up[0] -= 1 left_up[1] -= 1 break right_up = [row - 1, col - 1] for i in range(diagonal): if matrix[right_up[0]][right_up[1]] == target: return True if right_up[0] - diagonal &gt; 0 and right_up[1] - diagonal &gt; 0 and matrix[right_up[0]][right_up[1]] &gt; target: right_up[0] -= 1 right_up[1] -= 1 else: if right_up[0] &lt; row - 1: right_up[0] += 1 right_up[1] += 1 break if left_up[0] &lt;= right_up[0] and left_up[1] &lt;= right_up[1]: for i in range(left_up[0], right_up[0] + 1): for j in range(right_up[1] + 1): if matrix[i][j] == target: return True for i in range(left_up[0]): for j in range(left_up[1], right_up[1] + 1): if matrix[i][j] == target: return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 241. 为运算表达式设计优先级]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20241.%C2%A0%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 示例 1: 12345输入: &quot;2-1-1&quot;输出: [0, 2]解释: ((2-1)-1) = 0 (2-(1-1)) = 2 示例 2: 12345678输入: &quot;2*3-4*5&quot;输出: [-34, -14, -10, -10, 10]解释: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 2、解题思路​ 这道题目是一个分治法的典型应用，将大的问题分解成小问题求解 以每一个分隔符进行分割，变成两个子串，结果就是两个子串的值之和 因为每个子串都有多个值，我们要对第一个字串中的每个值进行匹配第二个子串值 例如 1&quot;2-1-1&quot; 第一步，分割成 12345&quot;2&quot; &quot;1-1&quot;当前符号 &quot;-&quot;得到左面的值[2]得到右面的值[0]组合得到[2] 第二次分割 12345&quot;2-1&quot; &quot;1&quot;当前符号 &quot;-&quot;得到左面的值[1]得到右面的值[1]组合得到[0] 将组合得到的数字放到结果集中 1[2 0] 12345678910111213141516171819202122232425262728293031class Solution: def diffWaysToCompute(self, input): """ :type input: str :rtype: List[int] """ if not input: return [] ans = [] signs = &#123;'+': 1, '-': 2, '*': 3&#125; for i in range(len(input)): if input[i] in signs: left = self.diffWaysToCompute(input[:i]) right = self.diffWaysToCompute(input[i + 1:]) for m in left: for n in right: if signs[input[i]] == 1: ans.append(m + n) elif signs[input[i]] == 2: ans.append(m - n) elif signs[input[i]] == 3: ans.append(m * n) if not ans: ans.append(int(input)) return ans]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 242. 有效的字母异位词]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20242.%C2%A0%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 1: 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2: 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 2、解题思路​ 实际上，这个题目是要找出两个字符串，她们有相同的字母构成，但是顺序可能不同，通过异或来做，十分简单 ​ 将第一个字符串所有字母进行异或， ​ 将第二个字符串所有字母进行异或， ​ 如果两个异或值相等，表示相等，不相等返回false ​ ​ 这个思路有一点问题，就是aa，bb这样的也会认为是相等的 ​ 异或的话，目前还没有好的解决办法 2.1 排序法​ 排序后比较 123456789101112131415161718192021222324252627282930313233343536373839int cmp(const void *a, const void *b) &#123; return *(char *) a - *(char *) b;&#125;bool isAnagram(char *s, char *t) &#123; if (!s &amp;&amp; !t) &#123; return true; &#125; if (strlen(s) != strlen(t)) &#123; return false; &#125; int length = strlen(s); char *s1 = (char *) malloc(sizeof(char) * strlen(s) + 1); char *t1 = (char *) malloc(sizeof(char) * strlen(t) + 1); strcpy(s1, s); strcpy(t1, t); qsort(s1, length, sizeof(char), cmp); qsort(t1, length, sizeof(char), cmp); for (int i = 0; i &lt; length; i++) &#123; if (s1[i] != t1[i]) &#123; free(t1); free(s1); return false; &#125; &#125; free(t1); free(s1); return true;&#125; 2.2 计数法1234567891011121314151617181920212223242526272829303132bool isAnagram(char *s, char *t) &#123; if (!s &amp;&amp; !t) &#123; return true; &#125; if (strlen(s) != strlen(t)) &#123; return false; &#125; int buf[26] = &#123;0&#125;; int i = 0; while (s[i]) &#123; buf[s[i++] - 'a']++; &#125; i = 0; while (t[i]) &#123; buf[t[i++] - 'a']--; &#125; for (i = 0; i &lt; 26; i++) &#123; if (buf[i] != 0) &#123; return false; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 25. k个一组翻转链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2025.%C2%A0k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 2、解题思路​ 实际上这道题是比较简单的 首先，设置一个头指针 然后，截取一段长度为k的链表进行翻转，然后接起来 如果长度小于k，直接接起来即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseKGroup(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if k == 1: return head res = ListNode(0) cur = res begin = head end = begin count = 1 while cur: count = 1 end = begin while count &lt; k and end: end = end.next count += 1 if count &gt;= k and end: next_section = begin # 截取一段，最后一个next设置为None first = begin begin = end.next end.next = None middle = first.next while middle: third = middle.next middle.next = first first = middle middle = third cur.next = first cur = next_section else: cur.next = begin cur = None return res.next ​ 主要是几个细节需要注意，截取的时候，如果已经到了None，表示长度已经不够，这时候，也需要直接接起来]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 257. 二叉树的所有路径]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 1234567891011输入: 1 / \2 3 \ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 2、解题思路​ 递归查找 ​ 如果有子节点，就继续向下找 ​ 如果是叶子节点，构造字符串，返回 ​ 不是叶子节点，将左右子节点的所有的字符串重新构造，向上返回 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; *//** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */const char *direction = "-&gt;";char *numToString(int n) &#123; int length = 1; int temp = n; while (temp &gt; 0) &#123; temp /= 10; length++; &#125; char *result = (char *) malloc(sizeof(char) * (length + 1)); sprintf(result, "%d", n); return result;&#125;void freeBuff(char **buf, int size) &#123; for (int i = 0; i &lt; size; i++) &#123; free(buf[i]); &#125;&#125;char **binaryTreePath(struct TreeNode *root, int level, int *returnSize) &#123; char **result; // 没有左右节点 // 当前节点的值 char *num = numToString(root-&gt;val); // 如果是根节点 if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123; result = (char **) malloc(sizeof(char *)); if (level == 0) &#123; *result = num; &#125; else &#123; *result = (char *) malloc(sizeof(char) * (strlen(num) + 3)); (*result)[0] = '\0'; strcat(*result, direction); strcat(*result, num); free(num); &#125; *returnSize = 1; return result; &#125; // 有左右节点，不是根节点 char **left; char **right; int left_size = 0; int right_size = 0; if (root-&gt;left) &#123; left = binaryTreePath(root-&gt;left, level + 1, returnSize); left_size = *returnSize; &#125; if (root-&gt;right) &#123; right = binaryTreePath(root-&gt;right, level + 1, returnSize); right_size = *returnSize; &#125; *returnSize = left_size + right_size; result = (char **) malloc(sizeof(char *) * (left_size + right_size)); if (level == 0) &#123; for (int i = 0; i &lt; left_size; i++) &#123; result[i] = (char *) malloc(sizeof(char) * (strlen(left[i]) + strlen(num) + 1)); result[i][0] = 0; strcat(result[i], num); strcat(result[i], left[i]); &#125; for (int i = 0; i &lt; right_size; i++) &#123; result[i + left_size] = (char *) malloc(sizeof(char) * (strlen(right[i]) + strlen(num) + 1)); result[i + left_size][0] = 0; strcat(result[i + left_size], num); strcat(result[i + left_size], right[i]); &#125; &#125; else &#123; for (int i = 0; i &lt; left_size; i++) &#123; result[i] = (char *) malloc(sizeof(char) * (strlen(left[i]) + strlen(num) + 3)); result[i][0] = 0; strcat(result[i], direction); strcat(result[i], num); strcat(result[i], left[i]); &#125; for (int i = 0; i &lt; right_size; i++) &#123; result[i + left_size] = (char *) malloc(sizeof(char) * (strlen(right[i]) + strlen(num) + 3)); result[i + left_size][0] = 0; strcat(result[i + left_size], direction); strcat(result[i + left_size], num); strcat(result[i + left_size], right[i]); &#125; &#125; free(num); freeBuff(left, left_size); freeBuff(right, right_size); return result;&#125;char **binaryTreePaths(struct TreeNode *root, int *returnSize) &#123; if (!root) &#123; *returnSize = 0; return NULL; &#125; return binaryTreePath(root, 0, returnSize);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 258.各位相加]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20258.%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例: 123输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 进阶:你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？ 2、解题思路​ ​ 通过寻找规律，我们发现，9的倍数结果都是9， ​ 如何找到这个规律呢 ​ 0的话，是0 1~9 就是1~9 然后 10~18， 是 1~9 接着，是19~27 ，是1~9 也就是说，不断地循环着 从1开始，是一个周期函数，如果正好将9整除，就是9，如果不能，对9取余，就是偏移量 1234567891011int addDigits(int num) &#123; if (num == 0) &#123; return 0; &#125; int temp = num % 9; if (temp == 0) &#123; return 9; &#125; else &#123; return temp; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 260. 只出现一次的数字 III]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20260.%C2%A0%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%20III%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。 示例 : 12输入: [1,2,1,3,2,5]输出: [3,5] 注意： 结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？ 2、解题思路​ 看到这道题，结合之前题目的思路，如果通过异或，我们就能够得到只出现一次的两个数的异或值 ​ 然后找到其中的一位为1的，也就是说这一位，两个数字不同，我们根据这一位，将所有的数据分成两组，然后进行异或，得到了两个数，就是我们想要的结果 ​ 123456789101112131415161718192021class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: List[int] """ xor_nums = 0 for i in nums: xor_nums ^= i xor_nums &amp;= -xor_nums num1 = 0 num2 = 0 for i in nums: if xor_nums &amp; i: num1 ^= i else: num2 ^= i return [num1, num2]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 26. 删除排序数组中的重复项]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2026.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 2、解题思路​ 设置一个不重复位置指针，另一个向前移动，每一次都判断之前的是不是重复 ​ 如果重复，当前指针直接加一 ​ 不重复，将不重复指针加一，并将当前值复制过去，然后当前指针加一 ​ 这种写法针对的所有数组，并不仅仅是排序数组 12345678910111213141516171819202122232425262728int removeDuplicates(int *nums, int numsSize) &#123; if (numsSize &lt;= 1) &#123; return numsSize; &#125; int left_pos = 0; int cur_pos = 1; bool flag_same = false; while (numsSize-- &gt; 1) &#123; for (int i = left_pos; i &gt;= 0; i--) &#123; if (nums[cur_pos] == nums[i]) &#123; flag_same = true; break; &#125; &#125; if (flag_same) &#123; cur_pos++; flag_same = false; &#125; else &#123; nums[++left_pos] = nums[cur_pos]; cur_pos++; &#125; &#125; return left_pos + 1;&#125; 下面的这种写法，仅仅针对于排序数组 123456789101112int removeDuplicates(int* nums, int numsSize) &#123; if (numsSize &lt;= 1)&#123; return numsSize; &#125; int left_pos=0; for(int i = 1; i &lt; numsSize; i++)&#123; if(nums[i] != nums[left_pos]) nums[++left_pos] = nums[i]; &#125; return left_pos+1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 262. 行程和用户]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20262.%C2%A0%E8%A1%8C%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述Trips 表中存所有出租车的行程信息。每段行程有唯一健 Id，Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’)。 1234567891011121314+----+-----------+-----------+---------+--------------------+----------+| Id | Client_Id | Driver_Id | City_Id | Status |Request_at|+----+-----------+-----------+---------+--------------------+----------+| 1 | 1 | 10 | 1 | completed |2013-10-01|| 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01|| 3 | 3 | 12 | 6 | completed |2013-10-01|| 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01|| 5 | 1 | 10 | 1 | completed |2013-10-02|| 6 | 2 | 11 | 6 | completed |2013-10-02|| 7 | 3 | 12 | 6 | completed |2013-10-02|| 8 | 2 | 12 | 12 | completed |2013-10-03|| 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03|+----+-----------+-----------+---------+--------------------+----------+ Users 表存所有用户。每个用户有唯一键 Users_Id。Banned 表示这个用户是否被禁止，Role 则是一个表示（‘client’, ‘driver’, ‘partner’）的枚举类型。 123456789101112+----------+--------+--------+| Users_Id | Banned | Role |+----------+--------+--------+| 1 | No | client || 2 | Yes | client || 3 | No | client || 4 | No | client || 10 | No | driver || 11 | No | driver || 12 | No | driver || 13 | No | driver |+----------+--------+--------+ 写一段 SQL 语句查出 2013年10月1日 至 2013年10月3日 期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率（Cancellation Rate）保留两位小数。 1234567+------------+-------------------+| Day | Cancellation Rate |+------------+-------------------+| 2013-10-01 | 0.33 || 2013-10-02 | 0.00 || 2013-10-03 | 0.50 |+------------+-------------------+ 致谢:非常感谢 @cak1erlizhou 详细的提供了这道题和相应的测试用例。 2、解题思路​ ​ 首先，我们查询出来某一天中不禁止的总的数量，然后然后找出cancel的数量，得到取消率 ​ 然后将取消率取两位小数 1234567# Write your MySQL query statement belowselect Request_at as Day, convert(count(case when status like "cancelled%" then status end)*1.0 / count(*) ,decimal(18,2)) as "Cancellation Rate" from Trips t where Request_at between "2013-10-01" and "2013-10-03"and Client_Id in (select Users_Id from Users where Banned like "No" ) and Driver_Id in (select Users_Id from Users where Banned like "No" )group by Request_at]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 263. 丑数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20263.%20%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1: 123输入: 6输出: true解释: 6 = 2 × 3 示例 2: 123输入: 8输出: true解释: 8 = 2 × 2 × 2 示例 3: 123输入: 14输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明： 1 是丑数。 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 2、解题思路​ 判断是不是不能被2，3，5整除，不能的话，返回false ​ 可以的话，除以2，3，5，继续判断 12345678910111213141516171819202122232425262728293031bool isUgly(int num) &#123; if (num &lt;= 0) &#123; return false; &#125; int result = num; int flag = 0; while (result != 1) &#123; flag = 0; if (result % 2 != 0) &#123; flag++; &#125; else &#123; result /= 2; &#125; if (result % 3 != 0) &#123; flag++; &#125; else &#123; result /= 3; &#125; if (result % 5 != 0) &#123; flag++; &#125; else &#123; result /= 5; &#125; if (flag &gt;= 3) &#123; return false; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 264. 丑数 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20264.%C2%A0%E4%B8%91%E6%95%B0%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例: 123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 2、解题思路​ 一个丑数，肯定是前面的丑数中乘以2，3，5以后，最小的那个 ​ 根据这个思路，我们维护3个数，使用第几个数字乘以2，3，5 ​ 每一次取其中的最小值 ​ 然后用过了以后，下标向后移动 ​ 12[1]0 0 0 12[1 2]1 0 0 12[1 2 3]1 1 0 12[1 2 3 4]2 1 0 1234567891011121314151617181920212223242526class Solution: def nthUglyNumber(self, n): """ :type n: int :rtype: int """ buff = [1] p2 = 0 p3 = 0 p5 = 0 for i in range(n - 1): temp2 = buff[p2] * 2 temp3 = buff[p3] * 3 temp5 = buff[p5] * 5 buff.append(min(temp2, temp3, temp5)) if buff[-1] == temp2: p2 += 1 if buff[-1] == temp3: p3 += 1 if buff[-1] == temp5: p5 += 1 return buff[-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 268.缺失数字]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20268.%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97%20%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1: 12输入: [3,0,1]输出: 2 示例 2: 12输入: [9,6,4,2,3,5,7,0,1]输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 2、解题思路2.1 异或法​ 所有的数进行异或，确实的也进行异或 ​ 用确实的异或每一个数，判断是不是相等，相等返回true 12345678910111213141516171819202122232425int missingNumber(int* nums, int numsSize) &#123; if (!nums) &#123; return -1; &#125; int total = 0; int current = nums[0]; for (int i = 1; i &lt; numsSize + 1; i++) &#123; total ^= i; &#125; for (int i = 1; i &lt; numsSize; i++) &#123; current ^= nums[i]; &#125; for (int i = 0; i &lt; numsSize + 1; i++) &#123; if ((current ^ i) == total) &#123; return i; &#125; &#125; return -1; &#125; 2.2 加和法​ 将缺少的数组加起来，算出所有的数，减去可得 123456789101112int missingNumber(int* nums, int numsSize) &#123; int total = 0; for (int i = 0; i &lt; numsSize; i++) &#123; total += nums[i]; &#125; return (numsSize + 1) * numsSize / 2 - total; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 27. 移除元素]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2027.%C2%A0%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述1234567891011121314151617181920212223242526272829303132333435363738给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例 1:给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 2、解题思路​ 考虑能不能只用一次循环就得到结果呢？也就是$O(n)$的时间复杂度 ​ 实际上是可以的， ​ 如下面的代码实现，设置两个变量，一个存储的是待删除的值的数量，另一个指向当前存储数字的位置 ​ 然后通过位置加删除值的数量的形式，取得新的值，在下一轮中进行判断 ​ 实际的判断数量就与字符串长度一致 例如 原始字符串为：321321 待删除字符为：3 循环变量：i，从0开始（第0即为第一次循环） 循环数量(i) /变量值 字符串 当前位置（cur_pos） 待删除字符的数量(val_nums) 0 221321 0 1 1 211321 1 1 2 213321 2 1 3 212321 2 2 4 212121 3 2 5 4 2 6 第0次 如上所示，一开始，判断当前的位置的字符与待删除的是不是相同，如果是，将vai_nums加一 ​ 然后将 cur_pos + val_nums位置的字符赋值到当前位置上，覆盖掉当前位置的待删除字符 第1次 然后判断当前位置的字符是不是与待删除的字符相同，如果不是，就将当前位置加一 然后将 cur_pos + val_nums位置的字符赋值到当前位置上 ​ 其余的结果依次类推，最终扫描完了种鸽数组，并且将所有的字符移动到到了应该的位置 ​ 12345678910111213141516int removeElement(int* nums, int numsSize, int val) &#123; if (numsSize &lt;= 0) &#123; return 0; &#125; int val_nums = 0; int cur_pos = 0; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[cur_pos] == val) &#123; val_nums++; &#125; else &#123; cur_pos++; &#125; nums[cur_pos] = nums[cur_pos + val_nums]; &#125; return numsSize - val_nums;&#125; 根据调试模式，下面添加了一个条件， 12345678910111213141516int removeElement(int* nums, int numsSize, int val) &#123; if(numsSize &lt;=0)&#123; return 0; &#125; int val_nums = 0; int cur_pos = 0; for (int i = 0; cur_pos+val_nums &lt; numsSize &amp;&amp; i &lt; numsSize ; i++) &#123; if (nums[cur_pos] == val) &#123; val_nums++; &#125; else &#123; cur_pos++; &#125; nums[cur_pos] = nums[cur_pos + val_nums]; &#125; return numsSize - val_nums;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 274. H指数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20274.%C2%A0H%E6%8C%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。 h 指数的定义: “一位有 h 指数的学者，代表他（她）的 N 篇论文中至多有 h 篇论文，分别被引用了至少 h 次，其余的 N - h 篇论文每篇被引用次数不多于 h 次。” 示例: 1234输入: citations = [3,0,6,1,5]输出: 3 解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。 说明: 如果 h 有多种可能的值，h 指数是其中最大的那个。 2、解题思路​ 根据题意，如果将论文引用进行倒排序 如果当前值大于索引值，也就是这个是满足条件的H值，更新结果为i+1 1234[3,0,6,1,5]排序后的结果[6,5,3,1,0]然后开始判断， 1234567891011121314class Solution: def hIndex(self, citations): """ :type citations: List[int] :rtype: int """ citations.sort(reverse=True) result = 0 for i, k in enumerate(citations): if k &gt; i: result = i + 1 return result ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 275. H指数 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20275.%C2%A0H%E6%8C%87%E6%95%B0%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。 h 指数的定义: “一位有 h 指数的学者，代表他（她）的 N 篇论文中至多有 h 篇论文，分别被引用了至少 h 次，其余的 N - h 篇论文每篇被引用次数不多于 h 次。” 示例: 1234输入: citations = [0,1,3,5,6]输出: 3 解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。 由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。 说明: 如果 h 有多有种可能的值 ，h 指数是其中最大的那个。 进阶： 这是 H指数 的延伸题目，本题中的 citations 数组是保证有序的。 你可以优化你的算法到对数时间复杂度吗？ 2、解题思路​ 使用二分查找法 判断中间值是不是符合h指数，或者H指数是否位于此位置之前，如果是，后半部分不必判断，因为后面的h指数肯定是小的 123456789101112131415161718class Solution: def hIndex(self, citations): """ :type citations: List[int] :rtype: int """ n = len(citations) left = 0 right = n - 1 while left &lt;= right: middle = (left + right) // 2 if citations[middle] &gt;= n - middle: right = middle - 1 else: left = middle + 1 return n - left]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 278. 第一个错误的版本]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20278.%C2%A0%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 1234567给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 2、解题思路1234567891011121314151617181920212223242526// Forward declaration of isBadVersion API.bool isBadVersion(int version);int firstBadVersion(int n) &#123; if(n == 1)&#123; return 1; &#125; int left = 1; int right = n; while (left != right-1) &#123; if (isBadVersion(right - (right - left) / 2)) &#123; right = right - (right - left)/2; &#125; else &#123; left = right - (right - left)/2; &#125; &#125; if(isBadVersion(left))&#123; return left; &#125; return right;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 279. 完全平方数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20279.%C2%A0%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2: 123输入: n = 13输出: 2解释: 13 = 4 + 9. 2、解题思路​ 使用dp来做， 如果当前的这个整数直接是平方数，直接返回1即可 如果不是，就将当前数之前的所有的平方数找出来，加上当前数减去平方数对应的索引值，更新结果，找到最小值 举个例子 12345678n = 12[0 1 0 0 1 0 0 0 0 1 0 0 0 ]首先，从1开始，因为是1，跳过到2，2之前的平方数是1，2-1=1，因此，更新一下结果，1+1，2[0 1 2 0 1 0 0 0 0 1 0 0 0 ]然后是33之前的平方数只有1，3-1=2，位置2对应的结果是2，2+1=3，更新为3以此类推 第一个版本，超时了 1234567891011121314151617181920212223242526272829class Solution: def numSquares(self, n): """ :type n: int :rtype: int """ buff = [0] * (n + 1) before_square = -1 for i in range(1, n + 1): temp = i * i if temp &lt;= n: buff[temp] = 1 before_square = temp else: break if before_square == n: return 1 for i in range(1, n + 1): if buff[i] == 0: temp = i for j in range(1, i): if buff[j] == 1: temp = min(temp, buff[j] + buff[i - j]) buff[i] = temp return buff[-1] ​ 为了提升效率，将所有的完全平方数存起来 123456789101112131415161718192021222324252627282930313233343536class Solution: buff = [0] def numSquares(self, n): """ :type n: int :rtype: int """ self.buff += [0] * (n - len(self.buff) + 1) square_buff = [] before_square = -1 for i in range(1, n + 1): temp = i * i if temp &lt;= n: self.buff[temp] = 1 square_buff.append(temp) else: break if before_square == n: return 1 for i in range(1, n + 1): if self.buff[i] == 0: temp = i for j in square_buff: if j &lt; i: temp = min(temp, self.buff[j] + self.buff[i - j]) self.buff[i] = temp return self.buff[n] ​ 因为可能需要需要多次运行，因此，只需要计算新那一部分 看了下别人的算法，发现，原来是数学不好（脸红。。。） ​ 四平方和定理说明每个正整数均可表示为4个整数的平方和。它是费马多边形数定理和华林问题的特例。注意有些整数不可表示为3个整数的平方和，例如7。 ​ 根据3平方和定理，当且仅当 1if and only if n is not of the form &#123;\displaystyle n=4^&#123;a&#125;(8b+7)&#125; n = 4^a(8b + 7) for integers a and b. ​ 也就是说，上面形式的数字，是不能够表示成3平方和的，只能是4平方和 ​ 123456789101112131415161718192021class Solution: def numSquares(self, n): """ :type n: int :rtype: int """ if (int(n ** 0.5)) ** 2 == n: return 1 while (n &amp; 3) == 0: n &gt;&gt;= 2 if (n &amp; 7) == 7: return 4 sqrt_n = int(n ** 0.5) for i in range(1, sqrt_n + 1): temp = n - i * i if (int(temp ** 0.5)) ** 2 == temp: return 2 return 3]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 28. 实现strStr()]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2028.%20%E5%AE%9E%E7%8E%B0strStr()%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述1234567891011121314151617实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。示例 1:输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2示例 2:输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1说明:当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 2、解题思路​ 从前向后一次扫描，首先判断特殊情况 ​ 如果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int strStr(char* haystack, char* needle) &#123; // 当第一个第二个字符串的长度大于第一个的时候，返回-1 if (strlen(haystack) &lt; strlen(needle)) &#123; return -1; &#125; else if ((!*needle)) &#123; return 0; &#125; int result_pos = -1; int count = 0; char *temp = needle; // 判断是不是在匹配的过程中 bool equal = false; // 需要注意的是，这个过程是需要回溯的 // 例如 aaab 和 ab // 当前两个aa不能匹配的时候，我们需要从第二个字符开始匹配,也就是第二个a开始新的匹配 while (haystack[count]) &#123; // 判断字符是不是相等的 if (haystack[count] == *temp) &#123; if (!equal) &#123; result_pos = count; equal = true; &#125; // 如果相等，并且匹配的字符串已经到了结尾，也就是p匹配字符下一个是'\0',表示找到了 if (!*(temp+1)) &#123; // 将temp指向 temp++; break; &#125; else &#123; // 如果还有字符要匹配，将temp 增加 temp++; &#125; &#125; else &#123; // 表示需要重新匹配 // 需要注意，只有前面第一个字符匹配以后，才会初始化这些变量 // 如果本来就不相等，则不需要初始化 if (equal) &#123; temp = needle; count = result_pos + 1; result_pos = -1; equal = false; continue; &#125; &#125; count++; &#125; // 如果匹配的到最后，匹配字符还有没有匹配到的，表示不能匹配 if (*(temp)) &#123; result_pos = -1; &#125; return result_pos;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 283. 移动零]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20283.%C2%A0%E7%A7%BB%E5%8A%A8%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 2、解题思路​ 分两步，第一次将所有的非0的数向前移动到正确的位置， ​ 第二步，将后面的数赋值0 123456789101112131415161718192021222324252627282930313233void moveZeroes(int* nums, int numsSize) &#123;// int zero_count = 0;// int non_zero_pos = 0;// for (int i = 0; i &lt; numsSize; i++) &#123;// if (nums[i] == 0) &#123;// zero_count++;// &#125; else &#123;// nums[non_zero_pos] = nums[i];// non_zero_pos++;// &#125;// &#125;// for (int i = 0; i &lt; zero_count; i++) &#123;// nums[non_zero_pos++] = 0;// &#125; int non_zero_pos = 0; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i]) &#123; nums[non_zero_pos++] = nums[i]; &#125; &#125; for (int i = non_zero_pos; i &lt; numsSize; i++) &#123; nums[non_zero_pos++] = 0; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 284. 顶端迭代器]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20284.%C2%A0%E9%A1%B6%E7%AB%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个迭代器类的接口，接口包含两个方法： next() 和 hasNext()。设计并实现一个支持 peek() 操作的顶端迭代器 – 其本质就是把原本应由 next() 方法返回的元素 peek() 出来。 示例: 12345假设迭代器被初始化为列表 [1,2,3]。调用 next() 返回 1，得到列表中的第一个元素。现在调用 peek() 返回 2，下一个元素。在此之后调用 next() 仍然返回 2。最后一次调用 next() 返回 3，末尾元素。在此之后调用 hasNext() 应该返回 false。 进阶：你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？ 2、解题思路​ 使用一个变量保存下一个值，依据这个值进行判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# Below is the interface for Iterator, which is already defined for you.## class Iterator:# def __init__(self, nums):# """# Initializes an iterator object to the beginning of a list.# :type nums: List[int]# """## def hasNext(self):# """# Returns true if the iteration has more elements.# :rtype: bool# """## def next(self):# """# Returns the next element in the iteration.# :rtype: int# """class PeekingIterator: def __init__(self, iterator): """ Initialize your data structure here. :type iterator: Iterator """ self.iter = iterator self.peek_value = self.iter.next() if self.iter.hasNext() else None def peek(self): """ Returns the next element in the iteration without advancing the iterator. :rtype: int """ return self.peek_value def next(self): """ :rtype: int """ temp = self.peek_value self.peek_value = self.iter.next() if self.iter.hasNext() else None return temp def hasNext(self): """ :rtype: bool """ if self.peek_value != None: return True else: return False # Your PeekingIterator object will be instantiated and called as such:# iter = PeekingIterator(Iterator(nums))# while iter.hasNext():# val = iter.peek() # Get the next element but not advance the iterator.# iter.next() # Should return the same value as [val].]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 287. 寻找重复数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20287.%C2%A0%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 12输入: [1,3,4,2,2]输出: 2 示例 2: 12输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 2、解题思路​ 采用二分法，判断，因为数字只存在1-n，所以找出重复的数，就利用小于等于当前数的数字数量是不是大于当前数，如果是，表示重复的小于当前数，否则表示重复的大于当前数 12345678910111213141516171819202122class Solution: def findDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ left = 0 right = len(nums) - 1 while left &lt;= right: mid = (left + right) // 2 count = 0 for i in nums: if i &lt;= mid: count += 1 if count &gt; mid: right = mid - 1 else: left = mid + 1 return left ​ 还可以用字典，直接扫描一遍，保存数字出现的次数]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 289. 生命游戏]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20289.%C2%A0%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。 示例: 1234567891011121314输入: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0]]输出: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0]] 进阶: 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？ 2、解题思路​ 最简单莫过于直接创建一个一模一样的矩阵，更新状态以后，复制返回 ​ 题目要求原地算法，所以就要想办法，在原地就能够区分状态前与状态后的值 一共两种状态，0，1 状态的变化一共4种情况，0-&gt;0, 0-&gt;1, 1-&gt;0, 1-&gt;1 我们分别用2，3，4，5表示这四种状态，就能够得到更新前后的结果 最后，更新一遍状态，2，4更新为0，3，5更新为1即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution: def gameOfLife(self, board): """ :type board: List[List[int]] :rtype: void Do not return anything, modify board in-place instead. """ row = len(board) if row &lt;= 0: return col = len(board[0]) if col &lt;= 0: return """ 0-&gt;0: 2 0-&gt;1: 3 1-&gt;0: 4 1-&gt;1: 5 """ for i in range(row): for j in range(col): count = 0 start_row = i - 1 start_col = j - 1 for k in range(9): start_row = i - 1 + k // 3 start_col = j - 1 + k % 3 if 0 &lt;= start_row &lt; row and 0 &lt;= start_col &lt; col: if board[start_row][start_col] in [1, 4, 5]: count += 1 if board[i][j] == 1: count -= 1 if count &lt; 2: board[i][j] = 4 elif count &lt;= 3: board[i][j] = 5 else: board[i][j] = 4 else: if count &lt; 3: board[i][j] = 2 elif count == 3: board[i][j] = 3 else: board[i][j] = 2 for i in range(row): for j in range(col): if board[i][j] in [2, 4]: board[i][j] = 0 else: board[i][j] = 1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 29.两数相除]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2029.%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1: 12输入: dividend = 10, divisor = 3输出: 3 示例 2: 12输入: dividend = 7, divisor = -3输出: -2 说明: 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 2、解题思路​ 首先，如果当前数大于除数，我们就循环判断，为了加快进度，使用移位操作，如果大于其二倍，被除数左移一位，每一次左移一位，直到大于除数停止，这时候，我们减去这个值，然后继续判断，直到最后 12345678910111213141516171819202122232425class Solution: def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ num1 = abs(dividend) num2 = abs(divisor) res = 0 while num1 &gt;= num2: temp = num2 count = 1 while (temp &lt;&lt; 1) &lt; num1: temp = temp &lt;&lt; 1 count = count &lt;&lt; 1 res += count num1 -= temp if (dividend &gt; 0) ^ (divisor &gt; 0): return -res if res &gt;= 2 ** 31: return 2 ** 31-1 return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 290. 单词模式]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20290.%20%E5%8D%95%E8%AF%8D%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一种 pattern(模式) 和一个字符串 str ，判断 str 是否遵循相同的模式。 这里的遵循指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应模式。 示例1: 12输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;输出: true 示例 2: 12输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;输出: false 示例 3: 12输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;输出: false 示例 4: 12输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;输出: false 说明:你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 2、解题思路​ 在前面，205题中，做过类似的题目，不过当时是两个字符串进行比较，通过建立映射关系，判断映射关系是不是一致 ​ 在这里，第二个串变得更复杂了，不过基本思路可以这样处理，将第二个串，一个一个映射到某一个字母上去， ​ 使用python很简单就实现了 12345678910111213141516171819202122232425class Solution: def wordPattern(self, pattern, str): """ :type pattern: str :type str: str :rtype: bool """ temp = str.split(" ") if len(pattern) != len(temp): return False p_dict = &#123;&#125; s_dict = &#123;&#125; for i in range(len(pattern)): if not s_dict.get(temp[i]) : s_dict[temp[i]] = pattern[i] elif s_dict[temp[i]] != pattern[i]: return False if not p_dict.get(pattern[i]): p_dict[pattern[i]] = temp[i] elif p_dict[pattern[i]] != temp[i]: return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 292.Nim游戏]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20292.Nim%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 你和你的朋友，两个人一起玩 Nim游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。 示例: 1234输入: 4输出: false 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛； 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。 2、解题思路我们定义Position P：表示当前局面下先手必败 N：表示当前局面下先手必胜 N，P状态的转移满足如下性质： 1.合法操作集合为空的局面为P 2.可以移动到P的局面为N，这个很好理解，以为只要能转换到P局面，那么先手只需要使操作后变成P局面，那么后手就面临了一个必败的状态。 3.所有移动只能到达N的局面为P。无论怎么选取都会留给对手一个必胜状态。 其实知道这个之后应该是可以记忆化搜索或者用sg函数求解的，但是如果范围非常大，就没法做了。 就引进了nim游戏一个很神奇的结论：对于一个局面，当且仅当a[1] xor a[2] xor …xor a[n]=0时，该局面为P局面，即必败局面。 ​ 根据上面的分析，我是先手，那么如果取1，2，3后产生的局面都是必赢局，那当前局面肯定是必输局 ​ ​ 如果1，2，3以后，产生了一个必败局，表示我们肯定赢了 2.1 递归法​ 遗憾的是，递归法太慢了，超出时间限制 1234567891011121314bool canWinNim(int n) &#123; if (n &lt;= 0) &#123; return false; &#125; if (n &lt;= 3 &amp;&amp; n &gt;= 1) &#123; return true; &#125; return !canWinNim(n-1) || !canWinNim(n-2) || !canWinNim(n-3);&#125; 2.2 动态规划​ 如果我们将前面的结果存储起来，然后后面的结果通过前面的来判断，速度会快很多 ​ 不过依然是超过时间限制 1234567891011121314151617181920212223242526bool canWinNim(int n) &#123; if (n == 0) &#123; return false; &#125; if (n &lt;= 3) &#123; return true; &#125; bool *buff = (bool *) malloc(sizeof(bool) * (n + 1)); // 初始化最初的状态 buff[0] = false; buff[1] = true; buff[2] = true; buff[3] = true; for (int i = 4; i &lt;= n; i++) &#123; buff[i] = !buff[i - 1] || !buff[i - 2] || !buff[i - 3]; &#125; bool ans = buff[n]; free(buff); return ans;&#125; 2.3 取余法​ 通过对多个数进行分析，发现结果以4不断地重复 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdlib.h&gt;bool canWinNim(int n) &#123; if (n == 0) &#123; return false; &#125; if (n &lt;= 3) &#123; return true; &#125; bool *buff = (bool *) malloc(sizeof(bool) * (n + 1)); // 初始化最初的状态 buff[0] = false; buff[1] = true; buff[2] = true; buff[3] = true; for (int i = 4; i &lt;= n; i++) &#123; buff[i] = !buff[i - 1] || !buff[i - 2] || !buff[i - 3]; &#125; bool ans = buff[n]; free(buff); return ans;&#125;int main() &#123; for (int i = 0; i &lt; 1000; i++) &#123; printf("num: %d\t result: %s \n", i, canWinNim(i) ? "true" : "false"); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455num: 0 result: false num: 1 result: true num: 2 result: true num: 3 result: true num: 4 result: false num: 5 result: true num: 6 result: true num: 7 result: true num: 8 result: false num: 9 result: true num: 10 result: true num: 11 result: true num: 12 result: false num: 13 result: true num: 14 result: true num: 15 result: true num: 16 result: false num: 17 result: true num: 18 result: true num: 19 result: true num: 20 result: false num: 21 result: true num: 22 result: true num: 23 result: true num: 24 result: false num: 25 result: true num: 26 result: true num: 27 result: true num: 28 result: false num: 29 result: true num: 30 result: true num: 31 result: true num: 32 result: false num: 33 result: true num: 34 result: true num: 35 result: true num: 36 result: false num: 37 result: true num: 38 result: true num: 39 result: true num: 40 result: false num: 41 result: true num: 42 result: true num: 43 result: true num: 44 result: false num: 45 result: true num: 46 result: true num: 47 result: true num: 48 result: false num: 49 result: true num: 50 result: true num: 51 result: true num: 52 result: false num: 53 result: true num: 54 result: true 所以，最终结果如下： 123bool canWinNim(int n) &#123; return n%4;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 299. 猜数字游戏]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20299.%C2%A0%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。 请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。 请注意秘密数字和朋友的猜测数都可能含有重复数字。 示例 1: 12345输入: secret = &quot;1807&quot;, guess = &quot;7810&quot;输出: &quot;1A3B&quot;解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。 示例 2: 12345输入: secret = &quot;1123&quot;, guess = &quot;0111&quot;输出: &quot;1A1B&quot;解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。 说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。 2、解题思路​ 首先，正确理解题意，猜数字的时候，A表示数字正确，位置也正确的数字，B表示数字正确，位置不正确的数字 ​ 一种解题思路，使用字典，如果两个数字不相等，就将当前的值作为字典的键，进行，考虑到重复的存在，记录数量 ​ 1234567891011121314151617181920212223class Solution: def getHint(self, secret, guess): """ :type secret: str :type guess: str :rtype: str """ secret_buff = &#123;&#125; guess_buff = &#123;&#125; A = 0 for i in range(len(secret)): if secret[i] == guess[i]: A += 1 else: secret_buff[secret[i]] = secret_buff.get(secret[i], 0) + 1 guess_buff[guess[i]] = guess_buff.get(guess[i], 0) + 1 B = 0 for num in guess_buff: B += min(guess_buff[num], secret_buff.get(num, 0)) return str(A) + "A" + str(B) + "B"]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3. 无重复字符的最长子串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%203.%C2%A0%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1最长不重复字符子串 1、题目描述123456789Given a string, find the length of the longest substring without repeating characters.Examples:Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3.Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1.Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. ​ 给定一个字符串，找出不含有重复字符的最长子串的长度。 示例： 给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。 给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。 给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 2、解题思路2.1 穷举法​ 双重循环得到所有的子串，然后判断每个是不是不重复的，是的话，更新最大不重复子串的值 2.2 滑动窗口法​ 设计两个指针，i，j指向字符串的下标； ​ （j-i表示不重复子串的值） ​ 从前向后遍历，遇到一个字符，判断这个字符是不是在集合中，如果不在，就将这个字符放到集合中； ​ 如果在，就将第i个字符从集合中删除，i加一，一直删除到前一个a为止 ​ 例如下面的字符串： ​ abcad 初始化，i=0，j=0 j不断递增，当j=3，发现集合中有重复的字符串了，然后开始删除，将a删除，然后i指向1 将a放入集合中 不断地重复操作 2.3 哈希表法​ 在集合中，我们需要不断地删除一个元素，才能够移动i指针，如果能够直接找到新的指针，就能够直接更新i的值，采用key-value的方式，将字符看成key，下标看成value 2.4 缓存表​ 哈希表的实现较为复杂，如果已知字符的个数，字符在ASCII表中的位置，创建一张表，存储当前字符的下标，不断地更新； 12345678910111213int lengthOfLongestSubstring(char* s) &#123; int index[128],i,j; int ans = 0; for (i=0;i&lt;128;i++)&#123; index[i] =0 ; &#125; for(i=0,j=0;s[j];j++)&#123; i = i &gt; index[s[j]]? i : index[s[j]]; ans = ans &gt; j-i+1 ? ans : j-i+1; index[s[j]] = j + 1; &#125; return ans;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 300. 最长上升子序列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20300.%C2%A0%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 2、解题思路2.1 动态规划​ 使用动态规划，建立一个数组，当前位置上的数表示从前向后扫描的过程中，最大的子数组值 12345678910111213141516171819class Solution: def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ if not nums: return 0 dp = [1] * len(nums) res = 1 for i in range(len(nums)): for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], 1 + dp[j]) res = max(res, dp[i]) return res 2.2 数组法​ 我们假设这样的问题，假如我们挑出来最长的上升子序列 如果这个元素小于数组首部元素，将首部元素替换掉 如果该元素大于数组尾部元素，添加到尾部 如果遍历到的新元素比ends数组首元素大，比尾元素小时，此时用二分查找法找到第一个不小于此新元素的位置，覆盖掉位置的原来的数字， 1234567891011121314151617181920212223242526272829class Solution: def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ if not nums: return 0 buff = [nums[0]] for i in range(1, len(nums)): if nums[i] &lt; buff[0]: buff[0] = nums[i] elif nums[i] &gt; buff[-1]: buff.append(nums[i]) else: left = 0 right = len(buff) - 1 while left &lt; right: mid = (left + right) // 2 if nums[i] &gt; buff[mid]: left = mid + 1 else: right = mid buff[right] = nums[i] return len(buff) ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 303. 区域和检索 - 数组不可变]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20303.%C2%A0%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例： 12345给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明: 你可以假设数组不可变。 会多次调用 sumRange 方法 2、解题思路​ 使用一个缓冲数组，存放从第一个到当前所以的和 ​ 如果想要求一个范围，就用当前的减去对应的索引的值，加上前面索引处的值即可 123456789101112131415161718192021222324252627282930313233343536typedef struct &#123; int *nums; int *buff;&#125; NumArray;NumArray *numArrayCreate(int *nums, int numsSize) &#123; NumArray *num = (NumArray *) malloc(sizeof(NumArray)); num-&gt;nums = nums; num-&gt;buff = (int *) malloc(sizeof(int) * numsSize); int sum = 0; for (int i = 0; i &lt; numsSize; i++) &#123; sum += nums[i]; num-&gt;buff[i] = sum; &#125; return num;&#125;int numArraySumRange(NumArray *obj, int i, int j) &#123; return obj-&gt;buff[j] - obj-&gt;buff[i] + obj-&gt;nums[i];&#125;void numArrayFree(NumArray *obj) &#123; if (obj) &#123; if (obj-&gt;buff) &#123; free(obj-&gt;buff); &#125; free(obj); &#125;&#125;/** * Your NumArray struct will be instantiated and called as such: * struct NumArray* obj = numArrayCreate(nums, numsSize); * int param_1 = numArraySumRange(obj, i, j); * numArrayFree(obj); */ ​ 略为改进 1234567891011121314151617181920212223242526272829303132333435typedef struct &#123; int *nums; int *buff;&#125; NumArray;NumArray *numArrayCreate(int *nums, int numsSize) &#123; NumArray *num = (NumArray *) malloc(sizeof(NumArray)); num-&gt;nums = nums; num-&gt;buff = (int *) malloc(sizeof(int) * numsSize); int sum = 0; for (int i = 0; i &lt; numsSize; i++) &#123; sum += nums[i]; num-&gt;buff[i] = sum; &#125; return num;&#125;int numArraySumRange(NumArray *obj, int i, int j) &#123; return obj-&gt;buff[j] - obj-&gt;buff[i] + obj-&gt;nums[i];&#125;void numArrayFree(NumArray *obj) &#123; if (obj) &#123; if (obj-&gt;buff) &#123; free(obj-&gt;buff); &#125; free(obj); &#125;&#125;/** * Your NumArray struct will be instantiated and called as such: * struct NumArray* obj = numArrayCreate(nums, numsSize); * int param_1 = numArraySumRange(obj, i, j); * numArrayFree(obj); */]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 304. 二维区域和检索 - 矩阵不可变]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20304.%C2%A0%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。 上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。 示例: 1234567891011给定 matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 说明: 你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2。 2、解题思路​ 使用动态规划，每一个节点都是左上角节点到当前节点的和， dp[i][j] = dp[i-1][j]+dp[i][j-1] - dp[i-1][j-1] 上面是状态转换函数，由此，我们可以方便的求解出从左上角节点到当前节点 12345678910111213141516171819202122232425262728293031323334353637383940class NumMatrix: def __init__(self, matrix): """ :type matrix: List[List[int]] """ self.matrix = matrix self.row = len(matrix) if self.row == 0: return self.col = len(matrix[0]) if self.col == 0: return self.dp = [[0] * (self.col + 1) for _ in range(self.row + 1)] for i in range(self.row): for j in range(self.col): self.dp[i + 1][j + 1] = self.dp[i][j + 1] + self.dp[i + 1][j] - self.dp[i][j] + self.matrix[i][j] # print(self.matrix) # print(self.dp) def sumRegion(self, row1, col1, row2, col2): """ :type row1: int :type col1: int :type row2: int :type col2: int :rtype: int """ if self.row == 0 or self.col == 0: return 0 return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - self.dp[row2 + 1][col1] + self.dp[row1][col1]# Your NumMatrix object will be instantiated and called as such:# obj = NumMatrix(matrix)# param_1 = obj.sumRegion(row1,col1,row2,col2)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 306. 累加数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20306.%C2%A0%E7%B4%AF%E5%8A%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述累加数是一个字符串，组成它的数字可以形成累加序列。 一个有效的累加序列必须至少包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。 给定一个只包含数字 &#39;0&#39;-&#39;9&#39; 的字符串，编写一个算法来判断给定输入是否是累加数。 说明: 累加序列里的数不会以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。 示例 1: 123输入: &quot;112358&quot;输出: true 解释: 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8 示例 2: 123输入: &quot;199100199&quot;输出: true 解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199 进阶:你如何处理一个溢出的过大的整数输入? 2、解题思路​ 输入的是字符串，那么就不能使用常规的计算，不能够先将字符串变成数字，然后相加，需要使用字符串加法来做 ​ 当然，如果是很短的字符串，也没必要，不过，使用字符串加法，可以防止溢出问题 ​ 然后关键就在于确定前两个数，只要确定了前两个数，整个序列就确定下来了 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution: def isAdditiveNumber(self, num): """ :type num: str :rtype: bool """ length = len(num) if length &lt;= 2: return False for i in range(1, length // 2 + 1): s1 = num[:i] j = 1 while (length - i - j) &gt;= max(i, j): s2 = num[i:i + j] if len(s2) &gt; 1 and s2[0] == '0': j += 1 continue if self.judgePlusString(s1, s2, num): return True j += 1 return False def judgePlusString(self, s1, s2, s3): length1 = len(s1) length2 = len(s2) if (length1 &gt; 1 and s1[0] == '0') or (length2 &gt; 1 and s2[0] == '0'): return False res = "" carry = 0 pre_part = min(length1, length2) for i in range(1, max(length1, length2) + 1): if i &lt;= length1 and i &lt;= length2: digit = ord(s1[-i]) + ord(s2[-i]) - 96 + carry elif i &lt;= length1: digit = ord(s1[-i]) - 48 + carry else: digit = ord(s2[-i]) - 48 + carry carry = digit // 10 res = str(digit % 10) + res if carry: res = str(carry) + res temp = s1 + s2 + res if temp == s3: return True elif temp == s3[:len(temp)]: return self.judgePlusString(s2, res, s3[len(s1):]) else: return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 307. 区域和检索 - 数组可修改]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20307.%C2%A0%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。 示例: 12345Given nums = [1, 3, 5]sumRange(0, 2) -&gt; 9update(1, 2)sumRange(0, 2) -&gt; 8 说明: 数组仅可以在 update 函数下进行修改。 你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。 2、解题思路​ 先来理清一下思路，假设不能修改，我们会怎么做呢？ ​ 建立一个缓冲数组，然后计算从第一个到当前值的和值，当我们要得到对应段的时候，做一下差值就可以了 树状数组一般适用于三类问题： 1，修改一个点求一个区间 2，修改一个区间求一个点 3，求逆序列对 使用Binary Indexed Tree来做，更加简单 利用的是数的性质，参见后文的blog 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class NumArray: def __init__(self, nums): """ :type nums: List[int] """ self.nums = nums self.buff = [0] * (len(nums) + 1) for i in range(1, len(nums) + 1): temp = nums[i - 1] while i &lt; (len(nums) + 1): self.buff[i] += temp i += i &amp; (-i) def update(self, i, val): """ :type i: int :type val: int :rtype: void """ index = i + 1 diff = val - self.nums[i] while index &lt; len(self.buff): self.buff[index] += diff index += index &amp; (-index) self.nums[i] = val def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ return self.getSum(j + 1) - self.getSum(i) def getSum(self, index): res = 0 while index &gt; 0: res += self.buff[index] index -= index &amp; (-index) return res# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# obj.update(i,val)# param_2 = obj.sumRange(i,j) ​ 代码超过了100%的，哈哈 ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 309. 最佳买卖股票时机含冷冻期]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20309.%C2%A0%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 2、解题思路​ 这道题虽然知道是用动态规划，不过状态转换方程还是不太好想 首先，状态分成两类，每种状态根据可能的条件，又有几种状态 持有股票 卖掉股票 继续持有 未持有股票 买股票（过了冷冻期） 继续未持有 由此，我们得到两个状态转换方程 12sdp[i] = max( bdp[i-1] + price , sdp[i-1] )bdp[i] = max( sdp[i-2] - price , bdp[i-1] ) 123456789101112131415161718192021222324class Solution: def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ length = len(prices) if length &lt;= 1: return 0 sdp = [0] * length bdp = [0] * length bdp[0] = -prices[0] for i in range(1, length): sdp[i] = max(bdp[i - 1] + prices[i], sdp[i - 1]) if i &gt;= 2: bdp[i] = max(sdp[i - 2] - prices[i], bdp[i - 1]) else: bdp[i] = max(-prices[i], bdp[i - 1]) return sdp[-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 31. 下一个排列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2031.%C2%A0%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 2、解题思路​ 实际上这个题目是有规律的，其想要求得就是全排列的时候，按照字典序输出 ​ 例如，123的全排列，按照字典序 123 132 213 231 312 321 我们发现，实际上，规律是，从右面向左寻找，找出第一个非升序的数字，例如，123，第一个不是升序的，就是2，直接判断3，2，发现2比3小，是降序的，于是，就将2与后面的比他大的那个数交换，得到132 如果是 1243，该如何寻找呢 首先，判断，3，4是升序，然后，2，4降序，找到了2，于是，将2与3进行交换，然后将2后面的数重新排列，得到1324，这就是下一个排列 从右向前寻找，第一个非升序的数字，然后将这个数字与后面第一个大于他的数字交换 然后将这个数字后面的数字重新按照顺序排列即可 12345678910111213141516171819202122232425class Solution: def nextPermutation(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ if len(nums) &lt;= 1: return index = 0 for i in range(len(nums) - 1, 0, -1): if nums[i] &gt; nums[i - 1]: index = i - 1 break swap_index = len(nums) - 1 # 寻找第一个比他大的数 for i in range(len(nums) - 1, index, -1): if nums[i] &gt; nums[index]: swap_index = i break nums[index], nums[swap_index] = nums[swap_index], nums[index] nums[index + 1:] = sorted(nums[index + 1:])]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 310. 最小高度树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20310.%C2%A0%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。 格式 该图包含 n 个节点，标记为 0 到 n - 1。给定数字 n 和一个无向边 edges 列表（每一个边都是一对标签）。 你可以假设没有重复的边会出现在 edges 中。由于所有的边都是无向边， [0, 1]和 [1, 0] 是相同的，因此不会同时出现在 edges 里。 示例 1: 123456789输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]] 0 | 1 / \ 2 3 输出: [1] 示例 2: 1234567891011输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \ | / 3 | 4 | 5 输出: [3, 4] 说明: 根据树的定义，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。 树的高度是指根节点和叶子节点之间最长向下路径上边的数量。 2、解题思路​ 因为这个题目是树，实际上也就是无向图，每个节点都是有度的，叶子节点的度是1，非叶子节点的度是2 ​ 然后我们将所有节点的度找出来，首先将所有度为1的节点，放到队列中，然后与这个节点有边相连接的节点，度会减少1 ​ 返回的结果，就是这些减少了一个度以后，度变成1的节点 ​ 实际上是一个广度优先搜索，从最底层开始，也就是叶子节点 ​ 一开始把题意理解错了，一位是找到叶子节点的子节点，实际上，是整棵树的根节点 12345670| 1|2|3 如果是上面的情况，我们想要得到度最小的树，就是以1，2为根节点的树，返回这两个节点 设计两个list，一个保存节点的度，一个保存与节点相连接的节点 使用层次遍历，用一个缓冲 123456789101112131415161718192021222324252627282930313233343536373839404142434445import queueclass Solution: def findMinHeightTrees(self, n, edges): """ :type n: int :type edges: List[List[int]] :rtype: List[int] """ if n == 1: return [0] if len(edges) == 0: return [i for i in range(n)] degree = [0] * n pre_node = [[] for _ in range(n)] q = queue.deque() for i in edges: pre_node[i[0]] += [i[1]] pre_node[i[1]] += [i[0]] degree[i[0]] += 1 degree[i[1]] += 1 for i, v in enumerate(degree): if v == 1: q.append(i) degree[i] = 0 result = [] while q: size = len(q) result = list(q) for i in range(size): node = q.popleft() for pre in pre_node[node]: degree[pre] -= 1 if degree[pre] == 1: q.append(pre) degree[node] = 0 return result ​ 嘿嘿嘿，战胜100%。。。。。。 ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 313. 超级丑数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20313.%C2%A0%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一段程序来查找第 n 个超级丑数。 超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。 示例: 123输入: n = 12, primes = [2,7,13,19]输出: 32 解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。 说明: 1 是任何给定 primes 的超级丑数。 给定 primes 中的数字以升序排列。 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。 第 n 个超级丑数确保在 32 位有符整数范围内。 2、解题思路​ 之前做的丑数题目， 2，3，5作为质因子，使用的是下标，然后不断地向前推进，每一次只需要找出最小的值，然后更新对应的下标即可 ​ ​ 采用一个思路，假如说，我们将现在已经有的数，乘以所有的质因子，然后排序，每次取出最小值，也能得到 ​ 使用一个堆，将这些数据都放在一起 1234567891011121314151617181920class Solution: def nthSuperUglyNumber(self, n, primes): """ :type n: int :type primes: List[int] :rtype: int """ uglies = [1] def gen(prime): for ugly in uglies: yield ugly * prime merged = heapq.merge(*map(gen, primes)) while len(uglies) &lt; n: ugly = next(merged) if ugly != uglies[-1]: uglies.append(ugly) return uglies[-1] ​ 下面的思路是之前做丑数的思路： 12345678910111213141516171819202122232425262728293031323334353637class Solution: def nthSuperUglyNumber(self, n, primes): """ :type n: int :type primes: List[int] :rtype: int """ uglies = [1] pos = [0] * len(primes) for i in range(1, n): first = True temp = 0 change_pos = 0 index = 0 while index &lt; len(pos): value = uglies[pos[index]] * primes[index] if value &lt;= uglies[-1]: pos[index] += 1 else: if first: first = False temp = value change_pos = index elif value &lt; temp: change_pos = index temp = value index += 1 uglies.append(temp) pos[change_pos] += 1 return uglies[-1] ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 318. 最大单词长度乘积]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20318.%C2%A0%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。 示例 1: 123输入: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]输出: 16 解释: 这两个单词为 &quot;abcw&quot;, &quot;xtfn&quot;。 示例 2: 123输入: [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]输出: 4 解释: 这两个单词为 &quot;ab&quot;, &quot;cd&quot;。 示例 3: 123输入: [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]输出: 0 解释: 不存在这样的两个单词。 ​ 2、解题思路​ 首先，判断当前要判断的字符串的长度之积是不是大于结果，如果是，继续判断有没有交集，如果没有，更新结果 ​ 这个题目最麻烦的一点就是判断两个字符串有没有交集，利用哈希来做是很快的 ​ 我们对每一个字符串做哈希，因为只有26个英文小写字母，因此，采用整数位运算的形式，如果出现a，表示第0位置一，如果出现b，表示第1位置一 ​ 比较两个字符串，就是将哈希值进行与，如果得到0，表示没有相同的字符串，如果不是0 ，表示得到了相同的字符串 ​ 123456789101112131415161718192021222324252627class Solution: def maxProduct(self, words): """ :type words: List[str] :rtype: int """ res = 0 hash_word = [self.hash_string(s) for s in words] for i in range(len(words)): for j in range(i + 1, len(words)): temp = len(words[i]) * len(words[j]) if temp &gt; res: if hash_word[i] &amp; hash_word[j] == 0: res = temp return res def hash_string(self, s): res = 0 for i in s: res |= (1 &lt;&lt; (ord(i) - 97)) return res ​ 改进一下，实际上，我们可以使用他的哈希值，作为字段的键，字符串长度作为值，判断如果键的与为0，更新结果 ​ 并且需要注意的就是，如果两个字符串有相同的哈希，那么我们取更长的长度作为它的值，这样才能找到最大的乘积 123456789101112131415161718192021222324252627282930313233class Solution: def maxProduct(self, words): """ :type words: List[str] :rtype: int """ res = 0 hash_dict = &#123;&#125; for word in words: hash_value = self.hash_string(word) if hash_dict.get(hash_value) is None: hash_dict[hash_value] = len(word) else: if hash_dict[hash_value] &lt; len(word): hash_dict[hash_value] = len(word) for i, j in itertools.combinations(hash_dict.keys(), 2): if not (i &amp; j): res = max(res, hash_dict[i] * hash_dict[j]) return res def hash_string(self, s): res = 0 for i in s: res |= (1 &lt;&lt; (ord(i) - 97)) return res ​ 这次提升了很多，战胜了90.32%。。 ​ 因为减少了很多组合数，所以执行速度变快了]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 319. 灯泡开关]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20319.%C2%A0%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。 示例: 123456789输入: 3输出: 1 解释: 初始时, 灯泡状态 [关闭, 关闭, 关闭].第一轮后, 灯泡状态 [开启, 开启, 开启].第二轮后, 灯泡状态 [开启, 关闭, 开启].第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 你应该返回 1，因为只有一个灯泡还亮着。 2、解题思路​ 首先，我们不能进行开关的模拟，这样时间复杂度太高了，因此，肯定是要分析内部的规律 假设一共10个灯泡 首先分析第一个灯泡，因为第一个灯泡肯定只有在第一轮才会切换状态，并且仅仅切换一次，因此，最终状态是亮的 然后是第二个灯泡，会在第一轮，还有第二轮切换，因此，最终状态是灭的 第三个灯泡则会在1，3次切换状态，因此最终状态是灭的 第4个灯泡在1，2，4轮切换状态，最终状态是亮的 第5个灯泡则会在1，5切换状态，最终是灭的 因此，如果直接判断某个灯泡是不是亮的，直接判断他的因子的个数，如果是奇数个，就是亮的，如果是偶数个，就是灭的 那么，从1到10，因子个数分别是： 1 2 2 3 2 4 2 4 3 4 最终状态： 1 0 0 1 0 0 0 0 1 0 而且，观察可得，对每一个数，其根号的整数，正好是最终所得的结果 为何出现这样的结果呢? 我们发现，对每一个灯泡来说，如果这个灯泡的平方仍然小于n，那么他的因子就是奇数，也就是亮的 12345678class Solution: def bulbSwitch(self, n): """ :type n: int :rtype: int """ return int(math.sqrt(n))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 322. 零钱兑换]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20322.%C2%A0%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 12输入: coins = [2], amount = 3输出: -1 说明:你可以认为每种硬币的数量是无限的。 2、解题思路​ 这道题可以使用动态规划来做 dp[i] = min(dp[i-1],dp[i-2],dp[i-5])+1 ​ 虽然这样可以做，但是会超出时间限制。。。 换个思路，我们直接通过已经有的硬币数，直接生成对应钱数最小的硬币数 建立一个dp数组 将硬币对应的下标设置为1 然后从头到尾开始计算，遇到一个不是-1的数，就用这个数加上硬币，对应的下标设置为当前硬币数加1 最后返回最后一个 举个例子 12345678coins = [1, 2, 5], amount = 11dp = [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 ]然后，对应的，1，2，5的位置，这是为1dp = [-1 1 1 -1 -1 1 -1 -1 -1 -1 -1 -1 -1 ]然后从前向后进行扫描，第一个不是-1的数，下标为2，然后 判断2+1 = 3，下标为3的如果不为是-1，就更新为2以此类推 123456789101112131415161718class Solution: def coinChange(self, coins, amount): """ :type coins: List[int] :type amount: int :rtype: int """ buff = [amount + 1] * (amount + 1) buff[0] = 0 for i in range(1, amount + 1): for j in coins: if i &gt;= j: buff[i] = min(buff[i], buff[i - j] + 1) if buff[-1] == amount + 1: return -1 return buff[-1] ​ 好几个版本，一直超出时间限制 ​ ​ 好伤心，还是同样的思路，直接用c语言重新写了一遍，就通过了 12345678910111213141516171819int coinChange(int* coins, int coinsSize, int amount) &#123; int *buff = (int *) malloc(sizeof(int) * (amount + 1)); for (int i = 1; i &lt;= amount; i++) &#123; buff[i] = amount + 1; &#125; buff[0] = 0; for (int i = 1; i &lt; amount + 1; i++) &#123; for (int j = 0; j &lt; coinsSize; j++) &#123; if (i &gt;= coins[j]) &#123; buff[i] = buff[i] &gt; (buff[i - coins[j]] + 1) ? (buff[i - coins[j]] + 1) : buff[i]; &#125; &#125; &#125; if (buff[amount] == (amount + 1)) &#123; return -1; &#125; return buff[amount];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 324. 摆动排序 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20324.%C2%A0%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个无序的数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]... 的顺序。 示例 1: 12输入: nums = [1, 5, 1, 1, 6, 4]输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6] 示例 2: 12输入: nums = [1, 3, 2, 2, 3, 1]输出: 一个可能的答案是 [2, 3, 1, 3, 1, 2] 说明:你可以假设所有输入都会得到有效的结果。 进阶:你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？ 2、解题思路​ 先排序，然后将数据进行交叉 举个例子， 12345678910[1, 5, 1, 1, 6, 4]排序后：[1, 1, 1, 4, 5, 6]首先，将前面一半取出来[1, 1, 1]取出后面一半[4, 5, 6]交错摆放即可1 1 1 4 5 6 不过，上面的情况，遇到下面的就会出现问题 123[4, 5, 5, 6]4 5 5 6 如果遇到相等的情况，就有问题了 因此，我们将它们反过来输出 125 4 6 5 这样就得到结果了 123456789class Solution: def wiggleSort(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ nums.sort() half = math.ceil(len(nums) / 2) nums[::2], nums[1::2] = nums[half - 1::-1], nums[len(nums) - 1:half - 1:-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 326. 3的幂]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20326.%C2%A03%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数，写一个函数来判断它是否是 3 的幂次方。 示例 1: 12输入: 27输出: true 示例 2: 12输入: 0输出: false 示例 3: 12输入: 9输出: true 示例 4: 12输入: 45输出: false 进阶：你能不使用循环或者递归来完成本题吗？ 2、解题思路​ 假设一个数Num是3的幂，那么所有Num的约数都是3的幂，如果一个数n小于Num且是3的幂，那么这个数n一定是Num的约数。 ​ 首先求解整数中，最大的3的幂是多少$$log_{3}Max$$​ 上面的式子，直接求是没办法的，没有直接用3为底，所以是用换底公式$$\frac{logMax}{log3}$$ ## 1234567891011bool isPowerOfThree(int n) &#123; if(n&lt;=0)&#123; return false; &#125; int max = pow(3, (int) (log(INT32_MAX) / log(3))); return !(max % n); &#125; ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 328. 奇偶链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20328.%C2%A0%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例 2: 12输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 2、解题思路​ 这个是比较简单的，直接设置两个指针，然后第一个指向奇数的，第二个指向偶数的，扫描一遍，连接起来即可 123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def oddEvenList(self, head): """ :type head: ListNode :rtype: ListNode """ odd = ListNode(1) odd_pos = odd even = ListNode(2) even_pos = even temp = head count = 1 while temp: if count % 2 == 0: even_pos.next = temp even_pos = even_pos.next else: odd_pos.next = temp odd_pos = odd_pos.next temp = temp.next count += 1 even_pos.next = None odd_pos.next = even.next return odd.next]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 33. 搜索旋转排序数组]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2033.%C2%A0%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2: 12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 2、解题思路​ 同样是使用二分法，不过在更新左右范围的时候有所不同 ​ 如果中间值大于最左面的那个值，表示中间值目前位与左面递增序列中，这时候，我们判断一下中间值是不是大于target，并且左面的值小于等于target，这样就转化了，变成在左面的范围中target ​ 如果中间值小于左面的值，中间值肯定是在右面的递增序列上面，同样的道理，这时候，我们就需要判断target是不是在右面的这段递增序列上，然后更新left，right 12345678910111213141516171819202122232425262728293031323334353637class Solution: def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ result_index = -1 left = 0 right = len(nums) - 1 middle = (left + right) // 2 while left &lt;= right: if nums[middle] == target: result_index = middle break # 如果middle 位与左面的递增数组上面 if nums[middle] &gt;= nums[left]: if nums[left] &lt;= target and target &lt; nums[middle]: right = middle - 1 else: left = middle + 1 else: # 现在middle位与右面的递增数组上面 if nums[right] &gt;= target and target &gt; nums[middle]: left = middle + 1 else: right = middle - 1 middle = (left + right) // 2 return result_index]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 331. 验证二叉树的前序序列化]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20331.%C2%A0%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。 1234567 _9_ / \ 3 2 / \ / \ 4 1 # 6/ \ / \ / \# # # # # # 例如，上面的二叉树可以被序列化为字符串 &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 &#39;#&#39; 。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 &quot;1,,3&quot; 。 示例 1: 12输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;输出: true 示例 2: 12输入: &quot;1,#&quot;输出: false 示例 3: 12输入: &quot;9,#,#,1&quot;输出: false 2、解题思路​ 根据题目，首先，#号的数量肯定是数字数目加一 ​ 从上到下，进来的看做入，下方的看做出，整棵树入和出应该是相同的 ​ 换一个角度来说，对一个数字节点来讲，他可以匹配两个”#”，也可以匹配一个数字一个”#” ​ 因此，前序遍历的过程中，进来的始终要大于出去的，最后一个节点也肯定是”#” ​ 初始化一个计数器，如果当前节点是数字，表示下方能够匹配2个”#”,但是他也占用了一个”#”的名额，所以，增加一个”#”计数 假如是一颗空树，默认是需要一个”#”，也就是说，我们在根节点前方假设是空的，放了一个# 然后根据上面的规则，开始判断 12345678910111213141516171819202122class Solution: def isValidSerialization(self, preorder): """ :type preorder: str :rtype: bool """ temp = preorder.split(',') count = 1 for node in temp: count -= 1 if count &lt; 0: return False if node != "#": count += 2 if count == 0: return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 332. 重新安排行程]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20332.%C2%A0%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 出发。 说明: 如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前 所有的机场都用三个大写字母表示（机场代码）。 假定所有机票至少存在一种合理的行程 示例 1：tickets = [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]返回[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;] 示例 2：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]返回[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]。但是它自然排序更大更靠后。 贡献：特别感谢 @dietpepsi 提供了该问题和测试用例 2、解题思路​ 使用深度优先搜索，或者更简单的，我们直接对所有的票做哈希，然后每张票后面都跟着至少一个目的地，如果有多个目的地的，我们就进行排序，然后取出第一个出来 123456789101112131415161718192021222324252627282930class Solution: def findItinerary(self, tickets): """ :type tickets: List[List[str]] :rtype: List[str] """ tickets_buff = &#123;&#125; for ticket in tickets: if ticket[0] not in tickets_buff: tickets_buff[ticket[0]] = [ticket[1]] else: tickets_buff[ticket[0]].append(ticket[1]) for ticket in tickets_buff: tickets_buff[ticket].sort() res = ['JFK'] end = [] while tickets_buff: if res[-1] not in tickets_buff: end.append(res.pop()) continue fr, to = res[-1], tickets_buff[res[-1]].pop(0) res.append(to) if len(tickets_buff[fr]) == 0: tickets_buff.pop(fr) if end: res.extend(end[::-1]) return res ​ ​ 这道题实际上是深度优先搜索的题目，上面则是将走不通的路径终点进行缓存了 ​ ​ 直接使用深度优先搜索，倒序输出 12345678910111213141516171819class Solution: def findItinerary(self, tickets): """ :type tickets: List[List[str]] :rtype: List[str] """ tickets_dict = collections.defaultdict(list) for a, b in sorted(tickets)[::-1]: tickets_dict[a] += [b] res = [] def dfs(current): while tickets_dict[current]: dfs(tickets_dict[current].pop()) res.append(current) dfs('JFK') return res[::-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 334. 递增的三元子序列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20334.%C2%A0%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。 数学表达式如下: 如果存在这样的 i, j, k, 且满足 0 ≤ i &lt; j &lt; k ≤ n-1，使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。 示例 1: 12输入: [1,2,3,4,5]输出: true 示例 2: 12输入: [5,4,3,2,1]输出: false 2、解题思路​ 设计两个数，m1，m2，初始化为整数最大值 如果当前数小于等于m1，更新m1 如果大于m1，小于等于m2，更新m2 如果大于m2，返回真 123456789101112131415161718192021class Solution: def increasingTriplet(self, nums): """ :type nums: List[int] :rtype: bool """ if len(nums) &lt; 3: return False m1 = 2 ** 32 - 1 m2 = 2 ** 32 - 1 for i in nums: if m1 &gt;= i: m1 = i elif m2 &gt;= i: m2 = i else: return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 337. 打家劫舍 III]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20337.%C2%A0%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述小偷又发现一个新的可行窃的地点。 这个地区只有一个入口，称为“根”。 除了根部之外，每栋房子有且只有一个父房子。 一番侦察之后，聪明的小偷意识到“这个地方的所有房屋形成了一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 在不触动警报的情况下，计算小偷一晚能盗取的最高金额。 示例 1: 12345 3 / \2 3 \ \ 3 1 能盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2: 12345 3 / \ 4 5 / \ \ 1 3 1 能盗取的最高金额 = 4 + 5 = 9. 致谢:特别感谢 @dietpepsi 添加此题并创建所有测试用例。 2、解题思路​ 使用深度优先搜索，我们针对每一层，都需要这样判断 偷当前层，那么就是当前层的值，加上左子树的 ​ 下面的这个超时了，换个方式重新写 123456789101112131415161718192021class Solution: def rob(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 sum0 = root.val sum1 = self.rob(root.left) + self.rob(root.right) if root.left: sum0 += self.rob(root.left.left) + self.rob(root.left.right) if root.right: sum0 += self.rob(root.right.left) + self.rob(root.right.right) return max(sum0, sum1) ​ ​ 嘿嘿嘿，使用大招，用C写一遍 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */int rob(struct TreeNode* root) &#123; if (root == NULL) &#123; return 0; &#125; int sum0 = root-&gt;val; int sum1 = 0; sum1 += rob(root-&gt;left) + rob(root-&gt;right); if (root-&gt;left != NULL) &#123; sum0 += rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right); &#125; if (root-&gt;right != NULL) &#123; sum0 += rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right); &#125; return sum0 &gt; sum1 ? sum0 : sum1;&#125; ​ 通过了，不过耗费时间太长了，学习一下别人的思路 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */int dfs(struct TreeNode *root, int *l, int *r) &#123; if (!root) &#123; return 0; &#125; int ll = 0; int lr = 0; int rl = 0; int rr = 0; *l = dfs(root-&gt;left, &amp;ll, &amp;lr); *r = dfs(root-&gt;right, &amp;rl, &amp;rr); int sum0 = root-&gt;val + ll + lr + rl + rr; int sum1 = *l + *r; return sum0 &gt; sum1 ? sum0 : sum1;&#125;int rob(struct TreeNode *root) &#123; if (!root) &#123; return 0; &#125; int l = 0; int r = 0; return dfs(root, &amp;l, &amp;r);&#125; ​ 思路差不多，分析一下区别在哪里，主要是减少了判断的情况 基本思路就是，对当前节点而言，当前节点的值，加上下下层的值 然后与下一层进行判断 这与直接的打家劫舍那道题就差不多了]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 338. Bit位计数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20338.%C2%A0Bit%E4%BD%8D%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非负整数 num。 对于范围 0 ≤ i ≤ num 中的每个数字 i ，计算其二进制数中的1的数目并将它们作为数组返回。 示例：比如给定 num = 5 ，应该返回 [0,1,1,2,1,2]. 进阶： 给出时间复杂度为O(n * sizeof(integer)) 的解答非常容易。 但是你可以在线性时间O(n)内用一次遍历做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？ 在c ++或任何其他语言中不使用任何内置函数（如c++里的 __builtin_popcount）来执行此操作。 致谢：特别感谢 @syedee 添加此问题及所有测试用例。 2、解题思路​ 实际上，这个是有规律的，规律如下 首先，我们得到0-7的bit数 10 1 1 2 1 2 2 3 然后求解8-15的比特数 11 2 2 3 2 3 3 4 发现刚好是前面的0-7的比特数加一 现在结果中应该是这样的 10 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 于是，我们继续求解16-31的比特数 11 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5 看出来了吧，就是前面的数据加一就能得到 其实从0开始也是这样的 1234501====0 11 2 12345678910111213141516class Solution: def countBits(self, num): """ :type num: int :rtype: List[int] """ result = [0] count = 0 cur_length = 1 for i in range(num): if count &gt;= cur_length: count = 0 cur_length = len(result) result.append(result[count] + 1) count += 1 return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 34. 搜索范围]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2034.%C2%A0%E6%90%9C%E7%B4%A2%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 2、解题思路​ 首先，我么能使用二分法，找到这个元素在数组中的位置，如果找不到，就返回[-1,-1] ​ 如果找得到，表示继续使用二分法，找出最小，和最大的下标 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution: def searchRange(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ left = 0 right = len(nums) - 1 middle = (left + right) // 2 result = [-1, -1] while left &lt;= right: if nums[middle] == target: result[0] = self.findMinIndex(nums, middle, target) result[1] = self.findMaxIndex(nums, middle, target) if nums[middle] &lt; target: left = middle + 1 else: right = middle - 1 middle = (left + right) // 2 return result def findMinIndex(self, nums, current, target): left = 0 right = current middle = (left + right) // 2 while left &lt;= right: if nums[middle] == target and middle == 0: return middle if nums[middle] == target and middle &gt; 0 and nums[middle - 1] != target: return middle if nums[middle] &lt; target: left = middle + 1 else: right = middle - 1 middle = (left + right) // 2 return current def findMaxIndex(self, nums, current, target): left = current right = len(nums) - 1 middle = (left + right) // 2 while left &lt;= right: if nums[middle] == target and middle == len(nums) - 1: return middle if nums[middle] == target and middle &gt; 0 and nums[middle + 1] != target: return middle if nums[middle] &gt; target: right = middle - 1 else: left = middle + 1 middle = (left + right) // 2 return current]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 341. 扁平化嵌套列表迭代器]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20341.%C2%A0%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给出一个嵌套的整型列表。设计一个迭代器，遍历这个整型列表中的所有整数。 列表中的项或者为一个整数，或者是另一个列表。 示例 1:给定列表 [[1,1],2,[1,1]], 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]. 示例 2:给定列表 [1,[4,[6]]], 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]. 2、解题思路​ 设计一个栈，如果是一个list，就放到栈里面，栈顶存放一个数字 ​ 但是，我们还需要知道他的下标，因此，我们就要同时保存下标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# """# This is the interface that allows for creating nested lists.# You should not implement it, or speculate about its implementation# """#class NestedInteger(object):# def isInteger(self):# """# @return True if this NestedInteger holds a single integer, rather than a nested list.# :rtype bool# """## def getInteger(self):# """# @return the single integer that this NestedInteger holds, if it holds a single integer# Return None if this NestedInteger holds a nested list# :rtype int# """## def getList(self):# """# @return the nested list that this NestedInteger holds, if it holds a nested list# Return None if this NestedInteger holds a single integer# :rtype List[NestedInteger]# """class NestedIterator(object): def __init__(self, nestedList): """ Initialize your data structure here. :type nestedList: List[NestedInteger] """ self.stack = [[nestedList, 0]] def next(self): """ :rtype: int """ self.hasNext() nestedList, index = self.stack[-1] self.stack[-1][1] += 1 return nestedList[index].getInteger() def hasNext(self): """ :rtype: bool """ stack = self.stack while stack: nestedList, index = self.stack[-1] if index == len(nestedList): stack.pop() else: cur = nestedList[index] if cur.isInteger(): return True stack[-1][1] += 1 stack.append([cur.getList(), 0]) return False # Your NestedIterator object will be instantiated and called as such:# i, v = NestedIterator(nestedList), []# while i.hasNext(): v.append(i.next()) ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 342. 4的幂]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20342.%C2%A04%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数 (32位有符整数型)，请写出一个函数来检验它是否是4的幂。 示例:当 num = 16 时 ，返回 true 。 当 num = 5时，返回 false。 问题进阶：你能不使用循环/递归来解决这个问题吗？ 致谢:特别感谢 @yukuairoy 添加这个问题并创建所有测试用例。 2、解题思路​ 从二进制位的角度来看，如果一个数是2的幂，n&amp;(n-1)就能直接判断，也就是说只出现一个’1’ ​ 如果是4的幂，那么只需要在判断一次，1出现在偶数位上就行了 1234567891011bool isPowerOfFour(int num) &#123; if(num &lt;=0)&#123; return false; &#125; if(!(num&amp;(num-1)) &amp;&amp; 0x55555555 &amp;num)&#123; return true; &#125; else&#123; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 343. 整数拆分]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20343.%C2%A0%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 例如，给定 n = 2，返回1（2 = 1 + 1）；给定 n = 10，返回36（10 = 3 + 3 + 4）。 注意：你可以假设 n 不小于2且不大于58。 感谢：特别感谢 @jianchao.li.fighter 添加此问题并创建所有测试用例。 2、解题思路我们来分析一下思路 1234567892: 13: 24: 45: 66: 97: 128: 169: 2410: 36 那么，当前最大的值应该是多少呢？ 1dp[i] = max(dp[1]*(n-1),dp[2]*(n-2),...,dp[n-1]*1,1*(n-1),2*(n-2),...,(n-1)*1) 从上面来看，也就是说，判断需要从两个角度来看： 前面求解的最优值与差值求和 在这里面，我们发现，实际上并不需要每一项都判断， 直接两个数相乘 实际上，从3往后，我们发现乘积之和都是大于它本身的，如果是两个数直接相乘， 如果是偶数，就是(n/2)*(n/2) 如果是奇数，就是(n/2)*(n/2+1) 上面的情况肯定是直接相乘最大的 然后，2，3是比较特殊的，因为他们的乘积是小于本身的，因此，要考虑这两种情况dp[n-2]*2, dp[n-3]*3 1234567891011121314151617181920212223class Solution: def integerBreak(self, n): """ :type n: int :rtype: int """ dp = [0, 1, 1, 2, 4, 6, 9, 12, 18] length = len(dp) if n &lt; length: return dp[n] dp.extend([0] * (n - length + 1)) for i in range(length, n + 1): half = i // 2 if i % 2 == 0: dp[i] = max(dp[i], dp[half] * dp[half], half * half, dp[i - 2] * 2, dp[i - 3] * 3) else: dp[i] = max(dp[i], dp[half] * dp[half + 1], half * (half + 1), dp[i - 2] * 2, dp[i - 3] * 3) return dp[n] ​ 实际上，只有2，3的情况特殊，其他的情况，都能够用中间的两个最大的值所得到 1234567891011121314151617181920212223class Solution: def integerBreak(self, n): """ :type n: int :rtype: int """ dp = [0, 1, 1, 2, 4, 6, 9, 12, 18] length = len(dp) if n &lt; length: return dp[n] dp.extend([0] * (n - length + 1)) for i in range(length, n + 1): half = i // 2 if i % 2 == 0: dp[i] = max(dp[half] * dp[half], dp[i - 2] * 2, dp[i - 3] * 3) else: dp[i] = max(dp[half] * dp[half + 1], dp[i - 2] * 2, dp[i - 3] * 3) return dp[n] ​ 又到网上查了一下，整数拆分实际上是一个数学问题，]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 344. 反转字符串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20344.%C2%A0%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述请编写一个函数，其功能是将输入的字符串反转过来。 示例： 12输入：s = &quot;hello&quot;返回：&quot;olleh&quot; 2、解题思路1234567891011121314151617181920char* reverseString(char* s) &#123; int length = strlen(s); if (length &lt;= 1) &#123; return s; &#125; char * temp = (char*)malloc(sizeof(char)*length+1); strcpy(temp,s); for (int i = 0; i &lt; length / 2; i++) &#123; temp[i] ^= temp[length-1-i]; temp[length-1-i] ^= temp[i]; temp[i] ^= temp[length-1-i]; &#125; return temp; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 347. 前K个高频元素]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20347.%C2%A0%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 例如， 给定数组 [1,1,1,2,2,3] , 和 k = 2，返回 [1,2]。 注意： 你可以假设给定的 k 总是合理的，1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 2、解题思路​ 先用字典，记录每个值出现的次数，然后通过排序，找出前面K个 12345678910class Solution: def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ counter = collections.Counter(nums) result = [v[0] for v in counter.most_common()[:k]] return result ​ 直接用系统库，果然很省力]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 345. 反转字符串中的元音字母]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20345.%C2%A0%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1：给定 s = “hello”, 返回 “holle”. 示例 2：给定 s = “leetcode”, 返回 “leotcede”. 注意:元音字母不包括 “y”. 2、 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758bool isVowel(char ch) &#123; switch (ch) &#123; case 'a': case 'e': case 'i': case 'o': case 'u': case 'A': case 'E': case 'I': case 'O': case 'U': return true; default: return false; &#125;&#125;char *reverseVowels(char *s) &#123; int length = strlen(s); if (length &lt;= 1) &#123; return s; &#125; char *buf = (char *) malloc(sizeof(char) * length + 1); strcpy(buf, s); int left = 0; int right = length - 1; for (int i = 0; i &lt; length / 2; i++) &#123; while (!isVowel(buf[left]) &amp;&amp; left &lt; length) &#123; left++; &#125; while (!isVowel(buf[right]) &amp;&amp; right &gt;= 0) &#123; right--; &#125; if (left &lt; right) &#123; buf[left] ^= buf[right]; buf[right] ^= buf[left]; buf[left] ^= buf[right]; left++; right--; &#125; else &#123; break; &#125; &#125; return buf;&#125; ​ 注意：下面的代码，在mac上直接跑有问题，不支持直接修改字符串 123456789101112131415161718192021222324252627282930313233343536373839404142char yuanyin[] = "aeiouAEIOU";char *reverseVowels(char *s) &#123; int length = strlen(s); if (length &lt;= 1) &#123; return s; &#125; //char *buf = (char *) malloc(sizeof(char) * length + 1); //strcpy(buf, s); int left = 0; int right = length - 1; for (int i = 0; i &lt; length / 2; i++) &#123; while (strchr(yuanyin, s[left]) == NULL &amp;&amp; left &lt; length) &#123; left++; &#125; while (strchr(yuanyin, s[right]) == NULL &amp;&amp; right &gt;= 0) &#123; right--; &#125; if (left &lt; right) &#123; s[left] ^= s[right]; s[right] ^= s[left]; s[left] ^= s[right]; left++; right--; &#125; else &#123; break; &#125; &#125; return s;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 349. 两个数组的交集]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20349.%C2%A0%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个数组，写一个函数来计算它们的交集。 例子: 给定 num1= [1, 2, 2, 1], nums2 = [2, 2], 返回 [2]. 提示: 每个在结果中的元素必定是唯一的。 我们可以不考虑输出结果的顺序。 2、解题思路​ 直接使用python的set解题很简单，如下： 12345678910class Solution: def intersection(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ s1 = set(nums1) s2 = set(nums2) return list(s1 &amp; s2)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 35. 搜索插入位置]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2035.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述1234567891011121314151617181920给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。示例 1:输入: [1,3,5,6], 5输出: 2示例 2:输入: [1,3,5,6], 2输出: 1示例 3:输入: [1,3,5,6], 7输出: 4示例 4:输入: [1,3,5,6], 0输出: 0 2、解题思路2.1 依次扫描法​ 从前向后扫描，遇到比当前数字小的，就将下标返回 1234567891011int searchInsert(int* nums, int numsSize, int target) &#123; int result_pos = 0; for(int i = 0;i&lt;numsSize; i++ )&#123; if(target &gt; nums[i])&#123; result_pos++; &#125;else&#123; return result_pos; &#125; &#125; return result_pos;&#125; 2.2 二分法​ 从中间开始比较，加快搜索速度 ​ 每一次更新左右的范围 ​ 最后找到的那个比较一次，即可得到下标 12345678910111213141516int searchInsert(int* nums, int numsSize, int target) &#123; int left = 0; int right = numsSize-1; while(left&lt;right)&#123; // 如果目标值大于中间值 if (target &gt; nums[(left+right)/2])&#123; left = (left+right)/2 +1; &#125;else&#123; right = (left+right)/2; &#125; &#125; if (target &gt; nums[left])&#123; left++; &#125; return left;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 350. 两个数组的交集 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20350.%C2%A0%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个数组，写一个方法来计算它们的交集。 例如:给定 nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2, 2]. 注意： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 跟进: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果nums2的元素存储在磁盘上，内存是有限的，你不能一次加载所有的元素到内存中，你该怎么办？ 2、解题思路12345678910111213141516class Solution: def intersect(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ result = list(set(nums1) &amp; set(nums2)) re = result[:] for i in result: for j in range((min(nums1.count(i) ,nums2.count(i)) - result.count(i))): re.append(i) return re 123456789import collectionsclass Solution: def intersect(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ return list((collections.Counter(nums1) &amp; collections.Counter(nums2)).elements())]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 355. 设计推特]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20355.%C2%A0%E8%AE%BE%E8%AE%A1%E6%8E%A8%E7%89%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能： postTweet(userId, tweetId): 创建一条新的推文 getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。 follow(followerId, followeeId): 关注一个用户 unfollow(followerId, followeeId): 取消关注一个用户 示例: 123456789101112131415161718192021222324Twitter twitter = new Twitter();// 用户1发送了一条新推文 (用户id = 1, 推文id = 5).twitter.postTweet(1, 5);// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.twitter.getNewsFeed(1);// 用户1关注了用户2.twitter.follow(1, 2);// 用户2发送了一个新推文 (推文id = 6).twitter.postTweet(2, 6);// 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -&gt; [6, 5].// 推文id6应当在推文id5之前，因为它是在5之后发送的.twitter.getNewsFeed(1);// 用户1取消关注了用户2.twitter.unfollow(1, 2);// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.// 因为用户1已经不再关注用户2.twitter.getNewsFeed(1); 2、解题思路​ 这道题的关键就在于保存用户关系，以及时间戳 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class Twitter: def __init__(self): """ Initialize your data structure here. """ self.user = &#123;&#125; self.timestamp = 0 def postTweet(self, userId, tweetId): """ Compose a new tweet. :type userId: int :type tweetId: int :rtype: void """ if self.user.get(userId) is None: self.user[userId] = [[(self.timestamp, tweetId)], set()] else: self.user[userId][0].append((self.timestamp, tweetId)) self.timestamp += 1 def getNewsFeed(self, userId): """ Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. :type userId: int :rtype: List[int] """ temp = [] if userId in self.user: temp.extend(self.user[userId][0][:-11:-1]) for i in self.user[userId][1]: if i in self.user: temp.extend(self.user[i][0][:-11:-1]) temp.sort(key=lambda x: x[0], reverse=True) if not temp: return [] return [i[1] for i in temp[:10]] def follow(self, followerId, followeeId): """ Follower follows a followee. If the operation is invalid, it should be a no-op. :type followerId: int :type followeeId: int :rtype: void """ if followerId == followeeId: return if self.user.get(followerId): self.user[followerId][1].add(followeeId) else: self.user[followerId] = [[], set([followeeId])] def unfollow(self, followerId, followeeId): """ Follower unfollows a followee. If the operation is invalid, it should be a no-op. :type followerId: int :type followeeId: int :rtype: void """ if self.user.get(followerId): if followeeId in self.user[followerId][1]: self.user[followerId][1].remove(followeeId) # Your Twitter object will be instantiated and called as such:# obj = Twitter()# obj.postTweet(userId,tweetId)# param_2 = obj.getNewsFeed(userId)# obj.follow(followerId,followeeId)# obj.unfollow(followerId,followeeId) ​ 超过了100%，哈哈哈哈]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 357. 计算各个位数不同的数字个数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20357.%C2%A0%E8%AE%A1%E7%AE%97%E5%90%84%E4%B8%AA%E4%BD%8D%E6%95%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10n。 示例:给定 n = 2，返回 91。（答案应该是除[11,22,33,44,55,66,77,88,99]外，0 ≤ x &lt; 100 间的所有数字） 致谢:特别感谢 @memoryless 添加这个题目并创建所有测试用例。 2、解题思路​ 分几种情况讨论 如果n为0，只有一个数，0，返回结果1 如果n为1，有0-9，10个数，返回10 如果n为2，最高位，不能为0，也就是有9个数可选，为了保证与高位不同，个位数可选9位数字 ，一共是81，因为求解[0,100),因此，81+10=91 如果n为3，最高位有9个，十位数是9个，个位数是8个，答案是9*9*8+91=739 一次类推 除了直接计算，采用dp保存前面的结果，进行缓存，这样在多次运算的时候就能直接得到结果 123456789101112131415161718class Solution: def countNumbersWithUniqueDigits(self, n): """ :type n: int :rtype: int """ dp = [1] if n == 0: return 1 res = 10 count = 9 for i in range(2, n + 1): res += count * (11 - i) count *= 11 - i return res ​ 这里简单的写一下]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 36. 有效的数独]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2036.%C2%A0%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 示例 1: 12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2: 123456789101112131415输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。 给定数独永远是 9x9 形式的。 2、解题思路​ 实际上，我们想要确定，每一行，每一列，每一个9宫格中，某一个数字只出现一次 ​ 我们可以这样做，将行标，数字组合起来，数字与列标组合起来，以及第几个9宫格组合起来，变成一个一个元组，如果每个元组只出现一次，表示满足要求，如果有一个出现了不止一次，表示不满足要求 ​ 123456789101112131415class Solution: def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ temp = [x for row in range(len(board)) for col in range(len(board[0])) for x in ((row, board[row][col]), (board[row][col], col), (row // 3, col // 3, board[row][col])) if board[row][col] != '.'] result_list = collections.Counter(temp) if len(result_list) == 0: return True return 1 == max(result_list.values())]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 365. 水壶问题]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20365.%C2%A0%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例1: (From the famous “Die Hard” example) 12输入: x = 3, y = 5, z = 4输出: True 示例2: 12输入: x = 2, y = 6, z = 5输出: False 致谢:感谢 @vinod23 添加这个问题并创建所有测试用例。 2、解题思路​ 这个题目是一个数学问题，用贝祖定理可以解决 12贝祖定理： 贝祖定理是代数几何中一个定理，其内容是若设a,b是整数，则存在整数x,y，使得ax+by=gcd（a,b），(a,b)代表最大公因数，则设a,b是不全为零的整数，则存在整数x,y，使得ax+by=(a，b)。 z &lt;= x+y z == x True z == y True z == x+y True z == abs(x-y) True 如果z%(gcd) == 0, 也就是说，z肯定能够使用x，y的组合构成 求解最大公约数，使用辗转相除法 123456789101112131415161718192021class Solution: def canMeasureWater(self, x, y, z): """ :type x: int :type y: int :type z: int :rtype: bool """ def gcd(a, b): if b &gt; a: a, b = b, a while b != 0: a, b = b, a % b return a if z &gt; x + y: return False if z == x + y or z == x or z == y or z == abs(x - y): return True return z % gcd(x, y) == 0 ​ 虽然通过了，不过这个基本上是一个数学题，这样并不能很好地体现计算机的解题思路 ​ 如果是纯计算机解题，那么]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 367. 有效的完全平方数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20367.%C2%A0%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 注意：不要使用任何内置的库函数，如 sqrt。 示例 1： 123输入： 16输出： True 示例 2： 123输入： 14输出： False 归功于: 特别感谢 @elmirap 添加此问题并创建所有测试用例。 2、解题思路打印出前面的数的平方，发现了规律， 1234567891011121314151617181920212223242526272829303132num: 0 pow2:0num: 1 pow2:1num: 2 pow2:4num: 3 pow2:9num: 4 pow2:16num: 5 pow2:25num: 6 pow2:36num: 7 pow2:49num: 8 pow2:64num: 9 pow2:81num: 10 pow2:100num: 11 pow2:121num: 12 pow2:144num: 13 pow2:169num: 14 pow2:196num: 15 pow2:225num: 16 pow2:256num: 17 pow2:289num: 18 pow2:324num: 19 pow2:361num: 20 pow2:400num: 21 pow2:441num: 22 pow2:484num: 23 pow2:529num: 24 pow2:576num: 25 pow2:625num: 26 pow2:676num: 27 pow2:729num: 28 pow2:784num: 29 pow2:841num: 30 pow2:900num: 31 pow2:961 ​ 通过列举所有的完全平方数，1，4，9，16，25，36，49，64，81，100…等等，发现完全平方数的差都为奇数，即1，3，5，7，9，11，13，15…等等~所以可以判断完全平方数应该是N个奇数的和。 123456789101112131415bool isPerfectSquare(int num) &#123; if (num &lt; 0) &#123; return false; &#125; for (int i = 1; num &gt; 0; i += 2) &#123; num -= i; &#125; if(num == 0)&#123; return true; &#125; else&#123; return false; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 368. 最大整除子集]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20368.%C2%A0%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给出一个由无重复的正整数组成的集合, 找出其中最大的整除子集, 子集中任意一对 (Si, Sj) 都要满足: Si % Sj = 0 或 Sj % Si = 0。 如果有多个目标子集，返回其中任何一个均可。 示例 1: 123集合: [1,2,3]结果: [1,2] (当然, [1,3] 也正确) 示例 2: 123集合: [1,2,4,8]结果: [1,2,4,8] 致谢：特别感谢 @Stomach_ache 添加这道题并创建所有测试用例。 2、解题思路​ 使用动态规划来做 首先，对数组进行排序 然后对于当前数字，先前寻找，能够整除的最大的数目 1dp[i] = max(dp[i], dp[j]+1) 举个例子 123[1,2,3]建立一个数组，存放当前点最大的整除序列数目在建立一个数组，保存当前节点最大的整除序列是由前面哪一个点增加得来的 1234567891011121314151617初始化为1，表示所有节点能够被自己整除[1 1 1]初始化为自己的下标，表示还没有通过前面的那个节点，得到最大的整除序列[0 1 2]首先是第一个点1，前面没有节点了，不用判断然后是2，判断能被1整除，更新dp，下标数组[1 2 1][0 0 2]然后是3，3可以被1整除，更新dp，下标数组[1 2 2][0 0 0]于是，我们就通过前向数组，就能得到整除的那个序列现在最大的就是2，从2这个点开始2，1到前向节点与当前节点是一个截止 123456789101112131415161718192021222324252627282930313233343536class Solution: def largestDivisibleSubset(self, nums): """ :type nums: List[int] :rtype: List[int] """ if not nums: return [] length = len(nums) dp = [1] * length pre = [i for i in range(length)] nums.sort() max_length = 1 max_index = 0 for i in range(length): for j in range(i): if nums[i] % nums[j] == 0 and dp[i] &lt; dp[j] + 1: dp[i] = dp[j] + 1 pre[i] = j if dp[i] &gt; max_length: max_length = dp[i] max_index = i result = [] while max_index != pre[max_index]: result.append(nums[max_index]) max_index = pre[max_index] result.append(nums[max_index]) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 371.两整数之和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20371.%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述不使用运算符 + 和-，计算两整数a 、b之和。 示例：若 a = 1 ，b = 2，返回 3。 致谢：特别感谢 @fujiaozhu 添加这道问题并创建测试用例。 2、解题思路 使用异或来做， 通过异或可以得到结果，通过与得到进位 将进位左移，作为新的加数 直到进位变成0为止 1234567891011int getSum(int a, int b) &#123; int carry = a &amp; b; int result = a ^b; int temp; while (carry != 0) &#123; temp = result; result = result ^ (carry &lt;&lt; 1); carry = temp &amp; (carry &lt;&lt; 1); &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 372. 超级次方]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20372.%C2%A0%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述你的任务是计算 a**b 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。 示例 1: 1234a = 2b = [3]结果: 8 示例 2: 1234a = 2b = [1,0]结果: 1024 致谢： 特别感谢 @Stomach_ache 添加这道题并创建所有测试用例。 2、解题思路​ 这个是数学问题，一开始没什么思路，不过主要还是利用取模的公式，不断地减少数量级 123x * y mod p=(x mod p) * (y mod p) mod p ​ 1234567891011121314151617181920212223class Solution: def superPow(self, a, b): """ :type a: int :type b: List[int] :rtype: int """ p = int("".join(map(str, b))) a = a % 1337 return self.calculate(a, p) def calculate(self, a, b): if b == 0: return 1 if b == 1: return a % 1337 val = self.calculate(a, b // 2) val *= val # 如果是奇数 if b &amp; 1 != 0: val *= a return val % 1337]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 373. 查找和最小的K对数字]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20373.%C2%A0%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84K%E5%AF%B9%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。 找到和最小的 k 对数字 (u1,v1), (u2,v2) … (uk,vk)。 示例 1: 123456给出： nums1 = [1,7,11], nums2 = [2,4,6], k = 3返回： [1,2],[1,4],[1,6]返回序列中的前 3 对数：[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 示例 2: 123456给出：nums1 = [1,1,2], nums2 = [1,2,3], k = 2返回： [1,1],[1,1]返回序列中的前 2 对数：[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] 示例 3: 123456给出：nums1 = [1,2], nums2 = [3], k = 3 返回： [1,3],[2,3]也可能序列中所有的数对都被返回:[1,3],[2,3] 2、解题思路​ 借助堆来实现 首先用用第一个数组的第0个元素，加上第二个数组的所有的值，放入堆中 然后开始从堆里里面取值，如果取出的值大于第一个数字第1个元素加上第二个数组第0个元素的值，这时候，我们将第一个数组的第1各元素，与第二个数组的所有元素匹配，放入堆中 实例说明 12345678[1 1 2] [1 2 3]c = 0一开始，将第一个元数组的第0个元素，与第二个数组所有的数字匹配，放入堆中(2，0，0)(3，0，1)(4，0，2)c=1将上面的组合放到堆中，接着，我们开始判断，从堆中取出来的组合，(2，0，0)的2，是不是大于第一个数组中下一个元素，与第二个数组中第0各元素之和，如果大于，结果中存放这个数字，并且将刚刚取出来的放入堆中，并且将第二个元素与剩余所有元素的匹配放入堆中 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def kSmallestPairs(self, nums1, nums2, k): """ :type nums1: List[int] :type nums2: List[int] :type k: int :rtype: List[List[int]] """ if not nums1 or not nums2: return [] length1 = len(nums1) length2 = len(nums2) count = min(length1 * length2, k) result = [] heap = [(nums1[0] + nums2[i], 0, i) for i in range(length2)] heapq.heapify(heap) c = 1 for i in range(count): if not heap: for j in range(length2): heapq.heappush(heap, (nums1[c] + nums2[j], c, j)) c += 1 temp = heapq.heappop(heap) if c &lt; length1: temp_sum = nums1[c] + nums2[0] if temp[0] &lt; temp_sum: result.append([nums1[temp[1]], nums2[temp[2]]]) else: result.append([nums1[c], nums2[0]]) heapq.heappush(heap, temp) for j in range(1, length2): heapq.heappush(heap, (nums1[c] + nums2[j], c, j)) c += 1 else: result.append([nums1[temp[1]], nums2[temp[2]]]) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 374. 猜数字大小]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20374.%C2%A0%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述我们正在玩一个猜数字游戏。 游戏规则如下：我从 1 到 *n* 选择一个数字。 你需要猜我选择了哪个数字。每次你猜错了，我会告诉你这个数字是大了还是小了。你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）： 123-1 : 我的数字比较小 1 : 我的数字比较大 0 : 恭喜！你猜对了！ 示例: 123n = 10, 我选择 6.返回 6. 2、解题思路1234567891011121314151617181920212223242526# The guess API is already defined for you.# @param num, your guess# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0# def guess(num):class Solution(object): def guessNumber(self, n): """ :type n: int :rtype: int """ left = 0 right = n while left &lt; right - 1: if guess(right - (right - left) // 2) == 1: left = left + (right - left) // 2 elif guess(right - (right - left) // 2) == -1: right = right - (right - left) // 2 elif guess(right - (right - left) // 2) == 0: return right - (right - left) // 2 if guess(left) == 0: return left else: return right 1234567891011121314151617181920212223# The guess API is already defined for you.# @param num, your guess# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0# def guess(num):class Solution(object): def guessNumber(self, n): """ :type n: int :rtype: int """ left = 1 right = n mid = (left + right) // 2 while guess(mid) != 0: if guess(mid) == 1: left = mid + 1 else: right = mid - 1 mid = (left + right) // 2 return mid]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 375. 猜数字大小 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20375.%C2%A0%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。 每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。 然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。 示例: 123456789n = 10, 我选择了8.第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。游戏结束。8 就是我选的数字。你最终要支付 5 + 7 + 9 = 21 块钱。 给定一个 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。 致谢: 特别感谢 @agave 和 @StefanPochmann 添加了这道题目，并且提供了所有测试用例。 2、解题思路​ 用动态规划来解决 分析一下思路，我们设置一个区间，在这个区间里面，才一个数，假设区间边界分别是，i，j 如果区间中只有一个数，i=j，那么花费肯定是0，一次就猜中了 如果i+1=j，那么如何保证能赢呢？每次都选小的那个数，如果挑选的正好是大的那个数，花费就是i，也就是说，只要有i，那么，不管挑选的是i还是j，肯定能赢 如果i+2=j,也就是我们有三个数可以选择的时候，如何保证一定能赢呢？ 首先，我们有i+1块钱，然后在前面区间和后面区间中，找到花钱最多的，加上i+1，这时候，就找到了 因为你会告诉我是大了还是小了，因此，3个数猜，肯定是中间的，i+1，因此， 以此类推，假如想要找从1到10的花费，那么，将区间分开， 假设我们第一次挑选的数字是5，因为你会告诉我猜的大了，还是猜的小了，因此，花费就是5加上前面区间和后面区间中较大的那个，这样才能保证能赢 假如想要的到1-10， 123456789101+dp[2][10]2+ max(dp[1][1], dp[3][10])3+ max(dp[1][2], dp[4][10])4+ max(dp[1][3], dp[5][10])5+ max(dp[1][4], dp[6][10])6+ max(dp[1][5], dp[7][10])7+ max(dp[1][6], dp[8][10])8+ max(dp[1][7], dp[9][10])9+ max(dp[1][8], dp[10][10])10+ dp[1][9] ​ 当我们求解1-9的时候，1-9之间的组合已经有了，但是前面的数到10的组合还没有，因此，需要从后面向前运算 ​ 也就是先将dp[9][10]算出来，然后是根据这个，就能计算dp[8][10] ​ 一次类推，最后，我们就得到了dp[1][10] 1234567891011121314151617181920class Solution: def getMoneyAmount(self, n): """ :type n: int :rtype: int """ dp = [[0] * (n + 1) for _ in range(n + 1)] for j in range(2, n + 1): for i in range(j - 1, 0, -1): temp = 0x7fffffff for k in range(i + 1, j): current = k + max(dp[i][k - 1], dp[k + 1][j]) temp = min(temp, current) if i + 1 == j: dp[i][j] = i else: dp[i][j] = temp return dp[1][n]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 376. 摆动序列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20376.%C2%A0%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例: 12345678910输入: [1,7,4,9,2,5]输出: 6解释: 整个序列就是一个摆动序列。输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 它的几个子序列满足摆动序列。其中一个是[1,17,10,13,10,16,8]。输入: [1,2,3,4,5,6,7,8,9]输出: 2 进阶:你能否用 O(n) 时间复杂度完成此题? 2、解题思路​ 使用动态规划，使用两个数组，down和up,分别保存到当前数字为止，前面一个是下降沿与上升沿的最大值 如果nums[i] &gt; nums[i - 1]: 也就是说现在这个是上升沿，那么上升沿更新为前面下降沿加一 下降沿不变 12up[i] = down[i - 1] + 1down[i] = down[i - 1] 如果nums[i] &lt; nums[i - 1]: 现在这个是下降沿，那个当前的下降沿用前面的上升沿加一更新，上升沿不变 12down[i] = up[i - 1] + 1up[i] = up[i - 1] 如果前后相等： 保持不变 12down[i] = down[i - 1]up[i] = up[i - 1] 1234567891011121314151617181920212223242526class Solution: def wiggleMaxLength(self, nums): """ :type nums: List[int] :rtype: int """ length = len(nums) if length &lt; 2: return length up = [1] * length down = [1] * length for i in range(1, length): if nums[i] &gt; nums[i - 1]: up[i] = down[i - 1] + 1 down[i] = down[i - 1] elif nums[i] &lt; nums[i - 1]: down[i] = up[i - 1] + 1 up[i] = up[i - 1] else: down[i] = down[i - 1] up[i] = up[i - 1] return max(up[-1], down[-1])]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 377. 组合总和 Ⅳ]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20377.%C2%A0%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例: 123456789101112131415nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 进阶：如果给定的数组中含有负数会怎么样？问题会产生什么变化？我们需要在题目中添加什么限制来允许负数的出现？ 致谢：特别感谢 @pbrother 添加此问题并创建所有测试用例。 2、解题思路​ 这道题使用动态规划来做 首先，将书数组中的所有的数字，建立哈希，方便查找 然后，建立dp[target+1] 然后对每一个下标开始判断 例如，对和为5进行判断 12345dp[5] = dp[0]+5(if 5 in nums) + dp[1]+4(if 4 in nums) + dp[2]+3(if 3 in nums) + dp[3]+2(if 2 in nums) + dp[4]+1(if 1 in nums) 以此类推，最后得到结果 ​ 上面的思路好像有点问题，还超时了 ​ 换个思路，再来一次，这一次我们使用构造法， 首先，将dp数组创建出来，然后将所有的nums数组中出现的数字对应的下标置一 接着，从前面向后进行扫描，遇到不为0的数，就用这个数字，加上nums中的数字，将对应的下标的数字增加1 举个例子 123456789101112131415nums = [1, 2, 3]target = 4首先，创建dp[0 0 0 0 0]然后初始化[0 1 1 1 0]然后开始扫描，找到第一个不为0的数，也就是下标为1的那个1然后判断 加上对应的nums的数字，是不是小于等于target1+11+21+3如果小于，对应的要加1得到新的dp[0 1 2 2 1]然后继续判断，到最后位置 123456789101112131415161718192021class Solution: def combinationSum4(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ dp = [0] * (target + 1) for i in nums: if i &lt;= target: dp[i] = 1 for i in range(target + 1): if dp[i] == 0: continue for j in nums: if i + j &lt;= target: dp[i + j] += dp[i] return dp[-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 101. 对称二叉树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20101.%C2%A0%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \2 2 \ \ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 2、 解题思路2.1 DFS​ 深度优先搜索 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */bool isSymmetric(struct TreeNode* root) &#123; // 判断终止条件 if (!root) &#123; return true; &#125; // 左右节点都不存在 if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; return true; &#125; // 左节点存在，右节点不存在 // 左节点不存在，右节点存在 // 左右节点存在，但是值不相等 if (root-&gt;left &amp;&amp; !root-&gt;right || !root-&gt;left &amp;&amp; root-&gt;right || root-&gt;left-&gt;val != root-&gt;right-&gt;val) &#123; return false; &#125; bool result = true; struct TreeNode *temp = (struct TreeNode *) malloc(sizeof(struct TreeNode)); temp-&gt;left = root-&gt;left-&gt;left; temp-&gt;right = root-&gt;right-&gt;right; result &amp;= isSymmetric(temp); temp-&gt;left = root-&gt;left-&gt;right; temp-&gt;right = root-&gt;right-&gt;left; result &amp;= isSymmetric(temp); return result;&#125; ​ 换一个思路 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */bool is_Symmetric(struct TreeNode *left, struct TreeNode *right) &#123; if (!left &amp;&amp; !right) &#123; return true; &#125; else if (!left || !right) &#123; return false; &#125; else &#123; return (left-&gt;val == right-&gt;val) &amp;&amp; is_Symmetric(left-&gt;left, right-&gt;right) &amp;&amp; is_Symmetric(left-&gt;right, right-&gt;left); &#125;&#125;bool isSymmetric(struct TreeNode *root) &#123; if (!root) &#123; return true; &#125; return is_Symmetric(root-&gt;left, root-&gt;right);&#125; 2.2 BFS​ 广度优先搜索 12]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 38. 报数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2038.%20%E6%8A%A5%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述1234567891011121314151617181920212223报数序列是指一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：1. 12. 113. 214. 12115. 1112211 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。21 被读作 &quot;one 2&quot;, &quot;one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。给定一个正整数 n ，输出报数序列的第 n 项。注意：整数顺序将表示为一个字符串。示例 1:输入: 1输出: &quot;1&quot;示例 2:输入: 4输出: &quot;1211&quot; 2、解题思路​ 一开始，看了半天没明白什么意思，后来才明白 ​ 这个序列是从1开始的，然后我们读出来，也就是one 1，变成了11，也就是说，下一个数是上一个数读音变化出来的 ​ 11，读成”two 1s”， 变成了21 以此类推： 1 11 21 1211 111221 21112211 1221112221 。。。 ​ 明确了题目的意思，也就容易写了 如果当前是1 并且下一个不是1，就直接变成11 如果当前是1，并且下一个是1，变成21 如果当前是2，下一个不是2，变成12 如果当前是2，下一个是2，变成22 只会出现这4种情况 ​ 如果用一个数组实现，发现是有点问题的，需要不断地移动数据 ​ 因此，选择使用两个数组，一个存放上一次的结果，另一个存放根据上一次计算出来的结果 需要非常注意的就是，这两个数组的长度问题 ​ 考虑到最大的可能性，新的数组长度可能是上一个的2倍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;memory.h&gt;#include &lt;string.h&gt;char *countAndSay(int n) &#123; if (n == 0) &#123; return ""; &#125; char *result = (char *) malloc(sizeof(char) * 2); char *next = (char *) malloc(strlen(result) * 2); char *temp; result[0] = '1'; result[1] = '\0'; int pos = 0; int next_pos = 0; int equal_num = 1; for (int i = 1; i &lt; n; i++) &#123; next_pos = 0; pos = 0; while (result[pos]) &#123; // 判断有几个相同字符 // 如果下一个字符存在，一直判断有几个相同的字符 if (result[pos + 1] == result[pos]) &#123; while (result[pos] == result[pos + 1]) &#123; equal_num++; pos++; &#125; pos++; next[next_pos] = '0' + equal_num; next[next_pos + 1] = result[pos - equal_num]; next_pos += 2; equal_num = 1; &#125; // 如果下一个字符是'\0' else if (!result[pos + 1]) &#123; next[next_pos] = '1'; next[next_pos + 1] = result[pos]; next[next_pos + 2] = '\0'; pos++; next_pos += 2; &#125; // 如果下一个字符与当前字符不相同 else if (result[pos + 1] &amp;&amp; result[pos] != result[pos + 1]) &#123; next[next_pos] = '1'; next[next_pos + 1] = result[pos];; pos++; next_pos += 2; &#125; &#125; next[next_pos] = '\0'; temp = result; result = next; free(temp); next = (char *) malloc(strlen(result) * 2); &#125; free(next); int count = 0; &#123; while (result[count]) &#123; count++; &#125; &#125; printf("number: %d \n", n); printf("length: %d \n", count); return result;&#125;void print(int x) &#123; int num = 1; for (int i = 31; i &gt;= 0; i--) &#123; if (x &amp; (num &lt;&lt; i)) &#123; printf("1"); &#125; else &#123; printf("0"); &#125; &#125; printf("\n");&#125;int main() &#123; printf("%s\n", countAndSay(1)); printf("%s\n", countAndSay(2)); printf("%s\n", countAndSay(3)); printf("%s\n", countAndSay(4)); printf("%s\n", countAndSay(5)); printf("%s\n", countAndSay(6)); printf("%s\n", countAndSay(7)); printf("%s\n", countAndSay(8)); printf("%s\n", countAndSay(9)); printf("%s\n", countAndSay(10)); printf("%s\n", countAndSay(11)); printf("%s\n", countAndSay(12)); printf("%s\n", countAndSay(13)); printf("%s\n", countAndSay(14)); printf("%s\n", countAndSay(25)); printf("%s\n", countAndSay(30)); printf("%s\n", countAndSay(50));&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/Users/zhangguohao/CLionProjects/untitled/cmake-build-debug/untitlednumber: 1 length: 1 1number: 2 length: 2 11number: 3 length: 2 21number: 4 length: 4 1211number: 5 length: 6 111221number: 6 length: 6 312211number: 7 length: 8 13112221number: 8 length: 10 1113213211number: 9 length: 14 31131211131221number: 10 length: 20 13211311123113112211number: 11 length: 26 11131221133112132113212221number: 12 length: 34 3113112221232112111312211312113211number: 13 length: 46 1321132132111213122112311311222113111221131221number: 14 length: 62 11131221131211131231121113112221121321132132211331222113112211number: 25 length: 1182 132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221number: 30 length: 4462 .. ​ 后面的数据太长。。。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 380. 常数时间插入、删除和获取随机元素]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20380.%C2%A0%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。 insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 : 1234567891011121314151617181920212223// 初始化一个空的集合。RandomizedSet randomSet = new RandomizedSet();// 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomSet.insert(1);// 返回 false ，表示集合中不存在 2 。randomSet.remove(2);// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomSet.insert(2);// getRandom 应随机返回 1 或 2 。randomSet.getRandom();// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomSet.remove(1);// 2 已在集合中，所以返回 false 。randomSet.insert(2);// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。randomSet.getRandom(); 2、解题思路​ 题目要求添加，删除，以及随机返回，都是$O(1)$的时间复杂度 ​ 如果直接使用数组，插入和随机返回都能够满足要求，但是删除不可以，会留有空位 ​ 如果直接用字典，插入和删除都能够满足要求，但是删除不可以，不能随机的找出想要的数字 随意，将数组和字典结合起来使用，我们使用数组保存元素，当我们想要删除的时候，就将当前元素与末尾元素调换，然后删除末尾元素即可，这样就得到了线性时间复杂度，并且，为了删除能快速定位这个元素，我们使用字典，保存元素所在的下标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class RandomizedSet: def __init__(self): """ Initialize your data structure here. """ self.nums = [] self.nums_index = &#123;&#125; def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.nums_index: self.nums.append(val) self.nums_index[val] = len(self.nums) - 1 return True else: return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ if val in self.nums_index: if len(self.nums) == 1: self.nums.pop() self.nums_index.pop(val) else: index = self.nums_index[val] self.nums[index], self.nums[-1] = self.nums[-1], self.nums[index] self.nums_index[self.nums[index]] = index self.nums.pop() self.nums_index.pop(val) return True else: return False def getRandom(self): """ Get a random element from the set. :rtype: int """ index = random.randint(0, len(self.nums) - 1) return self.nums[index]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom()]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 382. 链表随机节点]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20382.%C2%A0%E9%93%BE%E8%A1%A8%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。 进阶:如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？ 示例: 12345678// 初始化一个单链表 [1,2,3].ListNode head = new ListNode(1);head.next = new ListNode(2);head.next.next = new ListNode(3);Solution solution = new Solution(head);// getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。solution.getRandom(); 2、解题思路​ 这道题目实际上是蓄水池抽样的例子， ​ 假设有n条数据，可以是很大的文件很大，或者是流式数据，随机的选取k条数据，要保证取到每一个数据的概率是一样的，该如何来做呢？ 来自《The Art of Computer Programming》里的伪代码： 123456Init : a reservoir with the size： k for i= k+1 to N M=random(1, i); if( M &lt; k) SWAP the Mth value and ith value end for ​ ​ 首先，我们进行分析，假设有N个元素，我们只需要选取一个，保证每一个元素被选中的概率是一样的，该如何做呢？ N=1，选中这个元素的概率就是1，直接返回 N=2，首先我们选中第1个元素，然后通过随机数生成，生成（1，2），如果生成的数字是1，返回1，如果是2，返回2 或者反过来，如果是1，表示用当前数字替换1的位置 其概率都是0.5 N=3，同样是去取一个元素 先选中第一个元素，让后读取第二个数，取随机数（1，2），如果取到1，将当前元素和第一个元素交换，每个元素被取到的概率都是0.5 然后是第三个元素，随机的取（1，2，3），如果渠道的元素是1，就将当前元素和第一个元素交换，每一个元素渠道的概率： ==第一个元素==：$1 1/2 2/3 = 1/3$ ​ 首先，取到第一个元素的概率是1，然后加入第二个元素，取到的概率就是$1/2$, 然后加入第三个元素，第一个元素被取到的概率是$1/3$, 为什么呢？因为加入第三个元素，1在首位的概率是$1/2$，然后如果取到的随机数（1，2，3），不是1，就表示1最终可能被取到的概率，那么取到随机数2，3的概率就是$2/3$ ==第二个元素==：$1/2 * 2/3 = 1/3$ ​ 如果是2个元素，第二个元素被放到首位的概率是$1/2$，然后，加入第三个元素，被选中的概率是多少呢？ 是$2/3$，因为，不选中1的概率就是$2/3$, 于是，第二个元素被选中的概率是 1234567891011121314151617181920212223242526272829303132333435# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def __init__(self, head): """ @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. :type head: ListNode """ self.head = head self.value = head.val def getRandom(self): """ Returns a random node's value. :rtype: int """ temp = self.head count = 0 while temp: count += 1 if random.randint(1, count) == 1: self.value = temp.val temp = temp.next return self.value# Your Solution object will be instantiated and called as such:# obj = Solution(head)# param_1 = obj.getRandom() ​ 如果使用蓄水池抽样，执行效率并不是太高， ​ 答案中有一些取巧的做法，使用的是将所有元素先放到数组中，然后使用随机的下标，当然，这样做，主要是在小数 据量的时候有用，在大数据处理的时候，会出现问题。 ​ 当然，这个也要考虑实际情况，如果说内存能够将所有的数据放进去，当然就能够直接用随机的下标取出来了，这样效率更高； ​ 如果是流式数据的应用场景，那么使用蓄水池抽样就很合适了。 ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 383. 赎金信]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20383.%C2%A0%E8%B5%8E%E9%87%91%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。) 注意： 你可以假设两个字符串均只含有小写字母。 123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 2、解题思路123456789101112131415161718192021222324252627282930bool canConstruct(char* ransomNote, char* magazine) &#123; int ran_count[26]; int mag_count[26]; for (int i = 0; i &lt; 26; i++) &#123; ran_count[i] = 0; mag_count[i] = 0; &#125; int length_ran = strlen(ransomNote); int length_mag = strlen(magazine); for (int i = 0; i &lt; length_ran; i++) &#123; ran_count[ransomNote[i] - 'a']++; &#125; for (int i = 0; i &lt; length_mag; i++) &#123; mag_count[magazine[i] - 'a']++; &#125; for(int i =0;i&lt;26;i++)&#123; if(ran_count[i] &gt; mag_count[i])&#123; return false; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 384. 打乱数组]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20384.%C2%A0%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述打乱一个没有重复元素的数组。 示例: 123456789101112// 以数字集合 1, 2 和 3 初始化数组。int[] nums = &#123;1,2,3&#125;;Solution solution = new Solution(nums);// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。solution.shuffle();// 重设数组到它的初始状态[1,2,3]。solution.reset();// 随机返回数组[1,2,3]打乱后的结果。solution.shuffle(); 2、解题思路 首先，我们保存原来的数组，在重置的时候，直接返回 然后，使用交换的思路，对每一个数，求解他想要取得位置，使用一个随机数，随机生成 ​ 当然，也可以直接使用random库中自带的shuffle函数 123456789101112131415161718192021222324252627282930313233class Solution: def __init__(self, nums): """ :type nums: List[int] """ self.origin = nums def reset(self): """ Resets the array to its original configuration and return it. :rtype: List[int] """ return self.origin def shuffle(self): """ Returns a random shuffling of the array. :rtype: List[int] """ cur = self.origin.copy() length = len(self.origin) for i in range(length): pos = random.randint(0, length - 1) cur[i], cur[pos] = cur[pos], cur[i] return cur # Your Solution object will be instantiated and called as such:# obj = Solution(nums)# param_1 = obj.reset()# param_2 = obj.shuffle() 123456789101112131415161718192021222324252627282930class Solution: def __init__(self, nums): """ :type nums: List[int] """ self.origin = nums def reset(self): """ Resets the array to its original configuration and return it. :rtype: List[int] """ return self.origin def shuffle(self): """ Returns a random shuffling of the array. :rtype: List[int] """ cur = self.origin.copy() random.shuffle(cur) return cur # Your Solution object will be instantiated and called as such:# obj = Solution(nums)# param_1 = obj.reset()# param_2 = obj.shuffle()]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 385. Mini Parser]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20385.%C2%A0Mini%20Parser%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ]. Example 1: 123Given s = &quot;324&quot;,You should return a NestedInteger object which contains a single integer 324. Example 2: 123456789Given s = &quot;[123,[456,[789]]]&quot;,Return a NestedInteger object containing a nested list with 2 elements:1. An integer containing value 123.2. A nested list containing two elements: i. An integer containing value 456. ii. A nested list with one element: a. An integer containing value 789. 2、解题思路​ 首先来理解一下，这是一个嵌套的对象的反序列化，需要关注的几个点： 数字的识别 如果一个字母是数字的话，就要不断的向后移动，直到这个不是数字为止 list的识别 遇到’[]’的时候，将这个字母入栈，等到遇到’]’的时候，出栈 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# """# This is the interface that allows for creating nested lists.# You should not implement it, or speculate about its implementation# """#class NestedInteger:# def __init__(self, value=None):# """# If value is not specified, initializes an empty list.# Otherwise initializes a single integer equal to value.# """## def isInteger(self):# """# @return True if this NestedInteger holds a single integer, rather than a nested list.# :rtype bool# """## def add(self, elem):# """# Set this NestedInteger to hold a nested list and adds a nested integer elem to it.# :rtype void# """## def setInteger(self, value):# """# Set this NestedInteger to hold a single integer equal to value.# :rtype void# """## def getInteger(self):# """# @return the single integer that this NestedInteger holds, if it holds a single integer# Return None if this NestedInteger holds a nested list# :rtype int# """## def getList(self):# """# @return the nested list that this NestedInteger holds, if it holds a nested list# Return None if this NestedInteger holds a single integer# :rtype List[NestedInteger]# """class Solution: def deserialize(self, s): """ :type s: str :rtype: NestedInteger """ res = NestedInteger() nest_stack = [res] if s[0].isnumeric() or s[0] == '-': num_buff = s[0] num_sign = True else: num_sign = False num_buff = '' index = 1 while index &lt; len(s): if num_sign: if s[index].isnumeric(): num_buff += s[index] else: num_sign = False nest_stack[-1].setInteger(int(num_buff)) nest_stack.pop() index -= 1 num_buff = '' else: if s[index].isnumeric() or s[index] == '-': num_sign = True num_buff = s[index] temp = NestedInteger() nest_stack[-1].add(temp) nest_stack.append(temp) else: if s[index] == '[': temp = NestedInteger() nest_stack[-1].add(temp) nest_stack.append(temp) elif s[index] == ']': nest_stack.pop() index += 1 if num_buff: nest_stack[-1].setInteger(int(num_buff)) nest_stack.pop() return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 386. 字典序排数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20386.%C2%A0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数 n, 返回从 1 到 n 的字典顺序。 例如， 给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。 请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。 2、解题思路​ 可以直接排序，就是字符串形式的顺序 1234567class Solution: def lexicalOrder(self, n): """ :type n: int :rtype: List[int] """ return sorted(range(1, n+1), key=lambda x: str(x)) ​ 使用深度优先搜索来做 12345678910111213141516171819202122class Solution: def lexicalOrder(self, n): """ :type n: int :rtype: List[int] """ res = [] for i in range(1, 10): self.dfs(i, n, res) return res def dfs(self, start, n, res): if start &gt; n: return else: res.append(start) for i in range(10): if (10 * start + i) &gt; n: return self.dfs(10 * start + i, n, res)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 387. 字符串中的第一个唯一字符]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20387.%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例: 12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 注意事项：您可以假定该字符串只包含小写字母。 2、解题思路12345678910111213141516int firstUniqChar(char* s) &#123; int *index = (int *) calloc(26, sizeof(int)); int length = (int) strlen(s); for (int i = 0; i &lt; length; i++) &#123; index[s[i] - 'a']++; &#125; for (int i = 0; i &lt; length; i++) &#123; if (index[s[i] - 'a'] == 1) &#123; return i; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 388. 文件的最长绝对路径]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20388.%C2%A0%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述假设我们以下述方式将我们的文件系统抽象成一个字符串: 字符串 &quot;dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext&quot; 表示: 1234dir subdir1 subdir2 file.ext 目录 dir 包含一个空的子目录 subdir1 和一个包含一个文件 file.ext 的子目录 subdir2 。 字符串 &quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot; 表示: 1234567dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.ext 目录 dir 包含两个子目录 subdir1 和 subdir2。 subdir1 包含一个文件 file1.ext 和一个空的二级子目录 subsubdir1。subdir2 包含一个二级子目录 subsubdir2 ，其中包含一个文件 file2.ext。 我们致力于寻找我们文件系统中文件的最长 (按字符的数量统计) 绝对路径。例如，在上述的第二个例子中，最长路径为 &quot;dir/subdir2/subsubdir2/file2.ext&quot;，其长度为 32 (不包含双引号)。 给定一个以上述格式表示文件系统的字符串，返回文件系统中文件的最长绝对路径的长度。 如果系统中没有文件，返回 0。 说明: 文件名至少存在一个 . 和一个扩展名。 目录或者子目录的名字不能包含 .。 要求时间复杂度为 O(n) ，其中 n 是输入字符串的大小。 请注意，如果存在路径 aaaaaaaaaaaaaaaaaaaaa/sth.png 的话，那么 a/aa/aaa/file1.txt 就不是一个最长的路径。 2、解题思路 首先，我们可以将字符串按照’\n’进行分割 然后每一个目录或者是文件，前面有’\t’，个数就表示其深度 将目录入栈，并同时保存他的深度，遇到目录就入栈，遇到文件就将更新最长路径值 举个例子 123456789101112&quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot;首先分割字符串[&apos;dir&apos;, &apos;\tsubdir1&apos;, &apos;\t\tfile1.ext&apos;, &apos;\t\tsubsubdir1&apos;, &apos;\tsubdir2&apos;, &apos;\t\tsubsubdir2&apos;, &apos;\t\t\tfile2.ext&apos;]然后对每一个，计算其深度，并且去掉&apos;\t&apos;[&apos;dir&apos;, &apos;\tsubdir1&apos;, &apos;\t\tfile1.ext&apos;, &apos;\t\tsubsubdir1&apos;, &apos;\tsubdir2&apos;, &apos;\t\tsubsubdir2&apos;, &apos;\t\t\tfile2.ext&apos;]深度：[0, 1, 2, 2, 1, 2, 3]然后将每一个字符串去掉&apos;\t&apos;[&apos;dir&apos;, &apos;subdir1&apos;, &apos;file1.ext&apos;, &apos;subsubdir1&apos;, &apos;subdir2&apos;, &apos;subsubdir2&apos;, &apos;file2.ext&apos;]有了字符串，还有深度，就可以开始判断了，首先是判断当前字符串是不是路径，如果是，就判断当前的深度是不是小于栈中最后一个目录深度，如果是，就出栈，直到大于或者栈为空结束，然后将目录入栈如果是文件，不需要入栈，需要判断栈中的目录深度是不是小于当前文件，如果是，表示这个就是父目录，更新最长路径值 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def lengthLongestPath(self, input): """ :type input: str :rtype: int """ stack = [] input_split = input.split('\n') deepth = [x.count('\t') for x in input_split] dir_files = [x.replace('\t', '') for x in input_split] res = 0 count = 0 index = 0 while index &lt; len(dir_files): if '.' in dir_files[index]: if not stack or stack[-1][1] &lt; deepth[index]: res = max(res, count + len(dir_files[index]) + len(stack)) else: while stack and stack[-1][1] &gt;= deepth[index]: count -= stack[-1][0] stack.pop() index -= 1 else: if not stack or stack[-1][1] &lt; deepth[index]: count += len(dir_files[index]) stack.append((len(dir_files[index]), deepth[index])) else: while stack and stack[-1][1] &gt;= deepth[index]: count -= stack[-1][0] stack.pop() index -= 1 index += 1 return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 389. 找不同]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20389.%C2%A0%E6%89%BE%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个字符串 *s* 和 *t*，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 *t* 中被添加的字母。 示例: 123456789输入：s = &quot;abcd&quot;t = &quot;abcde&quot;输出：e解释：&apos;e&apos; 是那个被添加的字母。 2、解题思路12345678910111213141516171819202122232425char findTheDifference(char* s, char* t) &#123; int *index_s = (int *) calloc(26, sizeof(int)); int *index_t = (int *) calloc(26, sizeof(int)); int length_s = (int) strlen(s); int length_t = (int) strlen(t); for (int i = 0; i &lt; length_s; i++) &#123; index_s[s[i] - 'a']++; &#125; for (int i = 0; i &lt; length_t; i++) &#123; index_t[t[i] - 'a']++; &#125; for (int i = 0; i &lt; 26; i++) &#123; if (index_t[i] - index_s[i] == 1) &#123; return 'a' + i; &#125; &#125; return -1; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 39. 组合总和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2039.%C2%A0%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1: 123456输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 1234567输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 2、解题思路​ 使用递归的思路 ​ 首先，遇到一个数，我们就用target减掉这个数，判断一下，如果结果大于0，继续递归 ​ 如果等于0，将结果加入到结果集中 ​ 如果小于0，返回 12345678910111213141516171819202122class Solution: def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ result = [] self.findCombination(0, target, [], candidates, result) return result def findCombination(self, start, target, current, candidates, result): if target == 0: result.append(current) if target &lt; 0: return for i in range(start, len(candidates)): self.findCombination(i, target - candidates[i], current + [candidates[i]], candidates, result)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 390. 消除游戏]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20390.%C2%A0%E6%B6%88%E9%99%A4%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个从1 到 n 排序的整数列表。首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。返回长度为 n 的列表中，最后剩下的数字。 示例： 123456789输入:n = 9,1 2 3 4 5 6 7 8 92 4 6 82 66输出:6 2、解题思路​ 我们来找一下规律， 首先，在第一轮中，奇数位置的全部都删掉，然后剩下的全部是偶数位置，而奇数位置的数字，二进制表示中，末尾一位都是1 第二轮，反着删除，于是，能够被4整除的数字，都被删除了 第三轮中，与第一轮一样，不过这一次看的是为位置，而不是数字，重复第一轮 当n=1，结果就是1 当n=2，结果就是2 当n=3，结果就是2 当n=4，结果就是2 当n=5，结果就是2 当n=6，结果就是4 根据前面的描述，每一次，每隔4个数字，我们看成一次，也就是说从前往后删除一轮，从后向前删除一轮，那么结果就是，每隔4个，保留的都是第二个数字 12345678910111213141516171819201 2 3 4 5 6 7 8根据我们的规则，1，2，3，4中，保留第2个，然后是5，6，7，8中，保留第2个，也就是6于是，我们就来找规律，首先，每一轮，数字肯定是偶数，因为第一次奇数就都被删掉了然后剩下的数，会有两种情况，能被4整除，不能被4整除首先看不能被4整除的情况1 2 3 4 5 6这时候，剩下的不是恰好第2个，而是第4个元素如果是 1 2 3 4 5 6 7 8能够被4整除的情况下，剩下的就是2，6发现了一个规律，能被4整除的话，剩下的数乘以4，要减去2才可以不能被4整除，也就是说剩下的是4的倍数再来看个例子，如果是1 2 3 4 5 6 7 8 9 10经过一轮，剩下的是 4，8哈哈，规律很明显了，假如能被4整除，剩下的数字，就是每4个数字中的第2个，是4的倍数-2如果不能被4整除，那么，剩下的数字，就是从后向前，每4个数字中的第2个，这时候，正好是4的倍数 12345678910111213141516171819class Solution: def lastRemaining(self, n): """ :type n: int :rtype: int """ if n == 1: return 1 if n &lt;= 4: return 2 if n % 2 != 0: n -= 1 if n % 4 != 0: return 4 * self.lastRemaining(n // 4) else: return 4 * self.lastRemaining(n // 4) - 2]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 392. 判断子序列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20392.%C2%A0%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。 示例 1:s = &quot;abc&quot;, t = &quot;ahbgdc&quot; 返回 true. 示例 2:s = &quot;axc&quot;, t = &quot;ahbgdc&quot; 返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 致谢: 特别感谢 @pbrother 添加此问题并且创建所有测试用例。 2、解题思路​ 为啥感觉这道题直接用双指针就可以了？好像没get到难点。。 1234567891011121314151617181920212223242526class Solution: def isSubsequence(self, s, t): """ :type s: str :type t: str :rtype: bool """ index_s = 0 index_t = 0 length_s = len(s) length_t = len(t) if length_s == 0: return True while index_t &lt; length_t: if s[index_s] == t[index_t]: index_s += 1 if index_s &gt;= length_s: return True index_t += 1 return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 393. UTF-8 编码验证]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20393.%C2%A0UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则： 对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。 对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 这是 UTF-8 编码的工作方式： 1234567Char. number range | UTF-8 octet sequence (hexadecimal) | (binary)--------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。 注意:输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。 示例 1: 1234data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.返回 true 。这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。 示例 2: 123456data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.返回 false 。前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。下一个字节是开头为 10 的延续字节，这是正确的。但第二个延续字节不以 10 开头，所以是不符合规则的。 2、解题思路​ 主要是位运算判断是哪一个模式 如果第8位是0，就跳过判断下一个 如果不是0，判断第7位是不是0，如果是0，表示下一个元素应该是以10开头 如果还不是0，继续判断，第6位是不是0，如果是0，表示下面两个以10开头 如果第5位是0，表示，后面3个都是10开头的，如果这一位不是0，返回FALSE 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def validUtf8(self, data): """ :type data: List[int] :rtype: bool """ length = len(data) index = 0 while index &lt; length: if data[index] &amp; (1 &lt;&lt; 7) == 0: index += 1 elif data[index] &gt;&gt; 5 == 0b110: if index + 1 &lt; length: if data[index + 1] &gt;&gt; 6 != 0b10: return False else: index += 2 else: return False elif data[index] &gt;&gt; 4 == 0b1110: if index + 2 &lt; length: if data[index + 1] &gt;&gt; 6 != 0b10 or data[index + 2] &gt;&gt; 6 != 0b10: return False else: index += 3 else: return False elif data[index] &gt;&gt; 3 == 0b11110: if index + 3 &lt; length: if data[index + 1] &gt;&gt; 6 != 0b10 or data[index + 2] &gt;&gt; 6 != 0b10 or data[index + 3] &gt;&gt; 6 != 0b10: return False else: index += 4 else: return False else: return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 394. 字符串解码]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20394.%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: 123s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;. 2、解题思路​ 使用深度优先搜索 设置结果list 如果当前字符是字母，添加到结果数组中 如果是数字，开始进入识别数字模式 如果当前字符是’[‘，开始寻找它对应的’]’所在的位置，将这一段递归 使用数字乘以上面’[]’中字符串的返回值，放入结果数组中 最后将结果数组连接起来，返回 举个例子 12345678910&quot;3[a]2[bc]&quot;首先，识别到3，然后，进入子串识别，识别子串&apos;a&apos;&apos;a&apos;子串的返回值是&apos;a&apos;因此，将3*&apos;a&apos;放入结果数组[&apos;aaa&apos;]同样的道理，识别到后面的字符串，然后放到结果数组中[&apos;aaa&apos;,&apos;bcbc&apos;]最后连接起来，返回&apos;aaabcbc&apos; 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def decodeString(self, s): """ :type s: str :rtype: str """ res = [] index = 0 num = '' while index &lt; len(s): if s[index].isalpha(): res.append(s[index]) elif s[index].isnumeric(): num += s[index] index += 1 while s[index].isnumeric(): num += s[index] index += 1 index -= 1 elif s[index] == '[': index += 1 begin = index count = 1 while count: if s[index] == '[': count += 1 elif s[index] == ']': count -= 1 index += 1 index -= 1 res.append(int(num) * self.decodeString(s[begin:index])) num = '' index += 1 return ''.join(res)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 395. 至少有K个重复字符的最长子串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20395.%C2%A0%E8%87%B3%E5%B0%91%E6%9C%89K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。 示例 1: 1234567输入:s = &quot;aaabb&quot;, k = 3输出:3最长子串为 &quot;aaa&quot; ，其中 &apos;a&apos; 重复了 3 次。 示例 2: 1234567输入:s = &quot;ababbc&quot;, k = 2输出:5最长子串为 &quot;ababb&quot; ，其中 &apos;a&apos; 重复了 2 次， &apos;b&apos; 重复了 3 次。 2、解题思路​ 使用分治法 首先，统计当前字符串所有字符出现的次数 然后遍历字符串 如果当前字符出现的次数小于k，那么判断下一个字符出现的次数是不是小于k，如果是大于k的，就使用当前位置进行分割，分割为两个字符串，回到第一步，重新开始判断 123456789101112131415161718192021class Solution: def longestSubstring(self, s, k): """ :type s: str :type k: int :rtype: int """ if len(s) &lt; k: return 0 count = collections.Counter(s) index = 0 while index &lt; len(s): if count[s[index]] &lt; k: first_end = index while index &lt; len(s) and count[s[index]] &lt; k: index += 1 return max(self.longestSubstring(s[0:first_end], k), self.longestSubstring(s[index:], k)) index += 1 return len(s)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4. 两个排序数组的中位数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%204.%C2%A0%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1两个排序数组的中位数 1、问题描述1234567891011121314There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 ​ 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。 请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。 示例 1: 1234nums1 = [1, 3]nums2 = [2]中位数是 2.0 示例 2: 1234nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5 2、解题思路2.1 使用二分查找法​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) &#123;/** 基本思想：* 每一次判断，要找的是第k个数，如果在数组1中，第k/2个数比数组个数还要大，就是用最后一个数 用两个数组中的第k/2个数进行比较，如果第一个数组中的比第二个数组中的大，就能够将第二个数组中前k/2个数排除在比较范围之外 这时候，要查找的的就不是第k个数，而是k-k/2个数，*** left1：表示数组1的左边界，数组下标* left2：表示数组2的左边界，数组下标*/ int mid_loc; int pos1, pos2, left1 = 0, left2 = 0; // 奇偶判断，奇数为真，偶数为假 bool flag_odd_even = (nums1Size + nums2Size) % 2 == 0 ? false : true; bool found = false; double result; int result_pos; // 根据奇偶数，判断中位数是第几位数 if (flag_odd_even) &#123; //如果是奇数 mid_loc = (nums1Size + nums2Size) / 2 + 1; &#125; else &#123; //如果是偶数 mid_loc = (nums1Size + nums2Size) / 2; &#125; // 判断几种特殊情况，可以直接返回结果 if (nums1Size == 0 &amp;&amp; nums2Size != 0 &amp;&amp; nums2Size &gt; mid_loc) &#123; if (flag_odd_even) &#123; result = nums2[mid_loc - 1]; &#125; else &#123; result = (1.0 * nums2[mid_loc - 1] + nums2[mid_loc]) / 2; &#125; &#125; else if (nums2Size == 0 &amp;&amp; nums1Size != 0 &amp;&amp; nums1Size &gt; mid_loc) &#123; if (flag_odd_even) &#123; result = nums1[mid_loc - 1]; &#125; else &#123; result = (1.0 * nums1[mid_loc - 1] + nums1[mid_loc]) / 2; &#125; &#125; else &#123; // 使用二分法，进行判断 while (!found) &#123; pos1 = (mid_loc / 2) &gt; (nums1Size - left1 - 1) ? nums1Size - 1 : (mid_loc / 2 + left1 - 1); pos2 = (mid_loc / 2) &gt; (nums2Size - left2 - 1) ? nums2Size - 1 : (mid_loc / 2 + left2 - 1); if (nums1[pos1] &gt;= nums2[pos2]) &#123; // 如果第二个已经到了边界， 在第一个数组中直接找到结果 if (pos2 == (nums2Size - 1)) &#123; result_pos = mid_loc - (pos2 - left2 + 1) + left1 - 1; //奇数 if (flag_odd_even) &#123; result = nums1[result_pos]; &#125; else &#123; result = (1.0 * nums1[result_pos] + nums1[result_pos + 1]) / 2; &#125; found = true; &#125; else &#123; mid_loc -= (pos2 - left2 + 1); left2 = pos2 + 1; &#125; &#125; else &#123; // 如果第一个到了边界，直接在第二个数组中找到结果 if (pos1 == (nums1Size - 1)) &#123; result_pos = mid_loc - (pos1 - left1 + 1) + left2 - 1; //奇数 if (flag_odd_even) &#123; result = nums2[result_pos]; &#125; else &#123; result = (1.0 * nums2[result_pos] + nums2[result_pos + 1]) / 2; &#125; found = true; &#125; else &#123; mid_loc -= (pos1 - left1 + 1); left1 = pos1 + 1; &#125; &#125; if (!found &amp;&amp; mid_loc == 1) &#123; if (nums1[left1] &lt;= nums2[left2]) &#123; // 如果是奇数 if (flag_odd_even) &#123; result = nums1[left1]; &#125; else &#123; // 第一个条件是边界保护 if ((left1 &lt; nums1Size - 1) &amp;&amp; (nums1[left1 + 1] &lt;= nums2[left2])) &#123; result = (1.0 * nums1[left1] + nums1[left1 + 1]) / 2; &#125; else &#123; result = (1.0 * nums1[left1] + nums2[left2]) / 2; &#125; &#125; &#125; else &#123; if (flag_odd_even) &#123; result = nums2[left2]; &#125; else &#123; // 第一个条件是边界保护 if ((left2 &lt; nums2Size - 1) &amp;&amp; (nums2[left2 + 1] &lt;= nums1[left1])) &#123; result = (1.0 * nums2[left2] + nums2[left2 + 1]) / 2; &#125; else &#123; result = (1.0 * nums2[left2] + nums1[left1]) / 2; &#125; &#125; &#125; found = true; &#125; &#125; &#125; return result;&#125; 2.2 缓冲数组法​ 这个缓冲法就有点笨拙了，就类似于归并排序里面的，将两个已排好序的数组合并起来，不过我们只需要其中一半即可，这样就找到中位数了，这种办法的好处就是思路非常清晰，简单，但是会占用额外的空间，并且速度不快； 123456789101112131415161718192021222324252627282930313233double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) &#123;/** 基本思想：***/ int buff_length = (nums1Size + nums2Size) / 2 + 1; int num = (int*)malloc(sizeof(int)*buff_length); bool flag_odd_even = (nums1Size + nums2Size) % 2 == 0 ? false : true; int i=0,j=0; int count = 0; double result; int temp_length = buff_length; while (temp_length-- )&#123; if ((i &lt;nums1Size &amp;&amp; nums1[i] &lt;= nums2[j]) || j&gt;= nums2Size )&#123; num[count++] = nums1[i]; i++; &#125;else if((j &lt; nums2Size &amp;&amp; nums2[j] &lt;= nums1[i]) || i &gt;= nums1Size)&#123; num[count++] = nums2[j]; j++; &#125; &#125; if (flag_odd_even)&#123; result = num[buff_length-1]; &#125; else&#123; result = (1.0 * num[buff_length-2] + num[buff_length-1])/2; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 40. 组合总和 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2040.%C2%A0%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 123456输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 2、解题思路​ ​ 这个题目在前面的基础上，更改一下循环条件，并且判断是不是已经在结果集中就可以了 1234567891011121314151617181920212223class Solution: def combinationSum2(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ result = [] self.findCombination(0, target, [], candidates, result) return result def findCombination(self, start, target, current, candidates, result): if target == 0: if sorted(current) not in result: result.append(sorted(current)) if target &lt; 0: return for i in range(start, len(candidates)): self.findCombination(i+1, target - candidates[i], current + [candidates[i]], candidates, result)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 400. 第N个数字]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20400.%C2%A0%E7%AC%ACN%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。 注意:n 是正数且在32为整形范围内 ( n &lt; 231)。 示例 1: 12345输入:3输出:3 示例 2: 12345678输入:11输出:0说明:第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。 2、解题思路​ 首先确认是几位数 ​ 然后根据是几位数中的第几个数，找到那个数，然后确认是这个数中的第几个数字 12345678910111213141516171819202122232425int findNthDigit(int n) &#123; int plus = 1; long digital = 9; int prev = 0; int pos = n; while (pos &gt; plus * digital) &#123; pos -= (int) plus * digital; plus++; digital *= 10; &#125; prev = pos; pos = plus - (prev % plus == 0 ? plus : prev % plus); int num = (int) pow(10, plus - 1) + (prev-1) / plus; num = (num / (int) pow(10, pos)) % 10; return num; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 401. 二进制手表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20401.%C2%A0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。 每个 LED 代表一个 0 或 1，最低位在右侧。 例如，上面的二进制手表读取 “3:25”。 给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。 案例: 12输入: n = 1返回: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] 注意事项: 输出的顺序没有要求。 小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。 分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。 2、解题思路2.1 递归法​ 分成两部分 创建一个10个位置的数组，表示那几个灯亮 然后进行全部组合的遍历，利用递归 将满足条件的添加到结果中去 实际上，最多是亮8个灯，上面3个，下面5个 初始状态下，如果有3个灯，那么最多是$C(^3_{10})$ 这些，然后将其中不满足条件的删掉，所以初始的二维指针数组大小可以设置为这个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include "math.h"/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int pos = 0;// 将时间编程字符串，并且判断是不是满足要求的char *timeToString(int *time) &#123; int hour = 0; for (int i = 0; i &lt; 4; i++) &#123; if (time[i] == 1) &#123; hour += (int) pow(2, 3 - i); &#125; &#125; if (hour &gt;= 12) &#123; return NULL; &#125; int minite = 0; for (int i = 4; i &lt; 10; i++) &#123; if (time[i] == 1) &#123; minite += (int) pow(2, 9 - i); &#125; &#125; if (minite &gt; 59) &#123; return NULL; &#125; int digits = hour / 10 + 4; char *t = (char *) malloc(sizeof(char) * (digits + 1)); t[digits] = '\0'; t[digits - 3] = ':'; if (hour / 10 &gt;= 1) &#123; t[0] = '1'; t[1] = '0' + hour % 10; &#125; else &#123; t[0] = '0' + hour; &#125; t[digits - 2] = '0' + minite / 10; t[digits - 1] = '0' + minite % 10; return t;&#125;// 求解组合数int combination(int c, int u) &#123; if (u == 0) &#123; return 1; &#125; int result = 1; int down = c - u &gt; u ? u : c - u; int down_result = 1; for (int i = 0; i &lt; down; i++) &#123; result *= c - i; down_result *= i + 1; &#125; return result / down_result;&#125;// 递归求界所有的组合，并且转换成字符串，加入结果中void dfs(char **result, int timePos, int oneNums, int num, int *timeCode) &#123; if (oneNums == num) &#123; char *time = timeToString(timeCode); if (time!=NULL) &#123; result[pos++] = time; &#125; return; &#125; if (oneNums &gt; num || timePos == 10) &#123; return; &#125; timeCode[timePos] = 1; dfs(result, timePos + 1, oneNums + 1, num, timeCode); timeCode[timePos] = 0; dfs(result, timePos + 1, oneNums, num, timeCode);&#125;char **readBinaryWatch(int num, int *returnSize) &#123; char **result = (char **) malloc(sizeof(char *) * combination(10, num)); int *timeCode = (int *) calloc(10, sizeof(int)); dfs(result, 0, 0, num, timeCode); *returnSize = pos; char **r = (char **) malloc(sizeof(char *) * pos); for (int i = 0; i &lt; pos; i++) &#123; r[i] = result[i]; &#125; free(result); return r;&#125;int main() &#123;// printf("%d\n", combination(10, 1)); int size = 0;// char **r = readBinaryWatch(1, &amp;size); char **r = readBinaryWatch(2, &amp;size); printf("%d\n", size); printf("===================\n"); for (int i = 0; i &lt; size; i++) &#123; printf("%s\n", r[i]); &#125;// int *timeCode = (int *) calloc(10, sizeof(int));// timeCode[0] = 1;// timeCode[2] = 1;// printf("%s\n",timeToString(timeCode));&#125; ​ 上面代码本地跑起来没问题，leetCode上面run的时候没事，提交出错，有点困惑 2.2 循环法​ 实际上使用递归是很慢的，从另一个角度考虑，只需要判断一下数字中1的数量，并且相加，如果等于指定的1的数量，就转换这个数值，并且保存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */// 将时间编程字符串，并且判断是不是满足要求的char *timeToString(int time) &#123; int hour = 0; for (int i = 0; i &lt; 4; i++) &#123; if (time &amp; (1 &lt;&lt; (9 - i))) &#123; hour += (int) pow(2, 3 - i); &#125; &#125; int minute = 0; for (int i = 4; i &lt; 10; i++) &#123; if (time &amp; (1 &lt;&lt; (9 - i))) &#123; minute += (int) pow(2, 9 - i); &#125; &#125; int digits = hour / 10 + 4; char *t = (char *) malloc(sizeof(char) * (digits + 1)); t[digits] = '\0'; t[digits - 3] = ':'; if (hour / 10 &gt;= 1) &#123; t[0] = '1'; t[1] = '0' + hour % 10; &#125; else &#123; t[0] = '0' + hour; &#125; t[digits - 2] = '0' + minute / 10; t[digits - 1] = '0' + minute % 10; return t;&#125;// 求解组合数int combination(int c, int u) &#123; if (u == 0) &#123; return 1; &#125; int result = 1; int down = c - u &gt; u ? u : c - u; int down_result = 1; for (int i = 0; i &lt; down; i++) &#123; result *= c - i; down_result *= i + 1; &#125; return result / down_result;&#125;// 统计二进制位int binaryBits(int num) &#123; int result = 0; for (int i = 0; i &lt; 32; i++) &#123; if (num &amp; 1) &#123; result++; &#125; num &gt;&gt;= 1; if (num &lt;= 0) &#123; break; &#125; &#125; return result;&#125;char **readBinaryWatch(int num, int *returnSize) &#123; char **result = (char **) malloc(sizeof(char *) * combination(10, num)); int pos = 0; for (int i = 0; i &lt; 12; i++) &#123; for (int j = 0; j &lt; 60; j++) &#123; if (binaryBits(i) + binaryBits(j) == num) &#123; result[pos++] = timeToString((i &lt;&lt; 6) | j); &#125; &#125; &#125; *returnSize = pos; return result;&#125; ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 404. 左叶子之和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20404.%C2%A0%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述计算给定二叉树的所有左叶子之和。 示例： 1234567 3 / \ 9 20 / \ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 2、解题思路12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */int sumOfLeftLeaves(struct TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int result = 0; if (root-&gt;left) &#123; if (!root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; result += root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;left); &#125; else &#123; result += sumOfLeftLeaves(root-&gt;left); &#125; &#125; if (root-&gt;right) &#123; result += sumOfLeftLeaves((root-&gt;right)); &#125; return result; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 405. 数字转换为十六进制数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20405.%C2%A0%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。 注意: 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符&#39;0&#39;来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 示例 1： 12345输入:26输出:&quot;1a&quot; 示例 2： 12345输入:-1输出:&quot;ffffffff&quot; 2、解题思路123456789101112131415161718192021222324252627282930313233char* toHex(int num) &#123; char *result = (char *) malloc(sizeof(char) * 8+1); result[8] = '\0'; char *buf = "0123456789abcdef"; int num_pos = 0; for (int i = 0; i &lt; 8; i++) &#123; num_pos = 0; for (int j = 0; j &lt; 4; j++) &#123; if (num &amp; (1 &lt;&lt; (j + (i * 4)))) &#123; num_pos += pow(2, j); &#125; &#125; result[8 - i - 1] = buf[num_pos]; &#125; char *temp = result; int zero_num = 0; while (*temp == '0') &#123; zero_num++; temp++; &#125; if (zero_num == 8) &#123; zero_num = 7; &#125; char *re = (char *) malloc(sizeof(char) * (8 - zero_num + 1)); re[0] = 0; strcpy(re, &amp;result[zero_num]); free(result); return re;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 409. 最长回文串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20409.%C2%A0%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。 示例 1: 12345678输入:&quot;abccccdd&quot;输出:7解释:我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。 2、解题思路​ 统计所有字母出现的次数，如果是偶数，直接加上 ​ 如果是奇数，加上奇数然后减去一 ​ 最后，判断是否出现过奇数，出现过，就加一 1234567891011121314151617181920212223242526272829int longestPalindrome(char* s) &#123; if (!s) &#123; return 0; &#125; int buff['z'-'A'+1]; for (int i = 0; i &lt; 'z'-'A'+1; i++) &#123; buff[i] = 0; &#125; bool odd = false; int result = 0; int length = strlen(s); for (int i = 0; i &lt; length; i++) &#123; buff[s[i] - 'A']++; &#125; for (int i = 0; i &lt; 'z' - 'A' + 1; i++) &#123; if (buff[i] % 2 == 0) &#123; result += buff[i]; &#125; else &#123; result += buff[i] - 1; odd = true; &#125; &#125; return result + odd; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 412. Fizz Buzz]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20412.%C2%A0Fizz%20Buzz%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述写一个程序，输出从 1 到 n 数字的字符串表示。 \1. 如果 n 是3的倍数，输出“Fizz”； \2. 如果 n 是5的倍数，输出“Buzz”； 3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。 示例： 1234567891011121314151617181920n = 15,返回:[ &quot;1&quot;, &quot;2&quot;, &quot;Fizz&quot;, &quot;4&quot;, &quot;Buzz&quot;, &quot;Fizz&quot;, &quot;7&quot;, &quot;8&quot;, &quot;Fizz&quot;, &quot;Buzz&quot;, &quot;11&quot;, &quot;Fizz&quot;, &quot;13&quot;, &quot;14&quot;, &quot;FizzBuzz&quot;] 2、解题思路​ 基本上就是判断是不是被3整除，被5整除，都能整除，然后将该数字转换成字符串 ​ 如果想进一步提高效率，就将转换字符串的这一步确定一下，直接选择它的位数，不过会浪费空间； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546char *numToString(int num) &#123; int digits = 1; int temp = num; while (temp / 10) &#123; digits++; temp /= 10; &#125; char *result = (char *) calloc(digits + 1, sizeof(char)); sprintf(result, "%d", num); return result;&#125;/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */char **fizzBuzz(int n, int *returnSize) &#123; char **result = (char **) calloc(n, sizeof(char *)); char *divThree = "Fizz"; char *divFive = "Buzz"; char *divThreeAndFive = "FizzBuzz"; for (int i = 1; i &lt;= n; i++) &#123; if (i % 3 == 0 &amp;&amp; i % 5 == 0) &#123; result[i - 1] = divThreeAndFive; &#125; else if (i % 3 == 0) &#123; result[i - 1] = divThree; &#125; else if (i % 5 == 0) &#123; result[i - 1] = divFive; &#125; else &#123; result[i - 1] = numToString(i); &#125; &#125; *returnSize = n; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 414. 第三大的数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20414.%C2%A0%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例 1: 12345输入: [3, 2, 1]输出: 1解释: 第三大的数是 1. 示例 2: 12345输入: [1, 2]输出: 2解释: 第三大的数不存在, 所以返回最大的数 2 . 示例 3: 123456输入: [2, 2, 3, 1]输出: 1解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。存在两个值为2的数，它们都排第二。 2、解题思路123456789101112131415161718192021222324252627282930313233int thirdMax(int* nums, int numsSize) &#123; long top[3] = &#123;LONG_MIN, LONG_MIN, LONG_MIN&#125;; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i] &gt; top[0]) &#123; top[2] = top[1]; top[1] = top[0]; top[0] = nums[i]; &#125; if (nums[i] &lt; top[0] &amp;&amp; nums[i] &gt; top[1]) &#123; top[2] = top[1]; top[1] = nums[i]; &#125; if (nums[i] &lt; top[1] &amp;&amp; nums[i] &gt; top[2]) &#123; top[2] = nums[i]; &#125; &#125; if (top[2] != LONG_MIN) &#123; return top[2]; &#125; else &#123; return top[0]; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 415. 字符串相加]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20415.%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都不包含任何前导零。 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 2、解题思路​ ​ 与前面的一样，一位一位的判断，本位和以及进位 ​ 123456789101112131415161718192021222324252627282930313233343536373839404142char* addStrings(char* num1, char* num2) &#123; int length1 = strlen(num1); int length2 = strlen(num2); int max = length1 &gt; length2 ? length1 : length2; int min = length1 &gt; length2 ? length2 : length1; char *result = (char *) calloc(max + 2, sizeof(char)); bool carry = false; for (int i = 0; i &lt; max; i++) &#123; if (i &lt; min) &#123; result[max - i] = ((num1[length1 - 1 - i] - '0') + (num2[length2 - 1 - i] - '0') + carry) % 10 + '0'; carry = num1[length1 - 1 - i] + num2[length2 - 1 - i] + carry &gt;= 106 ? true : false; &#125; else &#123; if (length1 &lt; length2) &#123; result[max - i] = ((num2[length2 - 1 - i] - '0') + carry) % 10 + '0'; carry = num2[length2 - 1 - i] + carry &gt; 57 ? true : false; &#125; else &#123; result[max - i] = ((num1[length1 - 1 - i] - '0') + carry) % 10 + '0'; carry = num1[length1 - 1 - i] + carry &gt; 57 ? true : false; &#125; &#125; &#125; if (carry) &#123; result[0] = '1'; &#125; else &#123; char *re = (char *) calloc(max + 1, sizeof(char)); strcpy(re, &amp;result[1]); free(result); result = re; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 43. 字符串相乘]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2043.%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 12输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot; 示例 2: 12输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot; 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 2、解题思路​ 将每一个字符拿出来，放到一个数组中 ​ 然后，用第一个数的每一位，去乘以第二个数，累加到结果中去 121 2 3 4 5 6 ​ 最后，从结果中，找出第一个不为0的数字，从这个数字往后，转换为字符串，返回 ​ 注意，数字在结果中是反着存放的，需要从右端找出第一个不为0的数，然后转换为字符串返回 ​ ​ 基本思路是这样的 假设是123*456 首先，我们用3*456 然后，先是3*8，得到18，最低位就是8，进位是1 然后是3*5，得到15，加进位，16，第二位是6，进位是1 然后是3*4，得到12，加进位，得到13，第三位是3，进位是1 ​ 然后进行进位处理 ​ 进位加上下一个位的值，如果还有进位，继续传递 ​ 然后是2*456 ​ 因为2是第二位了，所有2*6的位置要从第二位开始算起 ​ ​ 以此类推 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def multiply(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ num1_list = [ord(v) - ord('0') for v in num1] num2_list = [ord(v) - ord('0') for v in num2] length1 = len(num1) length2 = len(num2) result = [0 for i in range(length1 + length2)] for i in range(length1): temp = 0 carry = 0 for j in range(length2): temp = result[i + j] + num1_list[length1 - 1 - i] * num2_list[length2 - 1 - j] + carry result[i + j] = temp % 10 carry = temp // 10 # 进位处理 k = i + j + 1 while carry != 0: temp = result[k] + carry result[k] = temp % 10 carry = temp // 10 k += 1 index = length1 + length2 - 1 while index &gt;= 0: if result[index] == 0: index -= 1 else: break if index == -1: return "0" return "".join([ chr(v + ord('0')) for v in reversed(result[:index + 1])]) ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 434. 字符串中的单词数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20434.%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例: 12输入: &quot;Hello, my name is John&quot;输出: 5 2、解题思路1234567891011121314151617181920212223242526int countSegments(char* s) &#123; bool word = false; int count = 0; while (*s) &#123; if (!word) &#123; if (*s != ' ') &#123; word = true; &#125; &#125; else &#123; if (*s == ' ') &#123; count++; word = false; &#125; &#125; s++; &#125; if(word)&#123; count++; &#125; return count;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 437. 路径总和 III]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20437.%C2%A0%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： 123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \3 -2 1返回 3。和等于 8 的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 2、解题思路123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */int pathSumCurrent(struct TreeNode *root, int sum) &#123; int result = 0; if (!root) &#123; return result; &#125; if (sum == root-&gt;val) &#123; result++; &#125; result += pathSumCurrent(root-&gt;left, sum - root-&gt;val); result += pathSumCurrent(root-&gt;right, sum - root-&gt;val); return result;&#125;int pathSum(struct TreeNode *root, int sum) &#123; if (!root) &#123; return 0; &#125; return pathSumCurrent(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 438 . 找到字符串中所有字母异位词]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20438%20.%C2%A0%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。 字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。 说明： 字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。 示例 1: 123456789输入:s: &quot;cbaebabacd&quot; p: &quot;abc&quot;输出:[0, 6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。 示例 2: 12345678910输入:s: &quot;abab&quot; p: &quot;ab&quot;输出:[0, 1, 2]解释:起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。 2、解题思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* findAnagrams(char* s, char* p, int* returnSize) &#123; int length_s = strlen(s); int length_p = strlen(p); if (!p || length_p &gt; length_s) &#123; return NULL; &#125; int *result = (int *) calloc(length_s - length_p + 1, sizeof(int)); int *index_p = (int *) calloc(26, sizeof(int)); int *temp = (int *) calloc(26, sizeof(int)); for (int i = 0; i &lt; length_p; i++) &#123; index_p[p[i] - 'a']++; &#125; int pos = 0; bool equal = true; for (int i = 0; i &lt; (length_s - length_p + 1); i++) &#123; for (int j = 0; j &lt; length_p; j++) &#123; temp[s[i + j] - 'a']++; &#125; equal = true; for (int k = 0; k &lt; 26; k++) &#123; if (temp[k] != index_p[k]) &#123; equal = false; break; &#125; &#125; // temp初始化 for (int k = 0; k &lt; 26; k++) &#123; temp[k] = 0; &#125; if (equal) &#123; result[pos++] = i; &#125; &#125; *returnSize = pos; return result; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 441. 排列硬币]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20441.%C2%A0%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。 给定一个数字 n，找出可形成完整阶梯行的总行数。 n 是一个非负整数，并且在32位有符号整型的范围内。 示例 1: 12345678n = 5硬币可排列成以下几行:¤¤ ¤¤ ¤因为第三行不完整，所以返回2. 示例 2: 123456789n = 8硬币可排列成以下几行:¤¤ ¤¤ ¤ ¤¤ ¤因为第四行不完整，所以返回3. 2、解题思路​ 这个问题可以用减值法，也可以用二分法，还能够用计算法 ​ 2.1 计算法​ 正常情况下，我们想到的是下面的公式$$k(k+1) \le 2n\k^2+k \le 2n\$$直接开方有问题，所以先来分解因式，先乘以4，得到$$4k^2 + 4*k \le 8n\ (2k+1)^2 -1 \le 8n\ k\le (\sqrt{8n+1}-1)/2$$ 123int arrangeCoins(int n) &#123; return (int)((-1 + sqrt(1 + 8 * (long double)n)) / 2);&#125; 2.2 遍历123456789101112131415int arrangeCoins(int n) &#123; int count = 0; for (int i = 1; i &lt;= n; i++) &#123; if (n &gt;= i) &#123; n -= i; count++; &#125; else &#123; break; &#125; &#125; return count; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 443. 压缩字符串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20443.%C2%A0%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一组字符，使用原地算法将其压缩。 压缩后的长度必须始终小于或等于原数组长度。 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 在完成原地修改输入数组后，返回数组的新长度。 进阶：你能否仅使用O(1) 空间解决问题？ 示例 1： 12345678输入：[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]输出：返回6，输入数组的前6个字符应该是：[&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]说明：&quot;aa&quot;被&quot;a2&quot;替代。&quot;bb&quot;被&quot;b2&quot;替代。&quot;ccc&quot;被&quot;c3&quot;替代。 示例 2： 12345678输入：[&quot;a&quot;]输出：返回1，输入数组的前1个字符应该是：[&quot;a&quot;]说明：没有任何字符串被替代。 示例 3： 123456789输入：[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]输出：返回4，输入数组的前4个字符应该是：[&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;]。说明：由于字符&quot;a&quot;不重复，所以不会被压缩。&quot;bbbbbbbbbbbb&quot;被“b12”替代。注意每个数字在数组中都有它自己的位置。 注意： 所有字符都有一个ASCII值在[35, 126]区间内。 1 &lt;= len(chars) &lt;= 1000。 2、解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758char *numToString(int num) &#123; int digits = 1; int temp = num; while (temp / 10) &#123; digits++; temp /= 10; &#125; char *result = (char *) calloc(digits + 1, sizeof(char)); sprintf(result, "%d", num); return result;&#125;int compress(char *chars, int charsSize) &#123; int pos = 0; char cur_ch = chars[0]; int ch_count = 1; char *count; for (int i = 1; i &lt; charsSize; i++) &#123; if (chars[i] == cur_ch) &#123; ch_count++; &#125; else &#123; chars[pos++] = cur_ch; cur_ch = chars[i]; if (ch_count &gt;= 2) &#123; count = numToString(ch_count); for (int j = 0; j &lt; strlen(count); j++) &#123; chars[pos++] = count[j]; &#125; &#125; ch_count = 1; &#125; &#125; chars[pos++] = cur_ch; if (ch_count &gt;= 2) &#123; count = numToString(ch_count); for (int j = 0; j &lt; strlen(count); j++) &#123; chars[pos++] = count[j]; &#125; &#125; return pos;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 447. 回旋镖的数量]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20447.%C2%A0%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。 示例: 12345678输入:[[0,0],[1,0],[2,0]]输出:2解释:两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 2、解题思路​ 因为需要考虑顺序，所以，首先固定一个点，然后将其他所有点相对于该点的距离算出来 ​ 然后，如果数目大于2，表示能够构成回旋镖，在其中取两个，n(n-1),表示排列数 ​ 举个例子，这个就相当于排列数，首先固定了第一个元素，然后在剩下的找出来两个，排列 ​ 如果固定第二个元素，同样的道理 ​ c语言实现有些麻烦，直接使用python 123456789101112131415161718class Solution: def numberOfBoomerangs(self, points): """ :type points: List[List[int]] :rtype: int """ result = 0 for i in points: dis = &#123;&#125; for j in points: if i != j: length = (i[0] - j[0])**2 + (i[1]-j[1])**2 dis[length] = dis.get(length,0)+1 for val in dis.values(): if val &gt;=2: result += val* (val-1) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 448. 找到所有数组中消失的数字]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20448.%C2%A0%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例: 12345输入:[4,3,2,7,8,2,3,1]输出:[5,6] 2、解题思路​ 根据上面的描述，我们知道，有一些元素重复出现了，如果我们将这些元素和下标关联起来，街能够找出来 ​ 例如，如果是数字2，就把[2-1]的下表的数字变成负数，从头向后扫描一遍，哪一个数字没有变成负数，就把[i+1]放到结果中 ​ 另一种，则是将对应下标的数加上n，如果有哪一个数最后没有被加，表示这个数就是缺失的 ​ 或者使用交换，将当前数与下标对应的数进行交换，交换了以后，判断对应下标的数字是不是下标+1，不是，表示这个数缺失 1234567891011121314151617181920212223242526272829/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) &#123; int count = 0; int target; for (int i = 0; i &lt; numsSize; i++) &#123; target = nums[i] &gt; 0 ? nums[i] : -nums[i]; if (nums[target - 1] &gt; 0) &#123; count++; nums[target - 1] = -nums[target - 1]; &#125; &#125; int *result = (int *) calloc(numsSize - count, sizeof(int)); int pos = 0; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i] &gt; 0) &#123; result[pos++] = i + 1; &#125; &#125; *returnSize = pos; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 453. 最小移动次数使数组元素相等]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20453.%C2%A0%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。 示例: 12345678910输入:[1,2,3]输出:3解释:只需要3次移动（注意每次移动会增加两个元素的值）：[1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] 2、解题思路​ 理解题意很重要，实际上，上面的描述主要表达了一个问题，每一次选取n-1个元素，使他们增加1，其实对应着另外一层意思，就是每次选取一个元素，使它减一，也就是说，题目的需要是将所有的元素调整为相等的，也就是说计算所有的元素相对于最小元素的差值就可以了 12345678910111213141516int minMoves(int* nums, int numsSize) &#123; int min = nums[0]; int result = 0; for (int i = 1; i &lt; numsSize; i++) &#123; if (nums[i] &lt; min) &#123; min = nums[i]; &#125; &#125; for(int i = 0;i&lt;numsSize;i++)&#123; result+= nums[i] - min; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 455. 分发饼干]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20455.%C2%A0%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意： 你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例 1: 12345678输入: [1,2,3], [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 12345678输入: [1,2], [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 2、解题思路​ 这个题目使用排序法就很好做了，每个小朋友获取的是大于等于其胃口的饼干，但是这个饼干与其胃口的差值是最小的 12345678910111213141516171819202122232425262728int cmp(int *a, int *b) &#123; return *a - *b;&#125;int findContentChildren(int *g, int gSize, int *s, int sSize) &#123; qsort(g, gSize, sizeof(int), cmp); qsort(s, sSize, sizeof(int), cmp); int result = 0; int cook_pos = 0; for (int i = 0; i &lt; gSize; i++) &#123; if (cook_pos &gt;= sSize) &#123; break; &#125; if (g[i] &lt;= s[cook_pos]) &#123; result++; cook_pos++; &#125; else &#123; cook_pos++; i--; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 458. 可怜的小猪]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20458.%C2%A0%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述有1000只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在15分钟内死去。 问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？ 回答这个问题，并为下列的进阶问题编写一个通用算法。 进阶: 假设有 n 只水桶，猪饮水中毒后会在 m 分钟内死亡，你需要多少猪（x）就能在 p 分钟内找出“有毒”水桶？n只水桶里有且仅有一只有毒的桶。 2、解题思路​ 这个题目很巧妙，从头开始分析问题 假如现在有一头猪，测试一次，能够确认几桶水呢？ ​ 答案是2桶，喝一桶，如果没事，表示有毒的是另一桶 如果同样是一头猪，测试两次呢？ 11 2 3 让这头猪第一次喝1，第二次是2，只能是3桶 如果是两头猪，测试一次，那么能够测试几桶水？ 4桶， 11 2 3 4 是4桶，为什么呢？ 两头猪有四种死亡状态，都没死，其中一个死，也就是第一个猪喝1，2，第二个猪是1，3，这样根据得到的4种状态，得到结果 如果是两头猪，测试2次呢？ 1231 2 34 5 67 8 9 测试2次，就是一个二维的，第一头猪第一次喝1，2，3，第二头猪第一次喝1，4，7，假如两头猪都没事， 125 68 9 结果集变成了上面这样，两头猪就能直接测试4桶水了 如果第一头死了，那么剩下一头猪，结果集如下 12 3 第二头猪就能够测试两个数 ​ 3头猪测试两次，能够测试多少呢？ ​ 答案是27头，相当于上面的9头的，增加了一个维度， ​ 如果测试一次，那么n头猪最多是$2^n$ ​ 也就是说，用猪的数量表示维度，测试次数加一，表示的是维度坐标长度， ​ 例如，2头猪，一次， 表示二维，维度长度是1+1 = 2 ​ ​ 3头猪，一次，三维，维度长度是2， 2*2*2 = 8 ​ 3头猪，2次，三维，维度长度是3，3*3*3=27 ​ 所以，就可以得出结果了 ​ n头猪，测试次数是k，能够测试的数量就是$$(k+1)^{n}$$​ 所以，如果是m通水，$$(k+1)^{n} &gt;=m$$ ​ 使用对数求解$$n * log(k+1) &gt;= logm\n &gt;= \frac{logm}{log(k+1)}$$​ 在c中，math.h提供了ceil函数，天花板，表示求解党的等于当前数的最小整数 ​ floor，地板，表示小于等于这个数的最大整数 123int poorPigs(int buckets, int minutesToDie, int minutesToTest) &#123; return (int)ceil(log(buckets) / log(minutesToTest /minutesToDie +1));&#125; ​ 所以解题思路很重要啊，哈哈]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 459. 重复的子字符串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20459.%C2%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 示例 1: 12345输入: &quot;abab&quot;输出: True解释: 可由子字符串 &quot;ab&quot; 重复两次构成。 示例 2: 123输入: &quot;aba&quot;输出: False 示例 3: 12345输入: &quot;abcabcabcabc&quot;输出: True解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。) 2、解题思路​ 实际很好判断，假如我们让整个串的子串，重复n次，n要大于1，那么n肯定是长度的因子 ​ 例如“abcabcabc” ​ 我们首先判断如果重复9次，是不是可以，不可以 ​ 然后是重复3次（2不是9的因子）可以，退出 123456789101112131415161718192021222324252627282930313233343536bool isRepeated(char *s, int step) &#123; int length = strlen(s); if (step &gt;= length) &#123; return false; &#125; for (int i = 0; i &lt; length - step; i++) &#123; if (s[i] != s[i + step]) &#123; return false; &#125; &#125; return true;&#125;bool repeatedSubstringPattern(char *s) &#123; if (!s) &#123; return false; &#125; bool result = false; int length = strlen(s); int step = 1; for (int i = 1; i &lt;= length; i++) &#123; if (length % i == 0) &#123; step = i; if (result = isRepeated(s, step)) &#123; break; &#125; &#125; &#125; return result;&#125; ​ ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 46. 全排列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2046.%C2%A0%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 2、解题思路​ 其实可以这样构造，例如，我们可以取第一个，作为第一个数，取第二个作为第一个数，一直取，取到最后 ​ 然后递归，确定第二个数 ​ 一直到确定最后一个元素的时候，返回 12345678910111213141516171819class Solution: def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ result = [] self.dfs(nums, 0, result) return result # index表示现在要确定第几个数 def dfs(self, nums, index, result): if index &gt;= len(nums) - 1: result.append(nums) return for i in range(index, len(nums)): new_nums = nums[:] new_nums[index], new_nums[i] = new_nums[i], new_nums[index] self.dfs(new_nums, index + 1, result)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 461. 汉明距离]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20461.%C2%A0%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意：0 ≤ x, y &lt; 231. 示例: 12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。 2、解题思路12345678int hammingDistance(int x, int y) &#123; int result = 0; for (int i = 0; i &lt; 32; i++) &#123; result += ((x &amp; (1 &lt;&lt; i)) ^ (y &amp; (1 &lt;&lt; i))) == 0 ? 0 : 1; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 463. 岛屿的周长]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20463.%C2%A0%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 : 1234567[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]答案: 16解释: 它的周长是下面图片中的 16 个黄色的边： 2、解题思路​ 解法很简单，遍历这个块，看看这个块周边是1，还是0，统计1的数量，然后用边数减去1的数量即可 12345678910111213141516171819202122232425262728293031323334int islandPerimeter(int** grid, int gridRowSize, int gridColSize) &#123; int result = 0; for (int i = 0; i &lt; gridRowSize; i++) &#123; for (int j = 0; j &lt; gridColSize; j++) &#123; if (grid[i][j]) &#123; result += 4; if (i - 1 &gt;= 0) &#123; if (grid[i - 1][j] == 1) &#123; result -= 1; &#125; &#125; if (j - 1 &gt;= 0) &#123; if (grid[i][j - 1] == 1) &#123; result -= 1; &#125; &#125; if (i + 1 &lt; gridRowSize) &#123; if (grid[i + 1][j] == 1) &#123; result -= 1; &#125; &#125; if (j + 1 &lt; gridColSize) &#123; if (grid[i][j + 1] == 1) &#123; result -= 1; &#125; &#125; &#125; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 47. 全排列 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2047.%C2%A0%E5%85%A8%E6%8E%92%E5%88%97%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 2、解题思路​ 在前面46题全排列的基础上，使用set无重复做存储，就得到结果了 123456789101112131415161718192021class Solution: def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ temp_result = set() self.dfs(nums, 0, temp_result) return [list(v) for v in temp_result] # index表示现在要确定第几个数 def dfs(self, nums, index, temp_result): if index &gt;= len(nums) - 1: temp_result.add(tuple(nums)) return for i in range(index, len(nums)): new_nums = nums[:] if index != i and new_nums[index] == new_nums[i]: continue new_nums[index], new_nums[i] = new_nums[i], new_nums[index] self.dfs(new_nums, index + 1, temp_result)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 475. 供暖器]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20475.%C2%A0%E4%BE%9B%E6%9A%96%E5%99%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。 所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。 说明: 给出的房屋和供暖器的数目是非负数且不会超过 25000。 给出的房屋和供暖器的位置均是非负数且不会超过10^9。 只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。 所有供暖器都遵循你的半径标准，加热的半径也一样。 示例 1: 123输入: [1,2,3],[2]输出: 1解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。 示例 2: 123输入: [1,2,3,4],[1,4]输出: 1解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。 2、解题思路​ 将房间好供暖器排序，对于每一个房间，找到离它最小的供暖半径是多少 ​ 然后，所有的房间中，最小供暖半径中找到最大的就可以了 ​ 下面的写法很简单，但是会超出时间限制，所以需要换个思路 1234567891011121314151617181920int findRadius(int *houses, int housesSize, int *heaters, int heatersSize) &#123; int result = INT32_MIN; int current_min = INT32_MAX; for (int i = 0; i &lt; housesSize; i++) &#123; for (int j = 0; j &lt; heatersSize; j++) &#123; if (abs(houses[i] - heaters[j]) &lt; current_min) &#123; current_min = abs(houses[i] - heaters[j]); &#125; &#125; if (result &lt; current_min) &#123; result = current_min; &#125; current_min = INT32_MAX; &#125; return result;&#125; ​ 下面是更好一点的优化解决办法，通过将之排序，就能够在扫描第一个的时候，确定与供暖期的哪一个进行比较 ​ 123456789101112131415161718192021int cmp(int *a, int *b) &#123; return *a - *b;&#125;int findRadius(int* houses, int housesSize, int* heaters, int heatersSize) &#123; int result = INT32_MIN; qsort(houses, housesSize, sizeof(int), cmp); qsort(heaters, heatersSize, sizeof(int), cmp); int heart_pos = 0; for (int i = 0; i &lt; housesSize; i++) &#123; while (heart_pos &lt; heatersSize - 1 &amp;&amp; abs(houses[i] - heaters[heart_pos]) &gt;= abs(houses[i] - heaters[heart_pos + 1])) &#123; heart_pos++; &#125; result = result &gt; abs(houses[i] - heaters[heart_pos]) ? result : abs(houses[i] - heaters[heart_pos]); &#125; return result; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 476. 数字的补数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20476.%C2%A0%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。 注意: 给定的整数保证在32位带符号整数的范围内。 你可以假定二进制数不包含前导零位。 示例 1: 123输入: 5输出: 2解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。 示例 2: 123输入: 1输出: 0解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。 2、解题思路​ 根据提议分析，首先是正整数，我们只需判断二进制表示中，左面第一个1的位置即可 123456789101112131415161718192021if (num == 0) &#123; return 1;&#125;int result = 0;int pos;for (int i = 31; i &gt;= 0; i--) &#123; if ((num &amp; (1 &lt;&lt; i) )!= 0) &#123; pos = i; break; &#125;&#125;for (int i = 0; i &lt;= pos; i++) &#123; if ((num &amp; (1 &lt;&lt; i) )== 0) &#123; result += pow(2, i); &#125;&#125;return result; ​ 上面的运行效率有点低，实际上，如果考虑异或的话， 12345678910111213int findComplement(int num) &#123; int temp = num &gt;&gt; 1; int xor = 1; while (temp &gt; 0) &#123; temp &gt;&gt;= 1; xor &lt;&lt;= 1; xor |= 1; &#125; return num ^ xor; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 479. 最大回文数乘积]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20479.%C2%A0%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E6%95%B0%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述你需要找到由两个 n 位数的乘积组成的最大回文数。 由于结果会很大，你只需返回最大回文数 mod 1337得到的结果。 示例: 输入: 2 输出: 987 解释: 99 x 91 = 9009, 9009 % 1337 = 987 说明: n 的取值范围为 [1,8]。 2、解题思路​ 首先，如果是两位数，那么我们从99开始，构造回文串，9999，判断是不可以被两位数整除，一直判断到少一位数，也就是比9大就可以 ​ 也就是说分两步，先构造回文串的数字，然后判断能不能被整除，如果可以，返回 ​ 用c语言构造回文串写起来有点麻烦，直接用python 12345678910111213141516171819class Solution: def largestPalindrome(self, n): """ :type n: int :rtype: int """ if n == 1: return 9; upper = 10**n -1 for i in range(upper, upper//10,-1): pal = int(str(i) + "".join(reversed(str(i)))) for j in range(upper, upper//10,-1): if pal // j &gt; upper: break if pal % j == 0: return pal % 1337 return -1 ​ 用python竟然超时了，没办法，还是用c来写一遍 1234567891011121314151617181920212223242526272829303132333435long buildPalindrome( long num, int digits) &#123; long result = num * pow(10, digits); int temp; for (int i = 0; i &lt; digits; i++) &#123; temp = (num / (int) pow(10, i)) % 10 * pow(10, digits - 1 - i); result += temp; &#125; return result;&#125;int largestPalindrome(int n) &#123; if (n == 1) &#123; return 9; &#125; int upper = pow(10, n) - 1; int lower = upper / 10; long pal = 9; for (int i = upper; i &gt; lower; i--) &#123; pal = buildPalindrome(i, n); for (int j = upper; j &gt; lower; j--) &#123; if (pal / j &gt; upper) &#123; break; &#125; if (pal % j == 0) &#123; return pal % 1337; &#125; &#125; &#125; return pal;&#125; ​ 还是用c可以，没有超时]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 48. 旋转图像]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2048.%C2%A0%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2: 123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 2、解题思路​ 从最简单的进行分析，2*2的矩阵 假如是 1234567891011121314151617181920212223242526271 23 4反转90度，变成样子就是：3 14 2其实这个过程可以分成两步来做，第一步，对角矩阵交换，也就是右上方的和左下方的进行交换变成1 32 4然后每一行左右交换3 1 4 2看到这里，实际上，我们就看到了没如果想要左转90度呢？只要把第一步变成，左上角和右下角更改就好了左转90度的结果是2 41 3那么第一步，左上角和右下角交换4 23 1第二步，每一行，左右交换 12345678910111213141516class Solution: def rotate(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ row = len(matrix) col = len(matrix[0]) for i in range(row): for j in range(i,col): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(row): for j in range(col // 2): matrix[i][j], matrix[i][col - 1 - j] = matrix[i][col - 1 - j], matrix[i][j]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 482. License Key Formatting]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20482.%C2%A0License%20Key%20Formatting%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes. Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase. Given a non-empty string S and a number K, format the string according to the rules described above. Example 1: 123456Input: S = &quot;5F3Z-2e-9-w&quot;, K = 4Output: &quot;5F3Z-2E9W&quot;Explanation: The string S has been split into two parts, each part has 4 characters.Note that the two extra dashes are not needed and can be removed. Example 2: 12345Input: S = &quot;2-5g-3-J&quot;, K = 2Output: &quot;2-5G-3J&quot;Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above. Note: The length of string S will not exceed 12,000, and K is a positive integer. String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-). String S is non-empty. 2、解题思路​ 一开始没有理解题意，实际上，他的意思是，假如使用3个字符一组，那么所有的字符，除了第一个，其他的都是3个字符 123456789101112131415161718192021222324252627282930313233343536char* licenseKeyFormatting(char* S, int K) &#123; int length = strlen(S); int length_temp = length; int result_pos = length + length / K; char *temp = S + length - 1; char *result = (char *) calloc(length + length / K, sizeof(char)); int count = K; while (length_temp-- &gt; 0) &#123; if (*temp != '-') &#123; if (count == 0) &#123; result[result_pos--] = '-'; count = K; &#125; if (*temp &gt;= 'a' &amp;&amp; *temp &lt;= 'z') &#123; result[result_pos--] = *temp - 32; &#125; else &#123; result[result_pos--] = *temp; &#125; count--; &#125; temp--; &#125; return &amp;result[result_pos+1]; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 485. 最大连续1的个数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20485.%C2%A0%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二进制数组， 计算其中最大连续1的个数。 示例 1: 123输入: [1,1,0,1,1,1]输出: 3解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3. 注意： 输入的数组只包含 0 和1。 输入数组的长度是正整数，且不超过 10,000。 2、解题思路12345678910111213141516171819202122232425262728int findMaxConsecutiveOnes(int* nums, int numsSize) &#123; int onesNum = 0; int result = INT32_MIN; for (int i = 0; i &lt; numsSize; i++) &#123; if (onesNum == 0) &#123; if (nums[i] == 1) &#123; onesNum++; &#125; else &#123; continue; &#125; &#125; else &#123; if (nums[i] == 0) &#123; result = result &gt; onesNum ? result : onesNum; onesNum = 0; &#125; else &#123; onesNum++; &#125; &#125; &#125; result = result &gt; onesNum ? result : onesNum; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 49. 字母异位词分组]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2049.%C2%A0%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 2、解题思路​ 12345678910111213class Solution: def groupAnagrams(self, strs): """ :type strs: List[str] :rtype: List[List[str]] """ result = &#123;&#125; for i in strs: if result.get(tuple(sorted(i))) is None: result[tuple(sorted(i))] = [i] else: result[tuple(sorted(i))].append(i) return list(result.values())]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 492. 构造矩形]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20492.%C2%A0%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求： 123451. 你设计的矩形页面必须等于给定的目标面积。2. 宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。3. 长度 L 和宽度 W 之间的差距应当尽可能小。 你需要按顺序输出你设计的页面的长度 L 和宽度 W。 示例： 1234输入: 4输出: [2, 2]解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。 说明: 给定的面积不大于 10,000,000 且为正整数。 你设计的页面的长度和宽度必须都是正整数。 2、解题思路12345678910111213141516171819202122232425262728/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* constructRectangle(int area, int* returnSize) &#123; *returnSize = 2; int *result = malloc(sizeof(int) * 2); int upper_num = (int) ceil(sqrt(area)); for (int i = upper_num; i &gt;= 1; i--) &#123; if (area % i == 0) &#123; result[0] = i; result[1] = area / i; break; &#125; &#125; if(result[0]&lt;result[1])&#123; result[0] ^=result[1]; result[1] ^=result[0]; result[0] ^=result[1]; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 496. 下一个更大元素 I]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20496.%C2%A0%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。 示例 1: 123456输入: nums1 = [4,1,2], nums2 = [1,3,4,2].输出: [-1,3,-1]解释: 对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。 对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。 对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。 示例 2: 12345输入: nums1 = [2,4], nums2 = [1,2,3,4].输出: [3,-1]解释: 对于num1中的数字2，第二个数组中的下一个较大数字是3。 对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。 注意: nums1和nums2中所有元素是唯一的。 nums1和nums2 的数组大小都不超过1000。 2、解题思路12345678910111213141516171819202122232425262728293031/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* nextGreaterElement(int* findNums, int findNumsSize, int* nums, int numsSize, int* returnSize) &#123; int *result = (int *) malloc(sizeof(int) * findNumsSize); *returnSize = findNumsSize; int findNum = -1; bool start_to_find = false; for (int i = 0; i &lt; findNumsSize; i++) &#123; for (int j = 0; j &lt; numsSize; j++) &#123; if (nums[j] == findNums[i]) &#123; start_to_find = true; &#125; if (start_to_find) &#123; if (nums[j] &gt; findNums[i]) &#123; findNum = nums[j]; break; &#125; &#125; &#125; result[i] = findNum; findNum = -1; start_to_find = false; &#125; return result; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5. 最长回文子串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%205.%C2%A0%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 123最长回文子串 回文串（palindromic string）是指这个字符串无论从左读还是从右读，所读的顺序是一样的；简而言之，回文串是左右对称的。所谓最长回文子串问题，是指对于一个给定的母串，找到的一个子串，是回文串，并且长度最长 1、题目描述123456789101112Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.Example 1:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.Example 2:Input: &quot;cbbd&quot;Output: &quot;bb&quot; 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot;也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 2、解题思路2.1 穷举法​ 从字符串的左侧，依次开始扫描，使用双重循环，将所有的子串得到，然后判断子串是否是回文串，如果是，判断长度是否是最长的，是最长的，就更新长度，并记录这个字串 ​ 不过需要分奇偶进行判断 2.2 动态规划​ 动态规划的思路就是，利用前面的结果进行判断，例如$$c[i,j] = \left{ {\matrix{ c[i+1, j-1] &amp; {if \ s[i] = s[j]} \cr 0 &amp; {if \ s[i] \ne s[j]} \cr } } \right.$$​ 如上所示，i和j表示下标，i在前，j在后，因此，判断的时候，如果判断到当前的是否是回文串，可以利用前面的结果来判断是不是回文串，比起前面构造的穷举法，少了一层循环 2.3 分治法​ 考虑回文串中间部分是相同的，从母串的每一个字符入手，向左右判断回文串的长度 2.4 Manacher​ 这个算法主要思想集中在将奇偶数的判断放在一起 ​ 例如下面的字符串 12345678910abcde变成#a#b#c#d#e#长度从5变成了11，也就是 2*n+1如果是ab#a#b#长度从2变成了5，同样是2*n +1也就是说，不管是奇数个还是偶数个字母，变换完成以后，都是奇数个 ​ 然后进行分析，如果当前判断的所在的下标被前面的回文串的最右侧下标所包含，，根据回文串的对称性，当前下标相对于前面的id有一个对称点，这个点的回文串长度我们已经算出来了，跟当前点到maxid的差值作比较，取小的，然后在这个基础上继续判断回文串的长度，也就是利用了前面应计算的结果，降低了计算量 ​ 这个算法的关键点，就在于，如果当前要判断的点在前面的点中的回文串中，那么肯定能够知道，这个点对称的位置的回文串长度，也能知道到最右端回文串的距离，这时候，就饿能根据这两个值，跳过一些已经验证过的步骤 123************$***1***i***j***$--------------假如我们判断到了j这个点，1是与j通过i对称的点，1的回文串半径已经确定了，那么j的回文串半径在右面$之前的部分也就能确定了，因为是对称的嘛 所以，基本的思路就是这样，跳过已经判断好的一些点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char *longestPalindrome(char *s) &#123; int i=0,id,maxid,ans=1,pos=0; //找到的最长回文串的左端下标 int left; //最长回文串的临时数组 char * result; //字符串长度 int str_length=0; while(s[i++]) str_length++; //初始化新的数组,存放每个元素对应的回文半径 int p[2*str_length+3]; //构造新的字符数组，用来计算 char new_str[2*str_length+3]; new_str[0]='$'; new_str[1]='#'; for (i =0;i&lt; str_length;i++)&#123; new_str[2*i+2]=s[i]; new_str[2*i+3]='#'; &#125; new_str[2*str_length+2]='\0'; int len = 2*str_length+2; // 对每个字符求其回文半径，利用前面的数组 // 最后面的'\0'不用求 // 第一个字符"$"，p[0]=1 id = 0; maxid = 1; p[0] = 1; for (i=1;i&lt;len;i++)&#123; // 判断前一次的回文最右端是不是包含当前判断的字符 if (maxid &gt; i)&#123; p[i] = p[2*id-i] &gt; (maxid-i)?(maxid-i):p[2*id-i]; &#125;else&#123; p[i] = 1; &#125; while(new_str[i+p[i]] == new_str[i-p[i]])&#123; p[i]++; &#125; if(p[i]+i&gt; maxid)&#123; maxid = p[i]+i; id = i; &#125; if (ans&lt;p[i])&#123; ans = p[i]; pos = i; &#125; &#125; left = (pos-ans)/2; result = (char*)malloc(sizeof(char)*ans); for (i=0;i&lt;ans-1;i++)&#123; result[i] = s[left+i]; &#125; result[ans-1] = '\0'; return result;&#125;int main() &#123; char * aa= "abb"; printf("%s\n", longestPalindrome(aa));&#125; 输出： 1234/Users/zhangguohao/CLionProjects/untitled/cmake-build-debug/untitledbbProcess finished with exit code 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 50.Pow(x, n)]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2050.Pow(x%2C%20n)%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 12输入: 2.00000, 10输出: 1024.00000 示例 2: 12输入: 2.10000, 3输出: 9.26100 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 2、解题思路​ 12345678class Solution: def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ return x ** n]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 500.键盘行]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20500.%E9%94%AE%E7%9B%98%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。 示例1: 12输入: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]输出: [&quot;Alaska&quot;, &quot;Dad&quot;] 注意: 你可以重复使用键盘上同一字符。 你可以假设输入的字符串将只包含字母。 2、解题思路​ 直接建立3个缓冲数组，存放q这一行，a这一行以及z这一行的值的索引，每一次判断一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */char** findWords(char** words, int wordsSize, int* returnSize) &#123; char *q = "qwertyuiopQWERTYUIOP"; char *a = "asdfghjklASDFGHJKL"; char *z = "zxcvbnmZXCVBNM"; int *index_q = (int *) calloc(('z' - 'A' + 1), sizeof(int)); int *index_a = (int *) calloc(('z' - 'A' + 1), sizeof(int)); int *index_z = (int *) calloc(('z' - 'A' + 1), sizeof(int)); while (*q || *a || *z) &#123; if (*q) &#123; index_q[*q - 'A']++; q++; &#125; if (*a) &#123; index_a[*a - 'A']++; a++; &#125; if (*z) &#123; index_z[*z - 'A']++; z++; &#125; &#125; char **result = (char **) malloc(sizeof(char *) * wordsSize); int result_pos = 0; char *temp; char *current_word; bool isWord = true; int current_line = 0; for (int i = 0; i &lt; wordsSize; i++) &#123; current_word = temp = words[i]; isWord = true; current_line = 0; while (*temp) &#123; if (current_line == 0) &#123; if (index_q[*temp - 'A'] != 0) &#123; current_line = 1; &#125; else if (index_a[*temp - 'A'] != 0) &#123; current_line = 2; &#125; else if (index_z[*temp - 'A'] != 0) &#123; current_line = 3; &#125; else &#123; isWord = false; break; &#125; &#125; else &#123; if (current_line == 1) &#123; if (index_q[*temp - 'A'] == 0) &#123; isWord = false; break; &#125; &#125; else if (current_line == 2) &#123; if (index_a[*temp - 'A'] == 0) &#123; isWord = false; break; &#125; &#125; else &#123; if (index_z[*temp - 'A'] == 0) &#123; isWord = false; break; &#125; &#125; &#125; temp++; &#125; if (isWord) &#123; result[result_pos++] = current_word; &#125; &#125; *returnSize = result_pos; // result = realloc(result, result_pos); return result; &#125; ​ 注意，在提交的时候，realloc出现问题了]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 501. 二叉搜索树中的众数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20501.%C2%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述Given a binary search tree (BST) with duplicates, find all the mode(s)) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. For example:Given BST [1,null,2,2], 123451 \ 2 /2 return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 例如：给定 BST [1,null,2,2], 123451 \ 2 /2 返回[2]. 提示：如果众数超过1个，不需考虑输出顺序 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内） 2、解题思路​ 首先，假设我们有一个排好序的数组，从前往后寻找出现次数最多的那个数，如果遇到一个，就来判断一下，当前数字的次数，如果等于最大计数值，就加入到结果数组中，如果大于，就将结果数组清空，并加入当前数 ​ 因为是二叉搜索树，因此，中序遍历就得到了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: current_value = 0; max_count = 0; count = 0; result = []; def findMode(self, root): """ :type root: TreeNode :rtype: List[int] """ if root != None: current_value = root.val else: return []; self.find(root) if self.count &gt; self.max_count: self.result.clear() self.result.append(self.current_value) elif self.count == self.max_count: self.result.append(self.current_value) return self.result; def find(self,root): if root == None: return ; self.find(root.left) if root.val == self.current_value: self.count += 1 else: if self.count &gt; self.max_count: self.result.clear() self.result.append(self.current_value) self.max_count = self.count elif self.count == self.max_count: self.result.append(self.current_value) self.count = 1; self.current_value = root.val self.find(root.right)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 504. 七进制数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20504.%C2%A0%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数，将其转化为7进制，并以字符串形式输出。 示例 1: 12输入: 100输出: &quot;202&quot; 示例 2: 12输入: -7输出: &quot;-10&quot; 注意: 输入范围是 [-1e7, 1e7] 。 2、解题思路​ 直接用python写了，比较简单 1234567891011121314151617181920class Solution: def convertToBase7(self, num): """ :type num: int :rtype: str """ if num &lt; 0: sign = "-" else: sign = "" temp = abs(num) result = str(temp % 7) while temp // 7: result = result + str(temp // 7 % 7) temp //= 7 result += sign return "".join(reversed(result))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 506. 相对名次]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20506.%C2%A0%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（”Gold Medal”, “Silver Medal”, “Bronze Medal”）。 (注：分数越高的选手，排名越靠前。) 示例 1: 1234输入: [5, 4, 3, 2, 1]输出: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]解释: 前三名运动员的成绩为前三高的，因此将会分别被授予 “金牌”，“银牌”和“铜牌” (&quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;).余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。 提示: N 是一个正整数并且不会超过 10000。 所有运动员的成绩都不相同。 2、解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */char *numToString(int num) &#123; int digits = 1; int temp = num; while (temp / 10) &#123; digits++; temp /= 10; &#125; char *result = (char *) calloc(digits + 1, sizeof(char)); sprintf(result, "%d", num); return result;&#125;int cmp(int *a, int *b) &#123; return *b - *a;&#125;char **findRelativeRanks(int *nums, int numsSize, int *returnSize) &#123; int *sort_num = (int *) malloc(sizeof(int) * numsSize); memcpy(sort_num, nums, sizeof(int) * numsSize); qsort(sort_num, numsSize, sizeof(int), cmp); char **result = (char **) malloc(sizeof(char *) * numsSize); for (int i = 0; i &lt; numsSize; i++) &#123; for (int j = 0; j &lt; numsSize; j++) &#123; if (nums[j] == sort_num[i]) &#123; if (i == 0) &#123; result[j] = "Gold Medal"; &#125; else if (i == 1) &#123; result[j] = "Silver Medal"; &#125; else if (i == 2) &#123; result[j] = "Bronze Medal"; &#125; else &#123; result[j] = numToString(i+1); &#125; break; &#125; &#125; &#125; *returnSize = numsSize; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 507. 完美数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20507.%C2%A0%E5%AE%8C%E7%BE%8E%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。 给定一个 正整数 n， 如果他是完美数，返回 True，否则返回 False 示例： 123输入: 28输出: True解释: 28 = 1 + 2 + 4 + 7 + 14 2、解题思路1234567891011121314151617181920212223242526272829303132bool checkPerfectNumber(int num) &#123; if (num == 1 || num == 0) &#123; return false; &#125; int ans = 1; int temp; int sq = (int) sqrt(num); for (int i = 2; i &lt;= sq; i++) &#123; temp = num % i; if (temp == 0) &#123; ans += num / i + i; &#125; &#125; if (sq != 1 &amp;&amp; num / sq == sq &amp;&amp; num %sq == 0) &#123; num -= sq; &#125; if (num == ans) &#123; return true; &#125; else &#123; return false; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 520. 检测大写字母]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20520.%C2%A0%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个单词，你需要判断单词的大写使用是否正确。 我们定义，在以下情况时，单词的大写用法是正确的： 全部字母都是大写，比如”USA”。 单词中所有字母都不是大写，比如”leetcode”。 如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。 否则，我们定义这个单词没有正确使用大写字母。 示例 1: 12输入: &quot;USA&quot;输出: True 示例 2: 12输入: &quot;FlaG&quot;输出: False 注意: 输入是由大写和小写拉丁字母组成的非空单词。 2、解题思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bool detectCapitalUse(char* word) &#123; if (!word) &#123; return true; &#125; bool result = true; /* * type: * 1：首字母大写 * 2：全部大写 * 3：全部小写 */ int type = 0; int length = strlen(word); while (length-- &gt; 0) &#123; if (type == 0) &#123; if (*word &gt;= 'A' &amp;&amp; *word &lt;= 'Z') &#123; type = 1; if ((word + 1) &amp;&amp; *(word + 1) &gt;= 'A' &amp;&amp; *(word + 1) &lt;= 'Z') &#123; type = 2; &#125; length--; word++; &#125; else &#123; type = 3; &#125; &#125; else &#123; if (type == 1 || type == 3) &#123; if (*word &lt; 'a') &#123; result = false; break; &#125; &#125; else if (type == 2) &#123; if (*word &gt; 'Z') &#123; result = false; break; &#125; &#125; &#125; word++; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 521. 最长特殊序列 Ⅰ]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20521.%C2%A0%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97%20%E2%85%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个字符串，你需要从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。 子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。 输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。 示例 : 123输入: &quot;aba&quot;, &quot;cdc&quot;输出: 3解析: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;) 说明: 两个字符串长度均小于100。 字符串中的字符仅含有 ‘a’~’z’。 2、解题思路​ ​ 这道题一开始没有理解题意，实际上比较简单的，就是给定两个字符串，如果一个字符串不能由另一个字符串删掉某些字符得到，就返回这个字符串的长度 ​ 其实一共可以分成3种情况 A的长度 &gt; B的长度 这时候，A肯定不能由B得到，直接返回A的长度 A的长度=B的长度 这时候，判断A和B是不是相同的字符串，如果不是，返回A的长度 如果是相同的字符串，返回-1 1234567891011121314151617int findLUSlength(char* a, char* b) &#123; int length_a = strlen(a); int length_b = strlen(b); if (length_a != length_b) &#123; return length_a &gt; length_b ? length_a : length_b; &#125; for (int i = 0;i&lt;length_a;i++)&#123; if (a[i] != b[i])&#123; return length_a; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 53.最大子序和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述12345678910给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。示例:输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。进阶:如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 2、解题思路​ 从前向后扫描，如果加上当前值使得和小于0，将和更新为0，继续扫描 ​ 需要判断一种特殊情况，全部小于0的时候，返回最大的负数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;memory.h&gt;#include &lt;string.h&gt;int maxSubArray(int *nums, int numsSize) &#123; bool all_minux = true; int max_minus = INT32_MIN; int this = 0; int max = 0; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i] &gt;= 0)&#123; all_minux = false; &#125; if(nums[i] &lt;0 &amp;&amp; max_minus &lt; nums[i])&#123; max_minus = nums[i]; &#125; this += nums[i]; if (this &gt; max) &#123; max = this; &#125; if (this &lt; 0) &#123; this = 0; &#125; &#125; if (all_minux)&#123; max = max_minus; &#125; return max;&#125;void print(int x) &#123; int num = 1; for (int i = 31; i &gt;= 0; i--) &#123; if (x &amp; (num &lt;&lt; i)) &#123; printf("1"); &#125; else &#123; printf("0"); &#125; &#125; printf("\n");&#125;int main() &#123; int a[]= &#123;-2, 1, -3, 4, -1, 2, 1, -5, 4&#125;; int b[]= &#123;-2, -1, -3, -4, -1, -2, -1, -5, -4&#125;; printf("%d\n", maxSubArray(a, 9)); printf("%d\n", maxSubArray(b, 9));&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 530. 二叉搜索树的最小绝对差]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20530.%C2%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值。 示例 : 12345678910111213输入: 1 \ 3 / 2输出:1解释:最小绝对差为1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。 注意: 树中至少有2个节点。 2、解题思路​ 实际上，因为是二叉搜索树，使用一下中序遍历就可以了 ​ 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */void in_order(struct TreeNode *root, int *prev, int *abs_max) &#123; if (!root) &#123; return; &#125; in_order(root-&gt;left, prev, abs_max); if (*prev != -1) &#123; *abs_max = *abs_max &lt; root-&gt;val - *prev ? *abs_max : root-&gt;val - *prev; *prev = root-&gt;val; &#125; else &#123; *prev = root-&gt;val; &#125; in_order(root-&gt;right, prev, abs_max);&#125;int getMinimumDifference(struct TreeNode *root) &#123; int prev = -1; int abs_max = INT32_MAX; in_order(root, &amp;prev, &amp;abs_max); return abs_max;&#125; 一开始，没有使用传参的方式，使用全局变量，报错，需要注意]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 532. 数组中的K-diff数对]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20532.%C2%A0%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84K-diff%E6%95%B0%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k. 示例 1: 1234输入: [3, 1, 4, 1, 5], k = 2输出: 2解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。尽管数组中有两个1，但我们只应返回不同的数对的数量。 示例 2: 123输入:[1, 2, 3, 4, 5], k = 1输出: 4解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。 示例 3: 123输入: [1, 3, 1, 5, 4], k = 0输出: 1解释: 数组中只有一个 0-diff 数对，(1, 1)。 注意: 数对 (i, j) 和数对 (j, i) 被算作同一数对。 数组的长度不超过10,000。 所有输入的整数的范围在 [-1e7, 1e7]。 2、解题思路2.1 哈希表法​ 一种思路是使用哈希表，将每个数字作为键，出现的次数作为value ​ 判断k是不是0，如果是，那么将所有的value值大于2的统计出来 ​ 如果k大于0，依次判断每一个键加上k是不是在哈希表中 ​ 12345678910111213141516171819202122232425262728class Solution: def findPairs(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ result = 0; if k&lt;0: return 0 hash_nums = &#123;&#125; for i in nums: if (hash_nums.get(i) == None): hash_nums[i] = 1 else: hash_nums[i] += 1 for i in hash_nums.keys(): if k==0 : if hash_nums[i] &gt;=2: result += 1 else: if hash_nums.get(i+k) != None: result += 1 return result ​ 用python实现比较简单 2.2 排序法​ 将数组先排序 ​ 判断k是不是0，如果是，就不断寻找相同数字大于2的，找到一次，就加一]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 538. 把二叉搜索树转换为累加树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20538.%C2%A0%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 例如： 123456789输入: 二叉搜索树: 5 / \ 2 13输出: 转换为累加树: 18 / \ 20 13 2、解题思路12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */int getTreeSum(struct TreeNode *root) &#123; if (!root) &#123; return 0; &#125; return root-&gt;val + getTreeSum(root-&gt;left) + getTreeSum(root-&gt;right);&#125;void convert_BST(struct TreeNode *root, int father) &#123; if (!root) &#123; return; &#125; root-&gt;val =root-&gt;val + father + getTreeSum(root-&gt;right); convert_BST(root-&gt;left, root-&gt;val); convert_BST(root-&gt;right, father); &#125;struct TreeNode *convertBST(struct TreeNode *root) &#123; convert_BST(root, 0); return root;&#125; ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 54. 螺旋矩阵]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2054.%C2%A0%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2: 1234567输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7] 2、解题思路​ 看到这个题，首先，想到的就是像贪吃蛇一样，不断地向前走，然后遇到障碍以后，拐弯，不过贪吃蛇只能向前，向左，向右，不能回退 ​ 这样的话，我们就设计一个表示已经走过的路径的墙壁，表示已经走过的路 例如是2*2的矩阵， 123456789101112131 23 4我们要的顺序就是1 2 4 3如何控制方向呢？1 1 1 11 0 0 11 0 0 11 1 1 1设计一个矩阵，专门用来表示走过的路径，最外围的是墙，然后每走过一步，就将该位置一没一次走之前，都要判断下一位是0才可以，不然就要调转方向如果无路可走，跳出即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import numpy as npclass Solution: def spiralOrder(self, matrix): """ :type matrix: List[List[int]] :rtype: List[int] """ row = len(matrix) if row == 0: return [] col = len(matrix[0]) buff = np.zeros((row + 2, col + 2), dtype=int) for i in range(row + 2): buff[i][0] = 1 buff[i][col + 1] = 1 for i in range(col + 2): buff[0][i] = 1 buff[row + 1][i] = 1 result = [] """ 方向： 右 0 下 1 左 2 上 3 """ direct = 0 print(buff) x = 0 y = -1 finish = False while not finish: x_temp = x y_temp = y if direct == 0: y += 1 elif direct == 1: x += 1 elif direct == 2: y -= 1 elif direct == 3: x -= 1 if buff[x + 1][y + 1] == 0: result.append(matrix[x][y]) buff[x + 1][y + 1] = 1 else: x = x_temp y = y_temp direct = (direct + 1) % 4 if buff[x_temp][y_temp + 1] == 1 and buff[x_temp + 1][y_temp] == 1 and buff[x_temp + 2][ y_temp + 1] == 1 and buff[x_temp + 1][y_temp + 2] == 1: finish = True return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 541. 反转字符串 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20541.%C2%A0%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。 示例: 12输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;bacdfeg&quot; 要求: 该字符串只包含小写的英文字母。 给定字符串的长度和 k 在[1, 10000]范围内。 2、解题思路123456789101112131415161718192021222324252627282930313233343536373839404142434445char* reverseStr(char* s, int k) &#123; if (!s) &#123; return s; &#125; int length = strlen(s); char *temp_s = (char *) malloc(sizeof(char) * (length + 1)); strcpy(temp_s,s); int pos = 0; int less = 0; char *temp = temp_s; while (pos &lt; length) &#123; if (length - pos &gt;= k) &#123; for (int i = 0; i &lt; k / 2; i++) &#123; *(temp + pos+i) ^= *(temp + pos + k - 1-i); *(temp + pos + k - 1 - i) ^= *(temp + pos+i); *(temp + pos+i) ^= *(temp + pos + k - 1 - i); &#125; pos += 2 * k; &#125; else &#123; less = length - pos; for (int i = 0; i &lt; less / 2; i++) &#123; *(temp + pos+i) ^= *(temp + pos + less - 1-i); *(temp + pos + less - 1 - i) ^= *(temp + pos+i); *(temp + pos+i) ^= *(temp + pos + less - 1 - i); &#125; pos += less; &#125; &#125; return temp_s; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 543. 二叉树的直径]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20543.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例 :给定二叉树 12345 1 / \ 2 3 / \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 2、解题思路​ 设计一个函数，找出当前节点中最长路径 ​ 再用一个函数，找出经过当前节点的最长路径，实际上就是利用上面的函数，得到左子树加上右子树的最长路径，再加上2 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */// 找到经过当前节点的最大的路径长度int getMaxdiameter(struct TreeNode *root) &#123; if (!root) &#123; return 0; &#125; int left = 0; int right = 0; if (root-&gt;left) &#123; left += 1 + getMaxdiameter(root-&gt;left); &#125; if (root-&gt;right) &#123; right += 1 + getMaxdiameter(root-&gt;right); &#125; return left &gt; right ? left : right;&#125;void getMax(struct TreeNode *root, int *max_length) &#123; int result = 0; if (root-&gt;left) &#123; result = 1 + getMaxdiameter(root-&gt;left); getMax(root-&gt;left, max_length); &#125; if (root-&gt;right) &#123; result += 1 + getMaxdiameter(root-&gt;right); getMax(root-&gt;right, max_length); &#125; if (result &gt; *max_length) &#123; *max_length = result; &#125;&#125;int diameterOfBinaryTree(struct TreeNode *root) &#123; if (!root) &#123; return 0; &#125; int max_length = 0; getMax(root, &amp;max_length); return max_length;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 55. 跳跃游戏]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2055.%C2%A0%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 123输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2: 123输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 2、解题思路​ 这个游戏一开始没什么思路，后来换个角度想一下，实际上，既然是每次最多的是当前的哪一步，也就是说，如果我们能够让最长的路线，大于等于最后一个位置，这样就能保证到达最后一个位置 ​ 因此，这道题的正确解法，是使用贪心法，每一次，挑选后面可能到达最长路径的那个步伐，然后不断地向后走，直到跳不过去为止 ​ 然后判断一下，是不是大于等于最后一个位置，得到结果 举个例子 1[2 3 1 1 4] 首先，将数组进行变换，看每一次跳跃能够从当前位置跳到哪一步 1[2 4 3 4 8] ​ 如上所示，第一步，能够看到的是4，3，也就是说，最远可以跳远额到位置4，于是，我们选择4所在的点，然后从这个点继续判断 ​ 4对应的是点1，原位置是3，也就是这个点能够看到3步，也就是看到3，4，8，我们挑选最大的那个，也就是8，我们发现8已经跳出了数组，循环退出 ​ 再来看另外一个例子： 1[3,2,1,0,4] 首先变换一下，看看每个点都能跳跃到的最远位置是哪个 1[3 3 3 3 8] ​ 我们发现，从第一个位置，整跳转到第三个位置，因此，我们就只能跳转到第三个位置上，然后我们发现，第三个只能跳转到它本身，这样就出问题了，因此，我们可以判断，如果当前这一次的步伐，相对于之前的步伐没有增加，直接退出循环即可，然后判断走到哪一步了 ​ 或者换个思路，贪心法的状态转换方程为 pos = max(pos,nums[i]+i) ​ 我们队每一个点，判断他能不能继续往前走，如果能够正常走到最后，表示当前的思路肯定是可以的，没什么问题，如果中途被停下了，不能继续往前走，也就是说不能遇到了循环了 ​ 那么什么时候是停止条件呢？ 1[3,2,1,0,4] ​ 我们来分析一下，首先，pos和第一个判断，也就是3+0，肯定是2比较大，这时候，pos为3，i变成了1，现在我们还是可以向后判断的，因为最大跳转两步，而1小于3，这时候，我们继续判断 ​ 然后到下一步，如果说i&gt;= pos，这时候，就不要判断了，因为pos是目前能看到的最长的位置，如果等于这个位置，表示陷入循环，超过的时候，表示跳不过去了 ​ 1234567891011121314class Solution: def canJump(self, nums): """ :type nums: List[int] :rtype: bool """ pos = -1 length = len(nums) for i in range(length): pos = max(pos, nums[i] + i) if i &gt;= pos and i &lt; length - 1: return False return True ​ 如上，一旦想明白了以后，代码实际上很简单 ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 551. 学生出勤纪录 I]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20551.%C2%A0%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E7%BA%AA%E5%BD%95%20I%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串来代表一个学生的出勤纪录，这个纪录仅包含以下三个字符： ‘A’ : Absent，缺勤 ‘L’ : Late，迟到 ‘P’ : Present，到场 如果一个学生的出勤纪录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。 你需要根据这个学生的出勤纪录判断他是否会被奖赏。 示例 1: 12输入: &quot;PPALLP&quot;输出: True 示例 2: 12输入: &quot;PPALLL&quot;输出: False 2、解题思路123456789101112131415161718192021222324252627282930313233343536373839bool checkRecord(char* s) &#123; int A_count = 0; int L_count = 0; bool start_Ls = false; for (int i = 0; i &lt; strlen(s); i++) &#123; if (A_count &gt;= 2 || L_count &gt;= 3) &#123; return false; &#125; if (s[i] == 'A') &#123; A_count++; &#125; if (!start_Ls) &#123; if (s[i] == 'L') &#123; start_Ls = true; L_count++; &#125; &#125; else &#123; if (s[i] == 'L') &#123; L_count++; &#125; else &#123; start_Ls = false; L_count = 0; &#125; &#125; &#125; if (A_count &gt;= 2 || L_count &gt;= 3) &#123; return false; &#125; return true; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 557. 反转字符串中的单词 III]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20557.%C2%A0%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1: 12输入: &quot;Let&apos;s take LeetCode contest&quot;输出: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot; 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 2、解题思路​ 12345678910111213141516171819202122232425262728293031323334353637383940char* reverseWords(char* s) &#123; int length = strlen(s); if (length &lt;= 1) &#123; return s; &#125; int current_pos = 0; int current_count = 0; char *temp = s; bool reverse = false; while (*temp) &#123; if (*temp != ' ') &#123; current_count++; &#125; else &#123; reverse = true; &#125; if (reverse) &#123; for (int i = 0; i &lt; current_count / 2; i++) &#123; s[current_pos + i] ^= s[current_pos + current_count - 1 - i]; s[current_pos + current_count - 1 - i] ^= s[current_pos + i]; s[current_pos + i] ^= s[current_pos + current_count - 1 - i]; &#125; current_pos += current_count +1; reverse = false; current_count = 0; &#125; temp++; &#125; for (int i = 0; i &lt; current_count / 2; i++) &#123; s[current_pos + i] ^= s[current_pos + current_count - 1 - i]; s[current_pos + current_count - 1 - i] ^= s[current_pos + i]; s[current_pos + i] ^= s[current_pos + current_count - 1 - i]; &#125; return s;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 56. 合并区间]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2056.%C2%A0%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给出一个区间的集合，请合并所有重叠的区间。 示例 1: 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 2、解题思路​ 这个问题实际上很简单，只要排个序，然后从前向后合并就好了 如果当前的end大于等于后面一个元素的start，这时候就需要合并，如果不是，直接将current加入到result里面，然后current指向下一个 如果已经合并到了最后一个，直接将current放到结果中，返回result 1234567891011121314151617181920212223242526272829# Definition for an interval.# class Interval:# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution: def merge(self, intervals): """ :type intervals: List[Interval] :rtype: List[Interval] """ length = len(intervals) if length &lt;=0: return [] temp = sorted(intervals, key=lambda x: x.start) result = [] current = temp[0] for i in range(length): if i + 1 &lt; length: if temp[i + 1].start &lt;= current.end: current.end = max(current.end, temp[i + 1].end) else: result.append(current) current = temp[i + 1] else: result.append(current) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 561. 数组拆分 I]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20561.%C2%A0%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%20I%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。 示例 1: 1234输入: [1,4,3,2]输出: 4解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 2、解题思路​ 1234567891011121314int cmp(int *a, int *b) &#123; return *a - *b;&#125;int arrayPairSum(int *nums, int numsSize) &#123; qsort(nums, numsSize, sizeof(int), cmp); int result = 0; for (int i = 0; i &lt; numsSize; i += 2) &#123; result += nums[i]; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 563. 二叉树的坡度]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20563.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，计算整个树的坡度。 一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。 整个树的坡度就是其所有节点的坡度之和。 示例: 12345678910输入: 1 / \ 2 3输出: 1解释: 结点的坡度 2 : 0结点的坡度 3 : 0结点的坡度 1 : |2-3| = 1树的坡度 : 0 + 0 + 1 = 1 注意: 任何子树的结点的和不会超过32位整数的范围。 坡度的值不会超过32位整数的范围。 2、解题思路​ 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */int getTreeSum(struct TreeNode *root) &#123; if (!root) &#123; return 0; &#125; return root-&gt;val + getTreeSum(root-&gt;left) + getTreeSum(root-&gt;right);&#125;int findTilt(struct TreeNode *root) &#123; if (!root || !root-&gt;right &amp;&amp; !root-&gt;left) &#123; return 0; &#125; return abs(getTreeSum(root-&gt;left) - getTreeSum(root-&gt;right)) + findTilt(root-&gt;left) + findTilt(root-&gt;right);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 566. 重塑矩阵]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20566.%C2%A0%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1: 123456789输入: nums = [[1,2], [3,4]]r = 1, c = 4输出: [[1,2,3,4]]解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 示例 2: 12345678910输入: nums = [[1,2], [3,4]]r = 2, c = 4输出: [[1,2], [3,4]]解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。 注意： 给定矩阵的宽和高范围在 [1, 100]。 给定的 r 和 c 都是正数。 2、解题思路​ 实际思路很简单，创建了矩阵以后，从头开始赋值， ​ 从第一行的第一个元素开始数 1234567891011121314151617181920212223242526272829303132333435/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *columnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** matrixReshape(int** nums, int numsRowSize, int numsColSize, int r, int c, int** columnSizes, int* returnSize) &#123; // columnSizes = (int **) malloc(sizeof(int *)); if (numsRowSize * numsColSize != r * c) &#123; *returnSize = numsRowSize; *columnSizes = (int *) malloc(sizeof(int) * numsRowSize); for (int i = 0; i &lt; numsRowSize; i++) &#123; (*columnSizes)[i] = numsColSize; &#125; return nums; &#125; *returnSize = r; *columnSizes = (int *) malloc(sizeof(int) * r); for (int i = 0; i &lt; r; i++) &#123; (*columnSizes)[i] = c; &#125; int **result = (int **) malloc(sizeof(int *) * r); int *line; for (int i = 0; i &lt; r * c; i++) &#123; if (i % c == 0) &#123; line = (int *) malloc(sizeof(int) * c); result[i / c] = line; &#125; result[i / c][i % c] = nums[i / numsColSize][i % numsColSize]; &#125; return result;&#125; ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 572. 另一个树的子树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20572.%C2%A0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1:给定的树 s: 12345 3 / \ 4 5 / \1 2 给定的树 t： 123 4 / \1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 示例 2:给定的树 s： 1234567 3 / \ 4 5 / \1 2 / 0 给定的树 t： 123 4 / \1 2 返回 false。 2、解题思路​ 1234567891011121314151617181920212223242526272829bool isEqual(struct TreeNode *s, struct TreeNode *t) &#123; if (!s &amp;&amp; !t) &#123; return true; &#125; else if (!s &amp;&amp; t || s &amp;&amp; !t || s-&gt;val != t-&gt;val) &#123; return false; &#125; return isEqual(s-&gt;left, t-&gt;left) &amp;&amp; isEqual(s-&gt;right, t-&gt;right);&#125;bool isSubtree(struct TreeNode *s, struct TreeNode *t) &#123; if (!s &amp;&amp; !t) &#123; return true; &#125; bool result = false; result = result || isEqual(s, t); if (s-&gt;left) &#123; result = result || isSubtree(s-&gt;left, t); &#125; if (s-&gt;right) &#123; result = result || isSubtree(s-&gt;right, t); &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 575. 分糖果]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20575.%C2%A0%E5%88%86%E7%B3%96%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。 示例 1: 1234输入: candies = [1,1,2,2,3,3]输出: 3解析: 一共有三种种类的糖果，每一种都有两个。 最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。 示例 2 : 123输入: candies = [1,1,2,3]输出: 2解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。 注意: 数组的长度为[2, 10,000]，并且确定为偶数。 数组中数字的大小在范围[-100,000, 100,000]内。 2、解题思路​ 首先分析一下，假如每一种只有一个，那么妹妹能够得到的种类就是candies/2, ​ 实际上，妹妹能够得到的糖果种类，最多是candies/2, ​ ​ 可以这样做，如果糖果种类超过一般的数量，妹妹肯定能够获得一半种类的糖果 ​ 如果不超过，妹妹能得到所有的种类 ​ 1234567891011121314int distributeCandies(int* candies, int candiesSize) &#123; int *buffer = (int *) calloc(200001, sizeof(int)); int kinds = 0; for (int i = 0; i &lt; candiesSize; i++) &#123; if (buffer[candies[i] + 100000] == 0) &#123; buffer[candies[i] + 100000]++; kinds++; &#125; &#125; free(buffer); return kinds &gt; candiesSize / 2 ? candiesSize / 2 : kinds;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 58. 最后一个单词的长度]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2058.%C2%A0%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述1234567891011给定一个仅包含大小写字母和空格 &apos; &apos; 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。说明：一个单词是指由字母组成，但不包含任何空格的字符串。示例:输入: &quot;Hello World&quot;输出: 5 2、解题思路​ 从后往前，先找到第一个非空格的字符的位置，然后从这个位置开始向前找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;memory.h&gt;#include &lt;string.h&gt;int lengthOfLastWord(char *s) &#123; int result = 0; int pos = strlen(s) - 1; // 找到最后一个非空格的字符位置 while (s[pos] == ' ' &amp;&amp; pos &gt; 0) &#123; pos--; &#125; while (pos &gt;= 0) &#123; if (s[pos] == ' ' || pos &lt; 0) &#123; break; &#125; else if (s[pos] != ' ') &#123; result++; pos--; &#125; &#125; return result;&#125;void print(int x) &#123; int num = 1; for (int i = 31; i &gt;= 0; i--) &#123; if (x &amp; (num &lt;&lt; i)) &#123; printf("1"); &#125; else &#123; printf("0"); &#125; &#125; printf("\n");&#125;int main() &#123; printf("%d\n", lengthOfLastWord("a "));&#125; ​ ​ 略做改进： 123456789101112131415161718192021222324252627int lengthOfLastWord(char* s) &#123; int result = 0; int pos = strlen(s) - 1; bool start_find = false; // 找到最后一个非空格的字符位置 while (pos &gt;= 0) &#123; if(!start_find)&#123; if(s[pos] == ' ' &amp;&amp; pos &gt; 0)&#123; pos--; &#125; else&#123; start_find = true; &#125; &#125;else&#123; if (s[pos] == ' ' || pos &lt; 0) &#123; break; &#125; else if (s[pos] != ' ') &#123; result++; pos--; &#125; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 581. 最短无序连续子数组]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20581.%C2%A0%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例 1: 123输入: [2, 6, 4, 8, 10, 9, 15]输出: 5解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 说明 : 输入的数组长度范围在 [1, 10,000]。 输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。 2、解题思路​ 乍一看，好像没什么思路，实际上，从题意中理解一下，假如我们已经知道了无序的那一段，剩下的就是有序的，也就是说，我虚的这一段肯定是在中间部分，两头的是有序的，也就是说，我们要找一个right，一个left， ​ 该如何找到这个正确的左右界限呢？ ​ 首先，我们从左面向右面扫描，找left，只要遇到了第一个逆序，就将这个位置标记为left，跳出 ​ 这时候，判断left是不是在最后面，如果是，表示整个数组都是有序的，直接返回 ​ 然后从右面找right，遇到第一个逆序，将位置标记位right ​ 接着，我们从left到right中间，找到最大值，最小值 ​ 最小值从0到left寻找，找到他的位置，用这个位置更新left ​ 最大值从length到right寻找，更新right ​ 结果就是right-left 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int findUnsortedSubarray(int* nums, int numsSize) &#123; if (numsSize &lt;= 1) &#123; return 0; &#125; int left = -1; for (int i = 0; i &lt; numsSize - 1; i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; left = i; break; &#125; &#125; // 表示数组是有序的 if (left == -1) &#123; return 0; &#125; int right = numsSize; for (int i = numsSize - 1; i &gt; 0; i--) &#123; if (nums[i] &lt; nums[i - 1]) &#123; right = i; break; &#125; &#125; int min_value = nums[numsSize - 1]; int max_value = nums[0]; for (int i = left; i &lt;= right; i++) &#123; if (nums[i] &lt; min_value) &#123; min_value = nums[i]; &#125; if (nums[i] &gt; max_value) &#123; max_value = nums[i]; &#125; &#125; int real_left = left; int real_right = right; // 确定left 和right真正的位置 for (int i = 0; i &lt;= left; i++) &#123; if (min_value &lt; nums[i]) &#123; real_left = i; break; &#125; &#125; for (int i = numsSize - 1; i &gt;= right; i--) &#123; if (max_value &gt; nums[i]) &#123; real_right = i; break; &#125; &#125; return real_right - real_left + 1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 59. 螺旋矩阵 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2059.%C2%A0%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 1234567输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 2、解题思路​ 这道题与前面的54题，螺旋矩阵相似，实际上，可以用相同的思路实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import numpy as npclass Solution: def generateMatrix(self, n): """ :type n: int :rtype: List[List[int]] """ row = n if row == 0: return [] col = n buff = np.zeros((row + 2, col + 2), dtype=int) for i in range(row + 2): buff[i][0] = 1 buff[i][col + 1] = 1 for i in range(col + 2): buff[0][i] = 1 buff[row + 1][i] = 1 result = [ [0 for i in range(n)] for i in range(n)] """ 方向： 右 0 下 1 左 2 上 3 """ direct = 0 x = 0 y = -1 finish = False index = 1 while not finish: x_temp = x y_temp = y if direct == 0: y += 1 elif direct == 1: x += 1 elif direct == 2: y -= 1 elif direct == 3: x -= 1 if buff[x + 1][y + 1] == 0: result[x][y] = index buff[x + 1][y + 1] = 1 index += 1 else: x = x_temp y = y_temp direct = (direct + 1) % 4 if buff[x_temp][y_temp + 1] == 1 and buff[x_temp + 1][y_temp] == 1 and buff[x_temp + 2][ y_temp + 1] == 1 and buff[x_temp + 1][y_temp + 2] == 1: finish = True return result ​ 虽然通过了，不过耗费时间有点长，换个思路，再来一次 ​ 我们实际上只需要控制转向就可以了，然后判断现在是需要赋值哪些 ​ 首先，我们判断该如何赋值，找出规律 3*3的矩阵 首先是 第一行，坐标为 1230,00,10,2 然后是最右面 121,22,2 然后是下面 122,12,0 再来左面 11，0 接下来又开始 11,1 其中有什么规律呢？ ​ 如果是从左向右走，只会增加纵坐标 ​ 从上往下走，只会增加横坐标 ​ 从右往左走，只会减少横坐标 ​ 从下向上，只会增加纵坐标 于是，我们就可以控制这个了，根据转向，该增加那个坐标， 设置4个变量，控制增加到什么位置结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import numpy as npclass Solution: def generateMatrix(self, n): """ :type n: int :rtype: List[List[int]] """ result = result = [[0] * n for _ in range(n)] """ 方向： 右 0 下 1 左 2 上 3 """ direct = 0 finish = False index = 1 row = 0 col = 0 # 这里直接设置边界，up表示横坐标值，是上面向右寻找，应该是从0到 # right = n - 1 down = n - 1 left = 0 up = 1 while index &lt;= n*n: if direct == 0: for i in range(col, right + 1): result[row][i] = index index += 1 row += 1 col = right right -= 1 direct += 1 elif direct == 1: for i in range(row, down + 1): result[i][col] = index index += 1 row = down col -= 1 down -= 1 direct += 1 elif direct == 2: for i in range(col, left - 1, -1): result[row][i] = index index += 1 row -= 1 col = left left += 1 direct += 1 elif direct == 3: for i in range(row, up - 1, -1): result[i][col] = index index += 1 row = up col += 1 up += 1 direct += 1 direct %= 4 return result ​ 没想到直接赋值，执行是时间也不快，算了，以后在优化，逻辑清晰更重要]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 594. 最长和谐子序列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20594.%C2%A0%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。 现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。 示例 1: 123输入: [1,3,2,2,5,2,3,7]输出: 5原因: 最长的和谐数组是：[3,2,2,2,3]. 说明: 输入的数组长度最大不超过20,000. 2、解题思路​ 看错了题意了，实际上是寻找相邻的两个数，加起来出现的次数最多！ ​ 直接用hashmap做 12345678910111213141516171819202122232425class Solution: def findLHS(self, nums): """ :type nums: List[int] :rtype: int """ hash_num = &#123;&#125; for i in nums: if hash_num.get(i) == None: hash_num[i] = 1 else: hash_num[i] += 1 max_value = 0 for i in hash_num.keys(): value1 = hash_num.get(i,-1) value2 = hash_num.get(i+1,-1) if value1 != -1 and value2 != -1: if max_value &lt; value1 + value2: max_value = value1 + value2 return max_value ​ 实际上，还可以使用collections里面的Counter来做]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 595. 大的国家]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20595.%C2%A0%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述这里有张 World表 123456789+-----------------+------------+------------+--------------+---------------+| name | continent | area | population | gdp |+-----------------+------------+------------+--------------+---------------+| Afghanistan | Asia | 652230 | 25500100 | 20343000 || Albania | Europe | 28748 | 2831741 | 12960000 || Algeria | Africa | 2381741 | 37100000 | 188681000 || Andorra | Europe | 468 | 78115 | 3712000 || Angola | Africa | 1246700 | 20609294 | 100990000 |+-----------------+------------+------------+--------------+---------------+ 如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。 编写一个SQL查询，输出表中所有大国家的名称、人口和地区。 例如，根据上表，我们应该输出: 123456+--------------+-------------+--------------+| name | population | area |+--------------+-------------+--------------+| Afghanistan | 25500100 | 652230 || Algeria | 37100000 | 2381741 |+--------------+-------------+--------------+ 2、解题思路​ 12# Write your MySQL query statement belowselect name , population , area from World where area&gt;3000000 or population &gt; 25000000;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 596. 超过5名学生的课]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20596.%C2%A0%E8%B6%85%E8%BF%875%E5%90%8D%E5%AD%A6%E7%94%9F%E7%9A%84%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述有一个courses 表 ，有: student (学生) 和 class (课程)。 请列出所有超过或等于5名学生的课。 例如,表: 12345678910111213+---------+------------+| student | class |+---------+------------+| A | Math || B | English || C | Math || D | Biology || E | Math || F | Computer || G | Math || H | Math || I | Math |+---------+------------+ 应该输出: 12345+---------+| class |+---------+| Math |+---------+ Note:学生在每个课中不应被重复计算。 2、解题思路123# Write your MySQL query statement belowselect class from courses group by class having count(distinct student)&gt;=5]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 598. 范围求和 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20598.%C2%A0%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8C%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。 操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素 M[i][j] 的值都增加 1。 在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。 示例 1: 123456789101112131415161718192021输入: m = 3, n = 3operations = [[2,2],[3,3]]输出: 4解释: 初始状态, M = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]执行完操作 [2,2] 后, M = [[1, 1, 0], [1, 1, 0], [0, 0, 0]]执行完操作 [3,3] 后, M = [[2, 2, 1], [2, 2, 1], [1, 1, 1]]M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。 注意: m 和 n 的范围是 [1,40000]。 a 的范围是 [1,m]，b 的范围是 [1,n]。 操作数目不超过 10000。 2、解题思路​ 实际上，每一次操作，都是对0-a,0-b之间的数进行增加，那么就很好办了，我们只需要找到所有的操作中，最小的a,b就可以了 ​ 讲真，这道题很无趣 123456789101112131415161718int maxCount(int m, int n, int** ops, int opsRowSize, int opsColSize) &#123; int row = INT32_MAX; int col = INT32_MAX; for (int i = 0; i &lt; opsRowSize; i++) &#123; if (ops[i][0] &lt; row) &#123; row = ops[i][0]; &#125; if (ops[i][1] &lt; col) &#123; col = ops[i][1]; &#125; &#125; row = row &lt; m ? row : m; col = col &lt; n ? col : n; return row * col;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 599. 两个列表的最小索引总和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20599.%C2%A0%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。 示例 1: 12345输入:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]输出: [&quot;Shogun&quot;]解释: 他们唯一共同喜爱的餐厅是“Shogun”。 示例 2: 12345输入:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]输出: [&quot;Shogun&quot;]解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。 提示: 两个列表的长度范围都在 [1, 1000]内。 两个列表中的字符串的长度将在[1，30]的范围内。 下标从0开始，到列表的长度减1。 两个列表都没有重复的元素。 2、解题思路​ 首先对第一个list创建哈希表，然后通过对第二个表遍历，找出最小的索引值之和 ​ 然后遍历一遍，找到索引值之和等于最小索引值之和的那个元素，放到结果list中 12345678910111213141516171819202122232425262728293031class Solution: def findRestaurant(self, list1, list2): """ :type list1: List[str] :type list2: List[str] :rtype: List[str] """ result = [] hash_list = &#123;&#125; index = 0; min_index = 2001; for i in list1: hash_list[i] = index; index += 1 index = 0; for i in list2: if hash_list.get(i) != None : if hash_list.get(i) + index &lt; min_index: min_index = hash_list.get(i) + index index += 1 index = 0; for i in list2: if hash_list.get(i) != None and hash_list.get(i) + index == min_index: result.append(i) index += 1 return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6. Z字形变换]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%206.%C2%A0Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[[TOC] 1ZigZag变换，是一种打乱顺序的方式 1、题目要求123456789101112131415161718192021222324The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows:string convert(string s, int numRows);Example 1:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;Example 2:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I 将字符串 &quot;PAYPALISHIRING&quot; 以Z字形排列成给定的行数： 123P A H NA P L S I I GY I R 之后从左往右，逐行读取字符：&quot;PAHNAPLSIIGYIR&quot; 实现一个将字符串进行指定行数变换的函数: 1string convert(string s, int numRows); 示例 1: 12输入: s = &quot;PAYPALISHIRING&quot;, numRows = 3输出: &quot;PAHNAPLSIIGYIR&quot; 示例 2: 12345678输入: s = &quot;PAYPALISHIRING&quot;, numRows = 4输出: &quot;PINALSIGYAHRPI&quot;解释:P I NA L S I GY A H RP I 2、解题思路2.1 依次写入法​ 如果有5行，则准备5个缓冲，将不同的字符依次放入不同的缓冲，然后从第一个开始，依次取出即可得到 2.2 移位写入法​ 行号 1 0 4 8 2 1 3 5 7 9 3 2 6 10 ​ 根据上面的写法，数据第一行的，下标间隔为4，第2行讲个为2，第三行间隔为4 行 1 0 8 2 1 7 9 3 2 6 10 4 3 5 11 5 4 12 ​ 再根据上面的表格， 第一行间隔为：8 第二行间隔为：6，2 第三行间隔为：4，4 第四行间隔为：2，6 第五行间隔为：8 ​ 根据上面的规律，可以看到，如果每一行都看成是两个间隔，就能统一，除去第一行与最后一行，如下改一下，就可以得到每一次移动的下标数； 第一行间隔为：8，8 第二行间隔为：6，2 第三行间隔为：4，4 第四行间隔为：2，6 第五行间隔为：8，8 123456789101112131415161718192021222324252627282930313233343536char *convert(char *s, int numRows) &#123; int i = 0, moves[2]; int result_pos = 0; int source_pos; int length = 0; int count = 0; while (s[i++]) &#123; length++; &#125; i = 0; char *result = (char *) malloc(sizeof(char) * length + 1); if (numRows &lt;= 1) &#123; while (i &lt;= length) &#123; result[i] = s[i]; i++; &#125; return result; &#125; for (i = 0; i &lt; numRows; i++) &#123; if (i == 0 || i == (numRows - 1)) &#123; moves[0] = moves[1] = (numRows - 1) * 2; &#125; else &#123; moves[0] = (numRows - 1) * 2 - 2 * i; moves[1] = 2 * i; &#125; source_pos = i; count = 0; while (source_pos &lt; length) &#123; result[result_pos++] = s[source_pos]; source_pos += moves[(count++) % 2]; &#125; &#125; result[length] = '\0'; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 60. 第k个排列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2060.%C2%A0%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给出集合 [1,2,3,…,*n*]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： &quot;123&quot; &quot;132&quot; &quot;213&quot; &quot;231&quot; &quot;312&quot; &quot;321&quot; 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例 1: 12输入: n = 3, k = 3输出: &quot;213&quot; 示例 2: 12输入: n = 4, k = 9输出: &quot;2314&quot; 2、解题思路​ 这一个实际上我们能够直接计算出来 1 2 3 例如，我们想要得到第1个 首先，算出第一位，1/3= 0 因此，得到下标为0的数,也就是1，将1从原数组中移除 第二位，0%3 = 0 第二位，0/2 = 0，继续取下标为0的数，2，并将2移除 不断的计算，最终得到想要的结果 假设缓冲数组是 1[1 2 3] 结果数组为 1[] 想要求第1个 第一步，缓冲数组和结果数组为 12[2 3][1] 第二步，缓冲数组和结果数组为 12[3][1 2] 第三步，缓冲数组和结果数组为 12[][1 2 3] 实际上，求结果数组的第一位，我们要用要求的第几个 1234567891011121314151617181920212223242526class Solution: def getPermutation(self, n, k): """ :type n: int :type k: int :rtype: str """ bits_order = [0] * (n - 1) for i in range(1, n): if i == 1: bits_order[i - 1] = i else: bits_order[i - 1] = i * bits_order[i - 2] bits_order = list(reversed(bits_order)) buff = [i for i in range(1, n + 1)] result = [] for i in range(n - 1): index = (k-1) // bits_order[i] result.append(buff[index]) buff.pop(index) k %= bits_order[i] result.append(buff[0]) return "".join([chr(i+48) for i in result])]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 601. 体育馆的人流量]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20601.%C2%A0%E4%BD%93%E8%82%B2%E9%A6%86%E7%9A%84%E4%BA%BA%E6%B5%81%E9%87%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (date)、 人流量 (people)。 请编写一个查询语句，找出高峰期时段，要求连续三天及以上，并且每天人流量均不少于100。 例如，表 stadium： 123456789101112+------+------------+-----------+| id | date | people |+------+------------+-----------+| 1 | 2017-01-01 | 10 || 2 | 2017-01-02 | 109 || 3 | 2017-01-03 | 150 || 4 | 2017-01-04 | 99 || 5 | 2017-01-05 | 145 || 6 | 2017-01-06 | 1455 || 7 | 2017-01-07 | 199 || 8 | 2017-01-08 | 188 |+------+------------+-----------+ 对于上面的示例数据，输出为： 12345678+------+------------+-----------+| id | date | people |+------+------------+-----------+| 5 | 2017-01-05 | 145 || 6 | 2017-01-06 | 1455 || 7 | 2017-01-07 | 199 || 8 | 2017-01-08 | 188 |+------+------------+-----------+ Note:每天只有一行记录，日期随着 id 的增加而增加。 2、解题思路​ 1234567891011121314# Write your MySQL query statement belowselect distinct s1.* from stadium s1, stadium s2, stadium s3 where s1.people &gt;= 100 and s2.people &gt;= 100 and s3.people &gt;=100 and ((s1.id - s2.id = 1 and s2.id - s3.id =1) or (s2.id - s1.id = 1 and s1.id - s3.id =1) or (s3.id - s2.id = 1 and s2.id - s1.id = 1) )order by s1.date asc]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 605. 种花问题]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20605.%C2%A0%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 示例 1: 12输入: flowerbed = [1,0,0,0,1], n = 1输出: True 示例 2: 12输入: flowerbed = [1,0,0,0,1], n = 2输出: False 注意: 数组内已种好的花不会违反种植规则。 输入的数组长度范围为 [1, 20000]。 n 是非负整数，且不会超过输入数组的大小。 2、解题思路​ 实际上很简单，我们判断有多少个连续的0，然后判断连续的0的左右边界，如果左边界是1，右边界也是1，那么能够种下的花的数量要根据边界进行计算 ​ 例如，左边界是1，右边界是1，0的数量是3 ​ 能够种下的花的数量是1 ​ 如果0的数量是2，能够种下花的数量是0 ​ 实际上是（0的数量-左边界-右边界）/2 的值 ​ 考虑到奇偶数的问题，最终结果应该是： （0的数量-左边界-右边界 +1）/2 的值 1234567891011121314151617181920212223242526272829303132333435363738394041bool canPlaceFlowers(int* flowerbed, int flowerbedSize, int n) &#123; int left = 0; int zero_nums = 0; int result = 0; bool start_count = false; for (int i = 0; i &lt; flowerbedSize; i++) &#123; if (!start_count) &#123; if (flowerbed[i] == 0) &#123; start_count = true; zero_nums++; if (i == 0) &#123; left = 0; &#125; else &#123; left = 1; &#125; &#125; &#125; else &#123; if (flowerbed[i] == 0) &#123; zero_nums++; &#125; else &#123; result += (zero_nums - left) / 2; left = 0; zero_nums = 0; start_count = false; &#125; &#125; &#125; if (flowerbed[flowerbedSize - 1] == 0) &#123; result += (zero_nums - left + 1) / 2; &#125; if (result &gt;= n) &#123; return true; &#125; else &#123; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 606. 根据二叉树创建字符串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20606.%C2%A0%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。 空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。 示例 1: 123456789101112输入: 二叉树: [1,2,3,4] 1 / \ 2 3 / 4 输出: &quot;1(2(4))(3)&quot;解释: 原本将是“1(2(4)())(3())”，在你省略所有不必要的空括号对之后，它将是“1(2(4))(3)”。 示例 2: 1234567891011输入: 二叉树: [1,2,3,null,4] 1 / \ 2 3 \ 4 输出: &quot;1(2()(4))(3)&quot;解释: 和第一个示例相似，除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。 2、解题思路​ 12]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 61. 旋转链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2061.%C2%A0%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 12345输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2: 1234567输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 2、解题思路​ 这个链表旋转实在是很简单的题目，如果将链表头尾相连，直接然后找到尾部，加上NULL，返回头部指针就可以了 ​ 需要注意的就是，如果旋转长度超过了链表长度，我们需要取余处理 在前面，19题，删除链表的倒数第N个节点中，我们使用了双指针来找到第N个需要删除的节点，这里也是这样做 ​ 第一个指针先走n步，然后第二个指针走到头，这样我们就得到了倒数第n个元素，将这个元素设为头指针，然后将尾部与头部相连，就可以了 ​ 需要注意的就是边界条件 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not head: return head first = head second = head total = 0 temp = head temp_k = k result = None while temp_k &gt; 0 and temp: temp = temp.next temp_k -= 1 if temp_k == 0 and temp is None: return head if temp_k == 0 and temp is not None: first = temp if temp_k &gt; 0 and temp is None: total = k - temp_k temp_k = k % total while temp_k &gt; 0: first = first.next temp_k -= 1 while first.next: first = first.next second = second.next first.next = head result = second.next second.next = None return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 617. 合并二叉树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20617.%C2%A0%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 1234567891011121314输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。 2、解题思路# 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */struct TreeNode* mergeTrees(struct TreeNode* t1, struct TreeNode* t2) &#123; if (!t1 &amp;&amp; !t2) &#123; return NULL; &#125; else if (!t1) &#123; return t2; &#125; else if (!t2) &#123; return t1; &#125; else &#123; t1-&gt;val = t1-&gt;val + t2-&gt;val; t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left); t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right); &#125; return t1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 62. 不同路径]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2062.%C2%A0%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：*m 和 n* 的值均不超过 100。 示例 1: 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m = 7, n = 3输出: 28 2、解题思路​ 这个题目是有规律的，我们仔细观察，能够看到，方格的列值，例如7*3，也就是说机器人可以向下走两次， 那么机器人第一步可能怎么走呢？ ​ 如果直接向右，也就是向下走了0步，还需要向下走两步 ​ 如果向下走了一步，在剩下的格子里，还需要走一步 ​ 如果向下走了2步，表示只能向右走 ​ 直观的，这道题可以用动态规划来做，如何做呢，比如，在第一行，机器人直接向右走，只有一条道 ​ 如果机器人直接向下走，也是只有一一条道 ​ 但是，其他的位置，都能由上面，和左面走过来，也就是其他的位置都是上面与左面之和 以7*3为例 0 1 1 1 1 1 1 1 2 3 4 5 6 7 1 3 6 10 15 21 28 ​ 从上面的表格可以看到，每个位置对应的路径条数，最终的位置就是想要求解的 123456789101112131415161718192021222324class Solution: def uniquePaths(self, m, n): """ :type m: int :type n: int :rtype: int """ if m == 1 and n == 1: return 1 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(1, m): dp[0][i] = dp[0][i - 1] for i in range(1, n): dp[i][0] = dp[i - 1][0] for i in range(1, n): for j in range(1, m): dp[i][j] = dp[i][j - 1] + dp[i - 1][j] return dp[n - 1][m - 1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 620. 有趣的电影]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20620.%C2%A0%E6%9C%89%E8%B6%A3%E7%9A%84%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。 作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。 例如，下表 cinema: 123456789+---------+-----------+--------------+-----------+| id | movie | description | rating |+---------+-----------+--------------+-----------+| 1 | War | great 3D | 8.9 || 2 | Science | fiction | 8.5 || 3 | irish | boring | 6.2 || 4 | Ice song | Fantacy | 8.6 || 5 | House card| Interesting| 9.1 |+---------+-----------+--------------+-----------+ 对于上面的例子，则正确的输出是为： 123456+---------+-----------+--------------+-----------+| id | movie | description | rating |+---------+-----------+--------------+-----------+| 5 | House card| Interesting| 9.1 || 1 | War | great 3D | 8.9 |+---------+-----------+--------------+-----------+ 2、解题思路​ 123# Write your MySQL query statement belowselect * from cinema where description != "boring" and id %2 =1 order by rating DESC]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 626. 换座位]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20626.%C2%A0%E6%8D%A2%E5%BA%A7%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。 其中纵列的 id 是连续递增的 小美想改变相邻俩学生的座位。 你能不能帮她写一个 SQL query 来输出小美想要的结果呢？ 示例： 123456789+---------+---------+| id | student |+---------+---------+| 1 | Abbot || 2 | Doris || 3 | Emerson || 4 | Green || 5 | Jeames |+---------+---------+ 假如数据输入的是上表，则输出结果如下： 123456789+---------+---------+| id | student |+---------+---------+| 1 | Doris || 2 | Abbot || 3 | Green || 4 | Emerson || 5 | Jeames |+---------+---------+ 注意： 如果学生人数是奇数，则不需要改变最后一个同学的座位。 2、解题思路​ ​ 首先通过判断当前id是不是奇数，如果是，当前id+1是不是大于最大id，如果大于，使用当前id， ​ 如果不大于，是奇数，就用id+1，是偶数，就直接使用id-1，最后在使用一下升序排列 123# Write your MySQL query statement belowselect if(if(id%2,id+1,id-1)&gt; (select max(id) from seat), id, if (id%2,id+1,id-1) ) as id ,student from seat order by id asc]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 627. 交换工资]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20627.%C2%A0%E4%BA%A4%E6%8D%A2%E5%B7%A5%E8%B5%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个 salary表，如下所示，有m=男性 和 f=女性的值 。交换所有的 f 和 m 值(例如，将所有 f 值更改为 m，反之亦然)。要求使用一个更新查询，并且没有中间临时表。 例如: 123456| id | name | sex | salary ||----|------|-----|--------|| 1 | A | m | 2500 || 2 | B | f | 1500 || 3 | C | m | 5500 || 4 | D | f | 500 | 运行你所编写的查询语句之后，将会得到以下表: 123456| id | name | sex | salary ||----|------|-----|--------|| 1 | A | f | 2500 || 2 | B | m | 1500 || 3 | C | f | 5500 || 4 | D | m | 500 | 2、解题思路12# Write your MySQL query statement belowupdate salary set sex = if(sex=&apos;m&apos;,&apos;f&apos;,&apos;m&apos;)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 628. 三个数的最大乘积]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20628.%C2%A0%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1: 12输入: [1,2,3]输出: 6 示例 2: 12输入: [1,2,3,4]输出: 24 注意: 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。 2、解题思路2.1 排序法​ 首先提议总是要得到最大的3个数的乘积，数据都是整型，因此，就会有两种情况 ​ 三个都是正数，2个负数一个正数 ​ 简单的做法，直接排序，然后判断一下就好了 ​ 123456789101112131415int cmp(int *a, int *b) &#123; return *a - *b;&#125;int maximumProduct(int *nums, int numsSize) &#123; qsort(nums, numsSize, sizeof(int), cmp); int result_left = nums[0] * nums[1] * nums[numsSize - 1]; int result_right = nums[numsSize - 3] * nums[numsSize - 2] * nums[numsSize - 1]; return result_left &gt; result_right ? result_left : result_right;&#125; 2.2 遍历法​ 通过遍历，找出最小的两个和最大的三个，比较最小的两个与最大的那个的乘积 与最大的3个数的乘积]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 629. K个逆序对数组]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20629.%C2%A0K%E4%B8%AA%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。 逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i &lt; j且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。 由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。 示例 1: 1234输入: n = 3, k = 0输出: 1解释: 只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。 示例 2: 1234输入: n = 3, k = 1输出: 2解释: 数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。 说明: n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。 2、解题思路​ 实际上，这个题目能够计算出来 ​ ​ 在1-n，有n个数字，最多有多少逆序对？ ​ 如果全部是逆序，第一个元素，n-1个，第二个元素，n-2个，以此类推 ​ 所以一共是n*（n-1）/2 个 ​ 实际上，我们可以使用动态规划来解决这个问题 n\k 0 1 2 3 4 5 6 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 2 1 1 0 0 0 0 0 3 1 2 2 1 0 0 0 4 1 5 1 6 1 7 1 假设n=5，已经知道n=4时的值， 那么添加一个5，可以得到下面的几种情况 xxxx5 不增加逆序对 xxx5x 增加1个逆序对 xx5xx 增加2个逆序对 x5xxx 增加3个逆序对 5xxxx 增加4个逆序对 那么，(5,k) = (4,k)+(4,k-1)+(4,k-2)+…+(4,k-(n-1)) 不过，这样的计算量有点大，每一次，都要对前面多个进行加和计算 下面来进行一下优化 123456789101112131415dp[n][k] = dp[n - 1][k] + dp[n - 1][k-1] + ... + dp[n - 1][k - n + 1]用k+1代替k，得到：dp[n][k+1] = dp[n - 1][k+1] + dp[n - 1][k] + ... + dp[n - 1][k + 1 - n + 1]用第二个等式减去第一个等式得到：dp[n][k+1] = dp[n][k] + dp[n - 1][k+1] - dp[n - 1][k - n + 1]将k+1换回成k，可以得到：dp[n][k] = dp[n][k-1] + dp[n - 1][k] - dp[n - 1][k - n]第三项，只有当k&gt;=n的时候，才会有值，所以分情况讨论即可 前面要求是$10^9+7​$, 直接计算出来，也就是1000000007 123456789101112131415161718192021222324int kInversePairs(int n, int k) &#123; int m = 1000000007; int dp[n + 1][k + 1]; // 初始化, 所有的取0个逆序对的情况都只有一种 for (int i = 0; i &lt;= n; i++) &#123; dp[i][0] = 1; &#125; // 当有0个元素的时候，逆序对大于1的情况都是0 for (int i = 1; i &lt;= k; i++) &#123; dp[0][i] = 0; &#125; // 开始为计算所有的dp元素 for (int row_n = 1; row_n &lt;= n; row_n++) &#123; for (int col_k = 1; col_k &lt;= k; col_k++) &#123; dp[row_n][col_k] = (dp[row_n - 1][col_k] + dp[row_n][col_k - 1]) % m; if (col_k &gt;= row_n) &#123; dp[row_n][col_k] = (dp[row_n][col_k] - dp[row_n - 1][col_k - row_n] + m) % m; &#125; &#125; &#125; return dp[n][k];&#125; ​ 这里有一点需要注意的就是，]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 63. 不同路径 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2063.%C2%A0%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：*m 和 n* 的值均不超过 100。 示例 1: 123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 2、解题思路​ 这道题和前面的62题区别不大，同样是动态规划，区别是，遇到障碍物，当前节点的路径值直接置0即可，其他的不变 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def uniquePathsWithObstacles(self, obstacleGrid): """ :type obstacleGrid: List[List[int]] :rtype: int """ dp = [obstacleGrid[i][:] for i in range(len(obstacleGrid))] row = len(dp) col = len(dp[0]) if row == 1 and col == 1: if dp[0][0] == 1: return 0 else: return 1 if dp[0][0] == 1: dp[0][0] = 0 else: dp[0][0] = 1 for i in range(1, col): if dp[0][i] == 1: dp[0][i] = 0 else: dp[0][i] = dp[0][i - 1] for i in range(1, row): if dp[i][0] == 1: dp[i][0] = 0 else: dp[i][0] = dp[i - 1][0] for i in range(1, row): for j in range(1, col): if dp[i][j] == 1: dp[i][j] = 0 else: dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[row - 1][col - 1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 633. 平方数之和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20633.%C2%A0%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。 示例1: 123输入: 5输出: True解释: 1 * 1 + 2 * 2 = 5 示例2: 12输入: 3输出: False 2、解题思路123456789101112131415161718192021bool judgeSquareSum(int c) &#123; int left = 0; int right = c ; double temp; for (int i = left; i &lt;= right; i++) &#123; temp = sqrt(c - pow(i, 2)); if (temp == (int) temp) &#123; if (c - pow(i, 2) == pow(temp,2)) &#123; return true; &#125; &#125; else &#123; right = c - pow(i, 2); &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 637. 二叉树的层平均值]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20637.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非空二叉树, 返回一个由每层节点平均值组成的数组. 示例 1: 123456789输入: 3 / \ 9 20 / \ 15 7输出: [3, 14.5, 11]解释:第0层的平均值是 3, 第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11]. 注意： 节点值的范围在32位有符号整数范围内。 2、解题思路123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Nonefrom queue import Queueclass Solution: def averageOfLevels(self, root): """ :type root: TreeNode :rtype: List[float] """ if root is None: return []; q = Queue() q.put(root) result = [] while not q.empty(): nums = q.qsize() sums = 0 for i in range(nums): node = q.get() sums += node.val if node.left is not None: q.put(node.left) if node.right is not None: q.put(node.right) result.append(sums / nums) return result ​ 有看了一个别人的思路，果然python理解的还不够好 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Nonefrom queue import Queueclass Solution: def averageOfLevels(self, root): """ :type root: TreeNode :rtype: List[float] """ if root is None: return []; row = [root] result = [] while any(row): result.append(sum([v.val for v in row]) / len(row)) row = [sub for node in row for sub in (node.left, node.right) if sub] return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 64. 最小路径和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2064.%C2%A0%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、解题思路给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 2、题目描述​ 这道题看起来与前面62，63题没什么区别，都是从右上角到右下角，不过这一个求解最少的路径花费，简单的做法就是贪心法，每一步都选最小花费的那个，最终得到的就是最小花费 ​ 12345678910111213141516171819class Solution: def minPathSum(self, grid): """ :type grid: List[List[int]] :rtype: int """ row = len(grid) col = len(grid[0]) for i in range(row): for j in range(col): if i - 1 &gt;= 0 and j - 1 &gt;= 0: grid[i][j] = min(grid[i][j - 1], grid[i - 1][j]) + grid[i][j] elif i - 1 &gt;= 0: grid[i][j] = grid[i - 1][j] + grid[i][j] elif j - 1 &gt;= 0: grid[i][j] = grid[i][j - 1] + grid[i][j] return grid[row - 1][col - 1] ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 643. 子数组最大平均数 I]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20643.%C2%A0%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0%20I%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。 示例 1: 123输入: [1,12,-5,-6,50,3], k = 4输出: 12.75解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 注意: 1 &lt;= k &lt;= n &lt;= 30,000。 所给数据范围 [-10,000，10,000]。 2、解题思路​ 从左面向右扫描一遍即可 ​ 12345678910111213141516171819202122232425double findMaxAverage(int* nums, int numsSize, int k) &#123; double result = INT32_MIN; double sum = 0; bool first = true; for (int i = 0; i &lt;= numsSize - k; i++) &#123; if (first) &#123; for (int j = i; j &lt; i + k; j++) &#123; sum += nums[j]; &#125; first = false; &#125; else &#123; sum -= nums[i - 1]; sum += nums[i + k - 1]; &#125; if (sum / k &gt; result) &#123; result = sum / k; &#125; &#125; return result;&#125; ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 645. 错误的集合]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20645.%C2%A0%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。 给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。 示例 1: 12输入: nums = [1,2,2,4]输出: [2,3] 注意: 给定数组的长度范围是 [2, 10000]。 给定的数组是无序的。 2、解题思路​ 前面做过一道类似的题目，我们直接让对应的数，让其下标加一个负号，如果发现某一个下标已经是负号的时候，这个元素就是重复元素 ​ 唯一的一个正元素的下表加1，就是缺失元素 ​ 解题思路与448题相似 123456789101112131415161718192021222324252627/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* findErrorNums(int* nums, int numsSize, int* returnSize) &#123; int *result = (int *) malloc(sizeof(int) * 2); *returnSize = 2; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[abs(nums[i]) - 1] &gt; 0) &#123; nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1]; &#125; else &#123; result[0] = abs(nums[i]); &#125; &#125; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i] &gt; 0) &#123; result[1] = i + 1; break; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 653. 两数之和 IV - 输入 BST]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20653.%C2%A0%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20IV%20-%20%E8%BE%93%E5%85%A5%20BST%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。 案例 1: 12345678910输入: 5 / \ 3 6 / \ \2 4 7Target = 9输出: True 案例 2: 12345678910输入: 5 / \ 3 6 / \ \2 4 7Target = 28输出: False 2、解题思路​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */bool findValue(struct TreeNode *root, int value, struct TreeNode *current) &#123; if (!root) &#123; return false; &#125; // 不是当前节点，并且值是要找的值 // 规避了两倍的情况 if (current != root &amp;&amp; root-&gt;val == value) &#123; return true; &#125; return findValue(root-&gt;left, value, current) || findValue(root-&gt;right, value, current);&#125;bool find_Target(struct TreeNode *current, struct TreeNode *root, int k) &#123; if (!current) &#123; return false; &#125; bool result = false; int tar = k - current-&gt;val; result = result || findValue(root, tar, current) || findValue(root, tar, current); return result || find_Target(current-&gt;left, root, k) || find_Target(current-&gt;right, root, k);&#125;bool findTarget(struct TreeNode *root, int k) &#123; if (!root) &#123; return false; &#125; return find_Target(root, root, k);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 657. 判断路线成圈]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20657.%C2%A0%E5%88%A4%E6%96%AD%E8%B7%AF%E7%BA%BF%E6%88%90%E5%9C%88%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述初始位置 (0, 0) 处有一个机器人。给出它的一系列动作，判断这个机器人的移动路线是否形成一个圆圈，换言之就是判断它是否会移回到原来的位置。 移动顺序由一个字符串表示。每一个动作都是由一个字符来表示的。机器人有效的动作有 R（右），L（左），U（上）和 D（下）。输出应为 true 或 false，表示机器人移动路线是否成圈。 示例 1: 12输入: &quot;UD&quot;输出: true 示例 2: 12输入: &quot;LL&quot;输出: false 2、题目解析​ 这个题的意思就是，是不是最终回到原点，感觉好傻的题，有种侮辱智商的感觉了 12345678910111213141516171819202122232425262728bool judgeCircle(char* moves) &#123; int x = 0; int y = 0; char *temp = moves; while (*temp) &#123; switch (*temp) &#123; case 'R': x++; break; case 'L': x--; break; case 'U': y++; break; case 'D': y--; break; &#125; temp++; &#125; return x == 0 &amp;&amp; y == 0; &#125; ​ 确认了一个问题，用if判断，比起switch，速度慢很多 。。。 1234567891011121314151617181920212223class Solution: def judgeCircle(self, moves): """ :type moves: str :rtype: bool """ x = 0 y = 0 for i in moves: if i == 'R': y += 1 if i == 'L': y -= 1 if i == 'U': x += 1 if i == 'D': x -= 1 if x == 0 and y == 0: return True return False 12345678class Solution: def judgeCircle(self, moves): """ :type moves: str :rtype: bool """ return moves.count('R') == moves.count('L') and moves.count('U') == moves.count('D')]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 66.加一]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2066.%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非负整数组成的非空数组，在该数的基础上加一，返回一个新的数组。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 2、解题思路​ 首先判断数组是不是需要扩展一位 ​ 然后申请空间 ​ 从尾部开始计算，遇到9，并且进位为1，则赋值0，并且进位仍为1 1234567891011121314151617181920212223242526272829303132333435/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* plusOne(int* digits, int digitsSize, int* returnSize) &#123; int length = digitsSize; int extend = 1; int carry = 1; for (int i = 0; i &lt; digitsSize; i++) &#123; if (digits[i] != 9) &#123; extend = 0; break; &#125; &#125; if (extend == 1) &#123; length++; &#125; int *result = (int *) malloc(sizeof(int) * length); for (int i = length - 1; (i-extend) &gt;= 0; i--) &#123; if (digits[i - extend] == 9 &amp;&amp; carry == 1) &#123; result[i] = 0; &#125; else &#123; result[i] = digits[i - extend] + carry; carry = 0; &#125; &#125; if (extend == 1) &#123; result[0] = 1; &#125; *returnSize = length; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 661. 图片平滑器]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20661.%C2%A0%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。 示例 1: 123456789101112输入:[[1,1,1], [1,0,1], [1,1,1]]输出:[[0, 0, 0], [0, 0, 0], [0, 0, 0]]解释:对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0 注意: 给定矩阵中的整数范围为 [0, 255]。 矩阵的长和宽的范围均为 [1, 150]。 2、解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *columnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** imageSmoother(int** M, int MRowSize, int MColSize, int** columnSizes, int* returnSize) &#123; *columnSizes = (int *) malloc(sizeof(int) * MRowSize); *returnSize = MRowSize; for (int i = 0; i &lt; MRowSize; i++) &#123; (*columnSizes)[i] = MColSize; &#125; int sum = 0; int count = 0; int **result = (int **) malloc(sizeof(int *) * MRowSize); int *cur_line; int row; int col; for (int i = 0; i &lt; MRowSize; i++) &#123; cur_line = (int *) malloc(sizeof(int) * MColSize); result[i] = cur_line; for (int j = 0; j &lt; MColSize; j++) &#123; sum = 0; count = 0; for (int k = 0; k &lt; 9; k++) &#123; row = i - 1 + k / 3; col = j - 1 + k % 3; if (row &gt;= 0 &amp;&amp; row &lt; MRowSize &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; MColSize) &#123; sum += M[row][col]; count++; &#125; &#125; result[i][j] = sum / count; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 665. 非递减数列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20665.%C2%A0%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。 示例 1: 123输入: [4,2,3]输出: True解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例 2: 123输入: [4,2,1]输出: False解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 说明: n 的范围为 [1, 10,000]。 2、解题思路​ 设置两个指针，左面和右面的指向了左面第一个减小的位置，右面指向了右面第一个减小的位置 判断这两个中间，有几次递减机会，超过一次，返回false 如果只有一次，找出中间的最大值，最小值 最小值和左面的值进行比较，如果小于，并且最大值和右面的一个值比较，如果大于，这种情况是不可以的，返回false 其他的都是true 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556bool checkPossibility(int* nums, int numsSize) &#123; int left_pos = 0; int right_pos = numsSize - 1; for (int i = 0; i &lt; numsSize - 1; i++) &#123; if (nums[i + 1] &lt; nums[i]) &#123; left_pos = i; break; &#125; &#125; if (left_pos == numsSize - 1) &#123; return true; &#125; for (int i = numsSize - 1; i &gt; 0; i--) &#123; if (nums[i - 1] &gt; nums[i]) &#123; right_pos = i; break; &#125; &#125; // 找到区间的最大最小值 int max = INT32_MIN; int min = INT32_MAX; int count = 0; for (int i = left_pos; i &lt;= right_pos; i++) &#123; if (nums[i] &gt; max) &#123; max = nums[i]; &#125; if (nums[i] &lt; min) &#123; min = nums[i]; &#125; if (i + 1 &lt;= right_pos &amp;&amp; nums[i + 1] &lt; nums[i]) &#123; count++; &#125; &#125; if (count &gt;= 2) &#123; return false; &#125; if (left_pos &gt; 0 &amp;&amp; right_pos &lt; numsSize - 1) &#123; if (max &gt; nums[right_pos + 1] &amp;&amp; min &lt; nums[left_pos - 1]) &#123; return false; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 669. 修剪二叉搜索树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20669.%C2%A0%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。 示例 1: 123456789101112输入: 1 / \ 0 2 L = 1 R = 2输出: 1 \ 2 示例 2: 123456789101112131415161718输入: 3 / \ 0 4 \ 2 / 1 L = 1 R = 3输出: 3 / 2 / 1 2、解题思路123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */struct TreeNode* trimBST(struct TreeNode* root, int L, int R) &#123; if (!root) &#123; return NULL; &#125; if (root-&gt;val &gt;= L &amp;&amp; root-&gt;val &lt;= R) &#123; root-&gt;left = trimBST(root-&gt;left, L, R); root-&gt;right = trimBST(root-&gt;right, L, R); &#125; else if (root-&gt;val &gt; R) &#123; root = trimBST(root-&gt;left, L, R); &#125; else &#123; root = trimBST(root-&gt;right, L, R); &#125; return root;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 67.二进制求和]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2067.%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 2、解题思路​ 两个二进制相加，要么进位1，要不不进位，进位的可能性比较大， ​ 首先创建一个结果数组，考虑到进位，因此数组长度比起两个二进制数要大一 ​ 从后向前判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172char* addBinary(char* a, char* b) &#123; int length_a = strlen(a); int length_b = strlen(b); int result_length = length_a &gt; length_b ? length_a : length_b; // 默认认为有一个进位 result_length++; int carry = 0; char *result = (char *) malloc(sizeof(char) * result_length + 1); result[result_length] = '\0'; for (int i = 0; i &lt; result_length - 1; i++) &#123; result[result_length - 1 - i] = '0'; if (length_a - 1 - i &gt;= 0) &#123; result[result_length - 1 - i] = a[length_a - 1 - i]; &#125; if (length_b - 1 - i &gt;= 0) &#123; if (carry == 0) &#123; if (b[length_b - 1 - i] == result[result_length - 1 - i]) &#123; if (result[result_length - 1 - i] == '1') &#123; carry = 1; result[result_length - 1 - i] = '0'; &#125; else &#123; carry = 0; result[result_length - 1 - i] = '0'; &#125; &#125; else &#123; result[result_length - 1 - i] = '1'; &#125; &#125; else &#123; if (b[length_b - 1 - i] == result[result_length - 1 - i]) &#123; if (result[result_length - 1 - i] == '1') &#123; carry = 1; result[result_length - 1 - i] = '1'; &#125; else &#123; carry = 0; result[result_length - 1 - i] = '1'; &#125; &#125; else &#123; carry = 1; result[result_length - 1 - i] = '0'; &#125; &#125; &#125; else &#123; if (carry == 1) &#123; if (result[result_length - 1 - i] == '1') &#123; result[result_length - 1 - i] = '0'; carry = 1; &#125; else &#123; carry = 0; result[result_length - 1 - i] = '1'; &#125; &#125; &#125; &#125; if (carry == 1 &amp;&amp; result_length &gt; length_a &amp;&amp; result_length &gt; length_b) &#123; result[0] = '1'; &#125; else &#123; result = &amp;result[1]; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 671. 二叉树中第二小的节点]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20671.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。 示例 1: 123456789输入: 2 / \ 2 5 / \ 5 7输出: 5说明: 最小的值是 2 ，第二小的值是 5 。 示例 2: 1234567输入: 2 / \ 2 2输出: -1说明: 最小的值是 2, 但是不存在第二小的值。 2、解题思路​ 注意，这里是第二小，不是第二大。。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */void find_Second(struct TreeNode *root, int *max_min, int *second) &#123; if (!root) &#123; return; &#125; if (root-&gt;val &lt; *max_min) &#123; *second = *max_min; *max_min = root-&gt;val; &#125; else if (root-&gt;val &gt; *max_min)&#123; if (root-&gt;val &lt; *second) &#123; *second = root-&gt;val; &#125; &#125; find_Second(root-&gt;left, max_min, second); find_Second(root-&gt;right, max_min, second);&#125;int findSecondMinimumValue(struct TreeNode *root) &#123; if (!root) &#123; return -1; &#125; int max_min = INT32_MAX; int second = INT32_MAX; find_Second(root, &amp;max_min, &amp;second); if(second == INT32_MAX)&#123; return -1; &#125; return second;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 674. 最长连续递增序列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20674.%C2%A0%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个未经排序的整数数组，找到最长且连续的的递增序列。 示例 1: 1234输入: [1,3,5,4,7]输出: 3解释: 最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 示例 2: 123输入: [2,2,2,2,2]输出: 1解释: 最长连续递增序列是 [2], 长度为1。 注意：数组长度不会超过10000。 2、解题思路​ ​ 注意理解题意，一开始想的有点复杂了，只要是升序就可以，一开始还以为必须是间隔相同的升序 123456789101112131415161718192021int findLengthOfLCIS(int* nums, int numsSize) &#123; if (numsSize &lt;= 1) &#123; return numsSize; &#125; int left = 0; int result = 0; int current_interval; for (int i = 0; i &lt; numsSize - 1; i++) &#123; current_interval = nums[i + 1] - nums[i]; if (current_interval &lt;= 0) &#123; result = result &gt; i - left + 1 ? result : i - left + 1; left = i + 1; &#125; &#125; result = result &gt; numsSize - left ? result : numsSize - left; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 680. 验证回文字符串 Ⅱ]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20680.%C2%A0%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E2%85%A1%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 12输入: &quot;aba&quot;输出: True 示例 2: 123输入: &quot;abca&quot;输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 2、解题思路​ 先找出第一个不相等的位置，然后分成两种情况，删掉左面的字符，删掉右面的字符，分别判断，如果都不是回文串，返回假 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657bool validPalindrome(char* s) &#123; int left1 = 0; int right1 = 0; int left2 = 0; int right2 = 0; int length = strlen(s); int interval = 0; for (int i = 0; i &lt; length / 2; i++) &#123; if (s[i] != s[length - 1 - i]) &#123; interval = length - 1 - i - i; if (interval &lt;= 1) &#123; return true; &#125; else &#123; left1 = i; right1 = length - 2 - i; left2 = i + 1; right2 = length - 1 - i; break; &#125; &#125; &#125; bool result1 = true; bool result2 = true; for (int i = 0; i &lt; (right1 - left1 + 1) / 2; i++) &#123; if (s[i + left1] != s[right1 - i]) &#123; result1 = false; break; &#125; &#125; if (result1) &#123; return true; &#125; for (int i = 0; i &lt; (right2 - left2 + 1) / 2; i++) &#123; if (s[i + left2] != s[right2 - i]) &#123; result2 = false; break; &#125; &#125; if (result2) &#123; return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 682. 棒球比赛]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20682.%C2%A0%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述你现在是棒球比赛记录员。给定一个字符串列表，每个字符串可以是以下四种类型之一：1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。 &quot;+&quot;（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。 &quot;D&quot;（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。 &quot;C&quot;（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。你需要返回你在所有回合中得分的总和。 示例 1: 12345678输入: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]输出: 30解释: 第1轮：你可以得到5分。总和是：5。第2轮：你可以得到2分。总和是：7。操作1：第2轮的数据无效。总和是：5。第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。第4轮：你可以得到5 + 10 = 15分。总数是：30。 示例 2: 1234567891011输入: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]输出: 27解释: 第1轮：你可以得到5分。总和是：5。第2轮：你可以得到-2分。总数是：3。第3轮：你可以得到4分。总和是：7。操作1：第3轮的数据无效。总数是：3。第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。第5轮：你可以得到9分。总数是：8。第6轮：你可以得到-4 + 9 = 5分。总数是13。第7轮：你可以得到9 + 5 = 14分。总数是27。 注意： 输入列表的大小将介于1和1000之间。 列表中的每个整数都将介于-30000和30000之间。 2、解题思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293int sToNum(char *s) &#123; int result = 0; int left = 0; int sign = 1; if (s[0] == '-') &#123; sign = -1; left = 1; &#125; for (int i = left; i &lt; strlen(s); i++) &#123; result = result * 10 + s[i] - '0'; &#125; return result * sign;&#125;int calPoints(char** ops, int opsSize) &#123; // 标识无效数据 const int MIN = -1000000; int *result = (int *) malloc(sizeof(int) * opsSize); // 初始化 for (int i = 0; i &lt; opsSize; i++) &#123; result[i] = MIN; &#125; int first = MIN; int second = MIN; int j; for (int i = 0; i &lt; opsSize; i++) &#123; switch (ops[i][0]) &#123; case 'C': j = i; while (result[j] == MIN) &#123; j--; &#125; if (j &gt;= 0) &#123; result[j] = MIN; &#125; break; case 'D': j = i; while (result[j] == MIN) &#123; j--; &#125; if (j &gt;= 0) &#123; result[i] = 2 * result[j]; &#125; break; case '+': first = MIN; second = MIN; j = i; while (result[j] == MIN) &#123; j--; &#125; first = result[j]; j--; while (result[j] == MIN) &#123; j--; &#125; second = result[j]; result[i] = first + second; break; default: result[i] = sToNum(ops[i]); break; &#125; &#125; int ans = 0; for (int i = 0; i &lt; opsSize; i++) &#123; if (result[i] != MIN) &#123; ans += result[i]; &#125; printf("%d\n",result[i]); &#125; return ans;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 686. 重复叠加字符串匹配]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20686.%C2%A0%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。 举个例子，A = “abcd”，B = “cdabcdab”。 答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”，此时 B 是其子串；A 重复叠加两遍后为”abcdabcd”，B 并不是其子串。 注意: A 与 B 字符串的长度在1和10000区间范围内。 2、解题思路​ 123456789101112131415class Solution: def repeatedStringMatch(self, A, B): """ :type A: str :type B: str :rtype: int """ str = "" for i in range(len(B) // len(A) + 2): str = str + A if B in str: return i + 1 return -1 ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 687. 最长同值路径]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20687.%C2%A0%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 注意：两个节点之间的路径长度由它们之间的边数表示。 示例 1: 输入: 12345 5 / \ 4 5 / \ \1 1 5 输出: 12 示例 2: 输入: 12345 1 / \ 4 5 / \ \4 4 5 输出: 12 注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。 2、解题思路​ 设计一个递归函数，返回的值是当前路径下左右节点中最长的路径 ​ 对每个节点来讲，经过这个节点的路径，是左右最长路径之和 ​ 注意一点就是，什么时候不相等，就从这个点重新计算最大值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */int longPath(struct TreeNode *root, int *max) &#123; int left = 0; int right = 0; if (root-&gt;left &amp;&amp; root-&gt;val == root-&gt;left-&gt;val) &#123; left = 1 + longPath(root-&gt;left, max); &#125; else if (root-&gt;left) &#123; longPath(root-&gt;left, max); &#125; if (root-&gt;right &amp;&amp; root-&gt;val == root-&gt;right-&gt;val) &#123; right = 1 + longPath(root-&gt;right, max); &#125; else if (root-&gt;right) &#123; longPath(root-&gt;right, max); &#125; if (left + right &gt; *max) &#123; *max = left + right; &#125; return left &gt; right ? left : right;&#125;int longestUnivaluePath(struct TreeNode *root) &#123; if (!root) &#123; return 0; &#125; int max = 0; longPath(root, &amp;max); return max;&#125; ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 69.x 的平方根]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2069.x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4输出: 2 示例 2: 1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 2、解题思路​ 使用二分查找法 ​ 需要注意int的上限值 ​ $2^{31}-1 = 2147483647$ ​ 其最大值为：46341 12345678910111213141516171819202122232425262728293031int mySqrt(int x) &#123; int max_int_sqrt = 46341; int left = 0; int right = x &gt; max_int_sqrt ? max_int_sqrt : x; int left_temp = left; int right_temp = right; int temp; while (left &lt; right - 1 &amp;&amp; right &lt;= 46341) &#123; temp = right - (right - left) / 2; if (temp * temp &gt; x) &#123; right_temp = temp; &#125; else &#123; left_temp = temp; &#125; temp = left + (right - left) / 2; if (temp * temp &gt; x) &#123; right = temp &lt; right_temp ? temp : right_temp; &#125; else &#123; left = temp &gt; left_temp ? temp : left_temp; &#125; &#125; if (right * right == x) &#123; return right; &#125; else &#123; return left; &#125;&#125; ​ 将除以2改成右移一位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;memory.h&gt;#include &lt;string.h&gt;/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int mySqrt(int x) &#123; int max_int_sqrt = 46341; int left = 0; int right = x &gt; max_int_sqrt ? max_int_sqrt : x; int left_temp = left; int right_temp = right; int temp; while (left &lt; right - 1 &amp;&amp; right &lt;= 46341) &#123; temp = right - ((right - left) &gt;&gt; 1); if (temp * temp &gt; x) &#123; right_temp = temp; &#125; else &#123; left_temp = temp; &#125; temp = left + ((right - left) &gt;&gt; 1); if (temp * temp &gt; x) &#123; right = temp &lt; right_temp ? temp : right_temp; &#125; else &#123; left = temp &gt; left_temp ? temp : left_temp; &#125; &#125; if (right * right == x) &#123; return right; &#125; else &#123; return left; &#125;&#125;int main() &#123; for (int i = 1; i &lt; 500; i++) &#123; printf("number: %d\t sqrt: %d\n", i, mySqrt(i)); &#125; printf("number: %d\t sqrt: %d\n", 2147395599, mySqrt(2147395599)); printf("number: %d\t sqrt: %d\n", 2147395600, mySqrt(2147395600));&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 690. 员工的重要性]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20690.%C2%A0%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。 比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。 现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。 示例 1: 1234输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1输出: 11解释:员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。 注意: 一个员工最多有一个直系领导，但是可以有多个直系下属 员工数量不超过2000。 2、解题思路​ 基本思路就是，建立一个哈希，或者说字典，保存id和里面内容的映射，不断的遍历属下，可以用递归，也可以使用list不断增加的特性，直到所有的都遍历完成 1234567891011121314151617181920212223242526272829303132"""# Employee infoclass Employee: def __init__(self, id, importance, subordinates): # It's the unique id of each node. # unique id of this employee self.id = id # the importance value of this employee self.importance = importance # the id of direct subordinates self.subordinates = subordinates"""class Solution: em = &#123;&#125; def getImportance(self, employees, id): """ :type employees: Employee :type id: int :rtype: int """ for i in employees: self.em[i.id] = i # print(i) return self.getSum(self.em[id]) def getSum(self,employee): total = employee.importance for i in employee.subordinates: total += self.getSum(self.em[i]) return total 123456789101112131415161718192021222324252627282930313233"""# Employee infoclass Employee: def __init__(self, id, importance, subordinates): # It's the unique id of each node. # unique id of this employee self.id = id # the importance value of this employee self.importance = importance # the id of direct subordinates self.subordinates = subordinates"""class Solution: def getImportance(self, employees, id): """ :type employees: Employee :type id: int :rtype: int """ em = &#123;&#125; for i in employees: em[i.id] = (i.importance, i.subordinates) sub = em[id][1] total = em[id][0]; for i in sub: total += em[i][0] sub += em[i][1] return total]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 693. 交替位二进制数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20693.%C2%A0%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。 示例 1: 1234输入: 5输出: True解释:5的二进制数是: 101 示例 2: 1234输入: 7输出: False解释:7的二进制数是: 111 示例 3: 1234输入: 11输出: False解释:11的二进制数是: 1011 示例 4: 1234输入: 10输出: True解释:10的二进制数是: 1010 2、解题思路​ 从左面开始，找到第一个1，然后,不断的进行异或，如果异或是0，返回false 123456789101112131415161718192021222324252627bool hasAlternatingBits(int n) &#123; if (n == 0) &#123; return true; &#125; int left = 0; int right = 0; bool start = false; for (int i = 31; i &gt; 0; i--) &#123; if (!start) &#123; if (n &amp; (1 &lt;&lt; i)) &#123; start = true; i++; &#125; &#125; else &#123; left = (n &amp; (1 &lt;&lt; i)) == 0 ? 0 : 1; right = (n &amp; (1 &lt;&lt; (i - 1))) == 0 ? 0 : 1; if ((left ^ right) == 0) &#123; return false; &#125; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 695. 岛屿的最大面积]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20695.%C2%A0%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: 12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: 1[[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 2、解题思路​ 对每一个为1的点，发起深度优先搜索，向右和向下搜索，其实与二叉树是一样的，但是不同的是，直接搜索可能放问同样的节点，因此，使用一个访问标记即可，如果该节点访问过了，解放上标记1，没访问过，就是标记0 ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void dfs(int **grid, int **sign, int *max, int gridRowSize, int gridColSize, int i, int j) &#123; if (i &lt; 0 || i &gt;= gridRowSize || j &lt; 0 || j &gt;= gridColSize) &#123; return; &#125; if (sign[i][j] == 0) &#123; if (grid[i][j] == 1) &#123; *max += 1; sign[i][j] = 1; dfs(grid, sign, max, gridRowSize, gridColSize, i - 1, j); dfs(grid, sign, max, gridRowSize, gridColSize, i, j - 1); dfs(grid, sign, max, gridRowSize, gridColSize, i + 1, j); dfs(grid, sign, max, gridRowSize, gridColSize, i, j + 1); &#125; &#125; else &#123; return; &#125;&#125;int maxAreaOfIsland(int **grid, int gridRowSize, int gridColSize) &#123; int result = 0; int max = 0; int **sign = (int **) malloc(sizeof(int *) * gridRowSize); for (int i = 0;i&lt;gridRowSize;i++)&#123; sign[i] = (int *)malloc(sizeof(int)*gridColSize); &#125; for (int i = 0; i &lt; gridRowSize; i++) &#123; for (int j = 0; j &lt; gridColSize; j++) &#123; sign[i][j] = 0; &#125; &#125; for (int i = 0; i &lt; gridRowSize; i++) &#123; for (int j = 0; j &lt; gridColSize; j++) &#123; if (grid[i][j] == 1) &#123; max = 0; dfs(grid, sign, &amp;max, gridRowSize, gridColSize, i, j); if (result &lt; max) &#123; result = max; &#125; &#125; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 696. 计数二进制子串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20696.%C2%A0%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例 1 : 1234567输入: &quot;00110011&quot;输出: 6解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。请注意，一些重复出现的子串要计算它们出现的次数。另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 示例 2 : 123输入: &quot;10101&quot;输出: 4解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。 注意： s.length 在1到50,000之间。 s 只包含“0”或“1”字符。 2、解题思路2.1 遍历法​ 直接能想到的就是遍历法，不过因为时间超过了限制，所以要寻找其他办法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950bool isSubstring(char *s) &#123; int current_count = 0; int next_count = 0; char cur = *s; char *temp = s; bool current_char = true; while (*temp) &#123; if (current_char) &#123; if (*temp == cur) &#123; current_count++; &#125; else &#123; current_char = false; next_count++; if (next_count &gt;= current_count) &#123; return true; &#125; &#125; &#125; else &#123; if (*temp != cur) &#123; next_count++; if (next_count &gt;= current_count) &#123; return true; &#125; &#125; else &#123; break; &#125; &#125; temp++; &#125; return current_count &lt;= next_count;&#125;int countBinarySubstrings(char *s) &#123; int result = 0; char *temp = s; while (*temp) &#123; result += isSubstring(temp); temp++; &#125; return result;&#125; 2.2 相邻最小值法​ 实际上，如果相邻的值中，我们只取最小值， 例如 00011 统计数字是3，2，子串是0011，01，也就是说，子串的数量等于最小的那个值得数量； ​ 重要的是理解题意！！！！ 12345678910111213141516171819202122232425262728#define min(a, b) a&lt;b?a:b;int countBinarySubstrings(char* s) &#123; int prev_count = 0; int current_count = 0; int result = 0; char *temp = s; char cur_char = *temp; while (*temp) &#123; if (*temp == cur_char) &#123; current_count++; &#125; else &#123; cur_char = *temp; result += min(prev_count, current_count); prev_count = current_count; current_count = 1; &#125; temp++; &#125; result += min(current_count, prev_count); return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 697. 数组的度]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20697.%C2%A0%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。 你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。 示例 1: 1234567输入: [1, 2, 2, 3, 1]输出: 2解释: 输入数组的度是2，因为元素1和2的出现频数最大，均为2.连续子数组里面拥有相同度的有如下所示:[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]最短连续子数组[2, 2]的长度为2，所以返回2. 示例 2: 12输入: [1,2,2,3,1,4,2]输出: 6 注意: nums.length 在1到50,000区间范围内。 nums[i] 是一个在0到49,999范围内的整数。 2、解题思路​ 首先找出最大的度，然后从数组的左面和右面找到这个数字第一次出现的位置，返回这两个位置之差； 123456789101112131415161718192021222324252627class Solution: def findShortestSubArray(self, nums): """ :type nums: List[int] :rtype: int """ result = 50000000 num_dict = &#123;&#125; count = 0 index = 0 for i in nums: if num_dict.get(i) is None: num_dict[i] = [1, index, index] else: num_dict[i][0] += 1 num_dict[i][2] = index index += 1 count = max([v[0] for v in num_dict.values()]) for k, v in num_dict.items(): if v[0] == count: result = min(result, v[2]-v[1]+1) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 7. 反转整数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%207.%C2%A0%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目要求12345678910111213141516Given a 32-bit signed integer, reverse digits of an integer.Example 1:Input: 123Output: 321Example 2:Input: -123Output: -321Example 3:Input: 120Output: 21Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 给定一个 32 位有符号整数，将整数中的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 2、解题思路2.1 判断边界条件1234567891011121314151617181920212223int reverse(int x) &#123; if (!(x ^ (1&lt;&lt;(sizeof(int)*8 -1))))&#123; return 0; &#125; bool flag_positive = x &gt; 0 ? true : false; int result; int num = flag_positive ? x : -x ; result = num % 10; num /= 10; while (num &gt; 0) &#123; if (result &gt; (INT_MAX/10))&#123; return 0; &#125; result = result * 10 + num % 10; num = num / 10; &#125; if (!flag_positive) &#123; result = -result; &#125; return result;&#125; 2.2 使用long保存数据2.3 根据除法结果​ 判断前面一次 1234int t = res * 10 + x % 10;if (t / 10 != res) return 0;res = t;x /= 10;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 70. 爬楼梯]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2070.%20%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述假设你正在爬楼梯。需要 n 步你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 步 + 1 步2. 2 步 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 步 + 1 步 + 1 步2. 1 步 + 2 步3. 2 步 + 1 步 2、解题思路​ 爬楼梯实际是一个斐波那切数列 ​ 可以这样考虑，如果是n级台阶的所有走法，那么第一步可以是1步，剩余n-1级，也可以是2步，剩余n-2级 ​ 因此，$S(n) = S(n-1)+S(n-2)$ ​ S(0) = 1 ​ S(1) = 1 ​ S(2) = 2 ​ S(3) = 3 … 1234567891011121314int climbStairs(int n) &#123; if (n == 0) &#123; return 0; &#125; int a = 1; int b = 1; int temp = a; for (int i = 0; i &lt; n; i++) &#123; temp = a; a = b; b = temp+b; &#125; return a;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 71. 简化路径]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2071.%C2%A0%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个文档 (Unix-style) 的完全路径，请进行路径简化。 例如，path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot; 边界情况: 你是否考虑了 路径 = &quot;/../&quot; 的情况？在这种情况下，你需返回 &quot;/&quot; 。 此外，路径中也可能包含多个斜杠 &#39;/&#39; ，如 &quot;/home//foo/&quot; 。在这种情况下，你可忽略多余的斜杠，返回 &quot;/home/foo&quot; 。 2、解题思路​ 这道题实际上很简单，不需要借助栈，也不需要其他的工具 首先，使用/ 将字符串拆分，然后，从后面向前扫描 如果是空串，也就表示出现的是//,直接删掉 如果是..，那么表示前面有一个目录需要简化，用一个计数器计数 如果遇到的是非空串，他可以抵消一个..， 最后,使用/将各个元素隔开，并在前面添加/即可 123456789101112131415161718192021222324252627class Solution: def simplifyPath(self, path): """ :type path: str :rtype: str """ temp = path.split('/') length = len(temp) count2Points = 0 while length &gt; 0: if temp[length - 1] == "": temp.pop(length - 1) elif temp[length - 1] == '..': count2Points += 1 temp.pop(length - 1) elif temp[length - 1] == '.': temp.pop(length - 1) else: if count2Points &gt; 0: temp.pop(length - 1) count2Points -= 1 length -= 1 return "/" + "/".join(temp)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 717. 1比特与2比特字符]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20717.%C2%A01%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。 现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。 示例 1: 12345输入: bits = [1, 0, 0]输出: True解释: 唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。 示例 2: 12345输入: bits = [1, 1, 1, 0]输出: False解释: 唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。 注意: 1 &lt;= len(bits) &lt;= 1000. bits[i] 总是0 或 1. 2、解题思路​ 123456789101112bool isOneBitCharacter(int* bits, int bitsSize) &#123; int result = false; for (int i = 0; i &lt; bitsSize; i++) &#123; if (i == bitsSize-1)&#123; result = true; &#125; if (bits[i] == 1) &#123; i++; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 720. 词典中最长的单词]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20720.%20%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。 若无答案，则返回空字符串。 示例 1: 12345输入: words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]输出: &quot;world&quot;解释: 单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;添加一个字母组成。 示例 2: 12345输入: words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]输出: &quot;apple&quot;解释: &quot;apply&quot;和&quot;apple&quot;都能由词典中的单词组成。但是&quot;apple&quot;得字典序小于&quot;apply&quot;。 注意: 所有输入的字符串都只包含小写字母。 words数组长度范围为[1,1000]。 words[i]的长度范围为[1,30]。 2、解题思路123456789101112131415161718class Solution: def longestWord(self, words): """ :type words: List[str] :rtype: str """ res = "" change = True for i in words: if len(i) &gt; len(res) or (len(i) == len(res) and i &lt; res): change = True for j in range(len(i)): if i[0:j + 1] not in words: change = False break if change: res = i return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 724. 寻找数组的中心索引]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20724.%C2%A0%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例 1: 123456输入: nums = [1, 7, 3, 6, 5, 6]输出: 3解释: 索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。同时, 3 也是第一个符合要求的中心索引。 示例 2: 12345输入: nums = [1, 2, 3]输出: -1解释: 数组中不存在满足此条件的中心索引。 说明: nums 的长度范围为 [0, 10000]。 任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。 2、解题思路​ 1234567891011121314151617181920212223class Solution: def pivotIndex(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 2: return -1 prev = 0 next = sum(nums) index = 0; result = -1 for i in range(0, len(nums)): if i &gt; 0: prev += nums[i - 1] next -= nums[i] if prev == next: result = i break return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 728. 自除数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20728.%C2%A0%E8%87%AA%E9%99%A4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 自除数 是指可以被它包含的每一位数除尽的数。 例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。 还有，自除数不允许包含 0 。 给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。 示例 1： 123输入： 上边界left = 1, 下边界right = 22输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] 注意： 每个输入参数的边界满足 1 &lt;= left &lt;= right &lt;= 10000。 2、解题思路​ 1234567891011121314151617181920212223class Solution: def selfDividingNumbers(self, left, right): """ :type left: int :type right: int :rtype: List[int] """ res = [] for i in range(left, right + 1): judge = True if i == 0: judge = False temp = i while temp &gt; 0: digit = temp % 10 if digit == 0 or i % digit != 0: judge = False break temp //= 10 if judge: res.append(i) return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 73. 矩阵置零]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2073.%C2%A0%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1: 123456789101112输入: [ [1,1,1], [1,0,1], [1,1,1]]输出: [ [1,0,1], [0,0,0], [1,0,1]] 示例 2: 123456789101112输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] 进阶: 一个直接的解决方案是使用 O(m**n) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ 2、解题思路​ 实际上，如上面进阶所说的 ，使用额外空间保存的话，题目很简单，但是，如果不用额外空间呢？ ​ 只需要在数组中，使用第0行和第0列来打标记就可以了，然后通过编列第0行和第0列，将对应的行与列置零 ​ ​ 这里需要注意的就是，左上角的元素需要存储，单独设置一个变量存储即可， ​ 如果是行元素或者列元素将它置1，就设置为1，如果本身就是0，设置为2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution: def setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ row = len(matrix) col = len(matrix[0]) # top 存储左上角的交叉点的状态 # 1: 行置0 # 2: 列置0 # 3: 行列都置0 top = 0 for i in range(row): for j in range(col): if matrix[i][j] == 0: if i == 0 and j == 0: top = 3 elif top != 3: if i == 0: if top == 2: top = 3 else: top = 1 if j == 0: if top == 1: top = 3 else: top = 2 if top == 2 and i == 0: top = 3 elif top == 1 and j == 0: top = 3 matrix[i][0] = 0 matrix[0][j] = 0 for i in range(1, row): if matrix[i][0] == 0: for j in range(col): matrix[i][j] = 0 for i in range(1, col): if matrix[0][i] == 0: for j in range(row): matrix[j][i] = 0 if top == 3: for i in range(row): matrix[i][0] = 0 for i in range(col): matrix[0][i] = 0 elif top == 1: for i in range(col): matrix[0][i] = 0 elif top == 2: for i in range(row): matrix[i][0] = 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 733. 图像渲染]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20733.%C2%A0%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。 最后返回经过上色渲染后的图像。 示例 1: 123456789输入: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2输出: [[2,2,2],[2,2,0],[2,0,1]]解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。 注意: image 和 image[0] 的长度在范围 [1, 50] 内。 给出的初始点将满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length。 image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。 2、解题思路​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void flood(int **image, int imageRowSize, int imageColSize, int sr, int sc, int oldColor, int newColor, int **sign) &#123; if (sign[sr][sc] == 0) &#123; sign[sr][sc] = 1; if (oldColor == image[sr][sc]) &#123; image[sr][sc] = newColor; &#125; else &#123; return; &#125; if (sr - 1 &gt;= 0) &#123; flood(image, imageRowSize, imageColSize, sr - 1, sc, oldColor, newColor, sign); &#125; if (sc - 1 &gt;= 0) &#123; flood(image, imageRowSize, imageColSize, sr, sc - 1, oldColor, newColor, sign); &#125; if (sr + 1 &lt; imageRowSize) &#123; flood(image, imageRowSize, imageColSize, sr + 1, sc, oldColor, newColor, sign); &#125; if (sc + 1 &lt; imageColSize) &#123; flood(image, imageRowSize, imageColSize, sr, sc + 1, oldColor, newColor, sign); &#125; &#125; else &#123; return; &#125;&#125;int **floodFill(int **image, int imageRowSize, int imageColSize, int sr, int sc, int newColor, int **columnSizes, int *returnSize) &#123; *columnSizes = (int *) malloc(sizeof(int) * imageRowSize); for (int i = 0; i &lt; imageRowSize; i++) &#123; (*columnSizes)[i] = imageColSize; &#125; *returnSize = imageRowSize; int **result = (int **) malloc(sizeof(int *) * imageRowSize); int **sign = (int **) malloc(sizeof(int *) * imageRowSize);// int sign[imageRowSize][imageColSize]; int *line; for (int i = 0; i &lt; imageRowSize; i++) &#123; line = (int *) malloc(sizeof(int) * imageColSize); result[i] = line; line = (int *) malloc(sizeof(int) * imageColSize); sign[i] = line; for (int j = 0; j &lt; imageColSize; j++) &#123; result[i][j] = image[i][j]; sign[i][j] = 0; &#125; &#125; flood(result, imageRowSize, imageColSize, sr, sc, image[sr][sc], newColor, sign); return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 74. 搜索二维矩阵]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2074.%C2%A0%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1: 12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2: 12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 2、解题思路​ 从题意来看，实际上这个矩阵每一行遍历得到的就是排序好的数组，直接用二分法就行了，只需要将左右指针转化为二维坐标即可 ​ 没有任何难点，只要注意一下边界条件即可，空的矩阵返回FALSE 1234567891011121314151617181920212223242526272829class Solution: def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ row = len(matrix) if row &lt;=0: return False col = len(matrix[0]) left = 0 right = row * col - 1 mid = (left + right) // 2 while left &lt;= right: if matrix[mid // col][mid % col] == target: return True else: if matrix[mid // col][mid % col] &gt; target: right = mid - 1 else: left = mid + 1 mid = (left + right) // 2 return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 744. 寻找比目标字母大的最小字母]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20744.%C2%A0%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。 数组里字母的顺序是循环的。举个例子，如果目标字母target = &#39;z&#39; 并且有序数组为 letters = [&#39;a&#39;, &#39;b&#39;]，则答案返回 &#39;a&#39;。 示例: 1234567891011121314151617181920212223242526272829输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;a&quot;输出: &quot;c&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;c&quot;输出: &quot;f&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;d&quot;输出: &quot;f&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;g&quot;输出: &quot;j&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;j&quot;输出: &quot;c&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;k&quot;输出: &quot;c&quot; 注: letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。 2、解题思路​ 123456789char nextGreatestLetter(char* letters, int lettersSize, char target) &#123; for (int i = 0; i &lt; lettersSize; i++) &#123; if (letters[i] &gt; target) &#123; return letters[i]; &#125; &#125; return letters[0];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 746. 使用最小花费爬楼梯]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20746.%C2%A0%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1: 123输入: cost = [10, 15, 20]输出: 15解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例 2: 123输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 2、解题思路​ 实际上就是简单的动态规划问题，可以用一个缓冲数组，也可以不用 12345678910111213141516171819#define min_Value(a, b) a&lt;b?a:bint minCostClimbingStairs(int *cost, int costSize) &#123; int buff[costSize + 1]; buff[0] = 0; buff[1] = cost[0]; int temp; for (int i = 1; i &lt; costSize; i++) &#123; temp = min_Value(buff[i], buff[i - 1]); temp += cost[i]; buff[i + 1] = temp; // printf("%d\n", buff[i + 1]); &#125; return min_Value(buff[costSize], buff[costSize - 1]);&#125; ​ 键值遇到奇葩了，不知道为什么，不用temp总是出错，晕了！！！！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 747. 至少是其他数字两倍的最大数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20747.%C2%A0%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述在一个给定的数组nums中，总是存在一个最大元素 。 查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 如果是，则返回最大元素的索引，否则返回-1。 示例 1: 1234输入: nums = [3, 6, 1, 0]输出: 1解释: 6是最大的整数, 对于数组中的其他整数,6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1. 示例 2: 123输入: nums = [1, 2, 3, 4]输出: -1解释: 4没有超过3的两倍大, 所以我们返回 -1. 提示: nums 的长度范围在[1, 50]. 每个 nums[i] 的整数范围在 [0, 99]. 2、解题思路​ 123456789101112131415161718192021int dominantIndex(int* nums, int numsSize) &#123; int max_value = -1; int second_value = -1; int max_pos = -1; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i] &gt; max_value) &#123; second_value = max_value; max_value = nums[i]; max_pos = i; &#125; else if (nums[i] &gt; second_value) &#123; second_value = nums[i]; &#125; &#125; if (max_value &gt;= 2 * second_value) &#123; return max_pos; &#125; else &#123; return -1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 75. 分类颜色]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2075.%C2%A0%E5%88%86%E7%B1%BB%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 2、解题思路​ 如果是常规的排序，是很简单，但是不能一谈扫描就将数组排序好，但是这个数字有点特殊，他只有3中，0，1，2，也就是说，最后的结果是，0，1，2的顺序 ​ 因此，我们设置两个指针，分别指向排好序的0的右端，2的左端，然后不断地判断，如果当前数字是0，直接与左端的指针位置数交换，并且，左指针加一 ​ 如果是2，就与右面的2的指针位置交换，并且右指针减一 ​ 等到判断到右指针的时候，表示整个数组都排好序了 举个例子 1[2,0,2,1,1,0] 左指针=0 右指针=5 然后从0号位置开始判断 判断是2，与右指针指向的位置交换，也就是变成了 1[0,0,2,1,1,2] 右指针减一 right = 4 此时， 然后判断一下，发现现在指向的是0，但是当前指针与左指针相等，直接加一，左指针加一 index=1 left=1 发现是0，当前指针和左指针相等，直接加一，左指针加一 index=2 left=2 发现现在这个是2，与右指针交换，得到 1[0,0,1,1,2,2] 然后index =3 right = 3 index = 4 然后继续，index超过了right，退出 12345678910111213141516171819202122232425262728293031class Solution: def sortColors(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ length = len(nums) if length &lt;= 1: return left = 0 right = length - 1 index = 0 while index &lt;= right: if nums[index] == 0: if index == left: index += 1 left += 1 else: nums[index], nums[left] = nums[left], nums[index] left += 1 elif nums[index] == 2: if index == right: index += 1 right -= 1 else: nums[index], nums[right] = nums[right], nums[index] right -= 1 else: index += 1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 762. 二进制表示中质数个计算置位]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20762.%C2%A0%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。） 示例 1: 1234567输入: L = 6, R = 10输出: 4解释:6 -&gt; 110 (2 个计算置位，2 是质数)7 -&gt; 111 (3 个计算置位，3 是质数)9 -&gt; 1001 (2 个计算置位，2 是质数)10-&gt; 1010 (2 个计算置位，2 是质数) 示例 2: 123456789输入: L = 10, R = 15输出: 5解释:10 -&gt; 1010 (2 个计算置位, 2 是质数)11 -&gt; 1011 (3 个计算置位, 3 是质数)12 -&gt; 1100 (2 个计算置位, 2 是质数)13 -&gt; 1101 (3 个计算置位, 3 是质数)14 -&gt; 1110 (3 个计算置位, 3 是质数)15 -&gt; 1111 (4 个计算置位, 4 不是质数) 注意: L, R 是 L &lt;= R 且在 [1, 10^6] 中的整数。 R - L 的最大值为 10000。 2、解题思路​ 这道题实际上很简单，因为位数最多是32位，其中是质数的有 12,3,5,7,11,13,17,19,23,29,31 ​ 直接判断就可以了 ​ ​ 12345678910111213141516171819202122232425262728293031323334353637383940int countOneNums(int num) &#123; int result = 0; for (int i = 0; i &lt; 32; i++) &#123; if ((num &amp; (1 &lt;&lt; i)) != 0) &#123; result++; &#125; &#125; return result;&#125;bool isPrime(int i) &#123; switch (i) &#123; case 2: case 3: case 5: case 7: case 11: case 13: case 17: case 19: case 23: case 29: case 31: return true; default: return false; &#125;&#125;int countPrimeSetBits(int L, int R) &#123; int result = 0; for (int i = L; i &lt;= R; i++) &#123; if (isPrime(countOneNums(i)))&#123; result++; &#125; &#125; return result; &#125; ​ 当然，质数判断也可以有更简单的方式，直接用32个数的缓冲数组，匹配下标即可]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 766. 托普利茨矩阵]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20766.%C2%A0%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。 给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。 示例 1: 1234567891011输入: matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2]]输出: True解释:在上述矩阵中, 其对角线为:&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。各条对角线上的所有元素均相同, 因此答案是True。 示例 2: 12345678输入:matrix = [ [1,2], [2,2]]输出: False解释: 对角线&quot;[1, 2]&quot;上的元素不同。 说明: matrix 是一个包含整数的二维数组。 matrix 的行数和列数均在 [1, 20]范围内。 matrix[i][j] 包含的整数在 [0, 99]范围内。 进阶: 如果矩阵存储在磁盘上，并且磁盘内存是有限的，因此一次最多只能将一行矩阵加载到内存中，该怎么办？ 如果矩阵太大以至于只能一次将部分行加载到内存中，该怎么办？ 2、解题思路123456789101112131415161718192021class Solution: def isToeplitzMatrix(self, matrix): """ :type matrix: List[List[int]] :rtype: bool """ prev_sum = sum(matrix[0]) current_sum = 0 prev = matrix[0][len(matrix[0]) - 1] first = True for i in matrix: if first: first = False; continue current_sum = sum(i) if prev_sum - prev + i[0] != current_sum: return False prev_sum = current_sum prev = i[len(i) - 1] return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 77. 组合]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2077.%C2%A0%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例: 12345678910输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 2、解题思路​ 直接使用最简单的思路的话，也就是使用python内置的itertools，直接求解 ​ 如果不使用的话，就需要不断的迭代，求解 1234567891011class Solution: def combine(self, n, k): """ :type n: int :type k: int :rtype: List[List[int]] """ temp = [i for i in range(1, n + 1)] result = itertools.combinations(temp, k) return [ list(v) for v in result]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 771. 宝石与石头]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20771.%C2%A0%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此&quot;a&quot;和&quot;A&quot;是不同类型的石头。 示例 1: 12输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3 示例 2: 12输入: J = &quot;z&quot;, S = &quot;ZZ&quot;输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 2、解题思路123456789101112131415161718int numJewelsInStones(char* J, char* S) &#123; int length_J = strlen(J); int length_S = strlen(S); int *buff = (int *) calloc('z' - 'A' + 1, sizeof(int)); for (int i = 0; i &lt; length_J; i++) &#123; buff[J[i] - 'A'] = 1; &#125; int result = 0; for (int i = 0; i &lt; length_S; i++) &#123; result += buff[S[i] - 'A']; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 78. 子集]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2078.%C2%A0%E5%AD%90%E9%9B%86%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 2、解题思路​ 看到这个题目，直接想到的解题就是利用求解组合数，从求解0个，到求解n个，然后放到结果数组中即可 123456789101112class Solution: def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ result = [] for i in range(len(nums)+1): result += [list(v) for v in itertools.combinations(nums, i)] return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 783. 二叉搜索树结点最小距离]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20783.%C2%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%BB%93%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉搜索树的根结点 root, 返回树中任意两节点的差的最小值。 示例： 1234567891011121314输入: root = [4,2,6,1,3,null,null]输出: 1解释:注意，root是树结点对象(TreeNode object)，而不是数组。给定的树 [4,2,6,1,3,null,null] 可表示为下图: 4 / \ 2 6 / \ 1 3 最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。 注意： 二叉树的大小范围在 2 到 100。 二叉树总是有效的，每个节点的值都是整数，且不重复。 2、解题思路​ 实际上这是一个中序遍历，很简单就出来了 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */void dfs(struct TreeNode *root, int *min_value, int *prev_value) &#123; if (!root) &#123; return; &#125; dfs(root-&gt;left, min_value, prev_value); if (*prev_value != -1) &#123; *min_value = *min_value &lt; root-&gt;val - *prev_value ? *min_value : root-&gt;val - *prev_value; &#125; *prev_value = root-&gt;val; dfs(root-&gt;right, min_value, prev_value);&#125;int minDiffInBST(struct TreeNode *root) &#123; int min_value = INT32_MAX; int prev_value = -1; dfs(root, &amp;min_value, &amp;prev_value); return min_value;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 784. 字母大小写全排列]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20784.%C2%A0%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。 123456789示例:输入: S = &quot;a1b2&quot;输出: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]输入: S = &quot;3z4&quot;输出: [&quot;3z4&quot;, &quot;3Z4&quot;]输入: S = &quot;12345&quot;输出: [&quot;12345&quot;] 注意： S 的长度不超过12。 S 仅由数字和字母组成。 12345678910111213141516class Solution: def letterCasePermutation(self, S): """ :type S: str :rtype: List[str] """ result = [S] for i in range(len(S)): if S[i] &gt;= 'a' and S[i] &lt;= 'z': result += [s[:i] + chr(ord(s[i]) - 32) + s[i + 1:] for s in result] elif S[i] &gt;= 'A' and S[i] &lt;= 'Z': result += [s[:i] + chr(ord(s[i]) + 32) + s[i + 1:] for s in result] return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 788. 旋转数字]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20788.%C2%A0%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。 现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？ 123456示例:输入: 10输出: 4解释: 在[1, 10]中有四个好数： 2, 5, 6, 9。注意 1 和 10 不是好数, 因为他们在旋转之后不变。 注意: N 的取值范围是 [1, 10000]。 2、解题思路12345678910111213141516171819202122232425262728293031class Solution: def rotatedDigits(self, N): """ :type N: int :rtype: int """ result = 0 for i in range(1,N+1): if self.isGood(i): result += 1 return result def isGood(self, num): good_num = [0, 0, 1, 0, 0, 1, 1, 0, 0, 1] not_good_num = [0, 0, 0, 1, 1, 0, 0, 1, 0, 0] good = False temp = num % 10 while num &gt; 0: if good_num[temp] != 0: good = True if not_good_num[temp] != 0: return False num //= 10 temp = num % 10 if good: return True else: return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 79. 单词搜索]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2079.%C2%A0%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]给定 word = &quot;ABCCED&quot;, 返回 true.给定 word = &quot;SEE&quot;, 返回 true.给定 word = &quot;ABCB&quot;, 返回 false. 2、解题思路​ 使用深度优先搜索，对每一个开头字母能够匹配的字母，开始深度优先搜索 例如 ​ 12345[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]] 1给定 word = &quot;ABCCED&quot; 首先，判断第一个字符是不是匹配，如果匹配，就用从这个点出发，搜索一遍看看能否找到 ​ 如果找到，返回True ​ 对每一个能匹配到的第一个字符，都这样搜索， ​ 如果全部都找不到，返回False 1234567891011121314151617181920212223242526272829303132333435class Solution: def exist(self, board, word): """ :type board: List[List[str]] :type word: str :rtype: bool """ row = len(board) col = len(board[0]) for i in range(row): for j in range(col): if word[0] == board[i][j]: temp_visited = [[0] * col for _ in range(row)] if self.findWord(board, word, 0, temp_visited, i, j, row, col): return True return False def findWord(self, board, word, index, visited, x, y, row, col): if index &gt;= len(word): return True if x &lt; 0 or y &lt; 0 or x &gt;= row or y &gt;= col: return False result = False # temp_visited = [[visited[i][j] for j in range(col)] for i in range(row)] if visited[x][y] == 0 and board[x][y] == word[index]: visited[x][y] = 1 result = result or self.findWord(board, word, index + 1, visited, x - 1, y, row, col) result = result or self.findWord(board, word, index + 1, visited, x, y - 1, row, col) result = result or self.findWord(board, word, index + 1, visited, x + 1, y, row, col) result = result or self.findWord(board, word, index + 1, visited, x, y + 1, row, col) else: return False visited[x][y] = 0 return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 796. 旋转字符串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20796.%C2%A0%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个字符串, A 和 B。 A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = &#39;abcde&#39;，在移动一次之后结果就是&#39;bcdea&#39; 。如果在若干次旋转操作之后，A 能变成B，那么返回True。 1234567示例 1:输入: A = &apos;abcde&apos;, B = &apos;cdeab&apos;输出: true示例 2:输入: A = &apos;abcde&apos;, B = &apos;abced&apos;输出: false 注意： A 和 B 长度不超过 100。 2、解题思路​ 12345678910111213141516171819202122class Solution: def rotateString(self, A, B): """ :type A: str :type B: str :rtype: bool """ if A == B: return True if len(A) != len(B): return False index = 0 for i in B: if A[0] == i: length = len(A) - index if A[:length] == B[index:] and A[length:] == B[:index]: return True index += 1 return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 8. 字符串转整数 (atoi)]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%208.%C2%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%20(atoi)%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述1234567891011121314151617181920212223242526272829303132333435363738394041Implement atoi which converts a string to an integer.The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.If no valid conversion could be performed, a zero value is returned.Note:Only the space character &apos; &apos; is considered as whitespace character.Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.Example 1:Input: &quot;42&quot;Output: 42Example 2:Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many numerical digits as possible, which gets 42.Example 3:Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.Example 4:Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.Example 5:Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. 实现 atoi，将字符串转为整数。 在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。 当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。 若函数不能执行有效的转换，返回 0。 说明： 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。如果数值超过可表示的范围，则返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 12输入: &quot;42&quot;输出: 42 示例 2: 1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4: 1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 2、解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int myAtoi(char* str) &#123; if (str == NULL) &#123; return 0; &#125; int numbers[10] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int left = 0; int pos = 0; int count = 0; int sign = 0; long result = 0; bool min_Int = false; while (str[left] == ' ') &#123; left++; &#125;; switch (str[left]) &#123; case '+': sign = 1; break; case '-': sign = -1; break; &#125; if (sign) &#123; pos = left + 1; &#125; else &#123; pos = left; &#125; //'0'~'9' while (str[pos] &gt;= '0' &amp;&amp; str[pos] &lt;= '9') &#123; pos++; &#125;; if (sign) &#123; count = left + 1; &#125; else &#123; count = left; &#125; while (count &lt; pos) &#123; result = 10 * result + numbers[str[count++] - '0']; if (result &gt; INT32_MAX ) &#123; if (sign == -1) &#123; result = INT32_MIN; min_Int = true; &#125; else &#123; result = INT32_MAX; &#125; break; &#125; &#125; if (sign == -1 &amp;&amp; !min_Int) &#123; result = -result; &#125; return (int)result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 80. 删除排序数组中的重复项 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2080.%C2%A0%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 2、解题思路​ 这道题很简单，直接使用双指针就可以了，加一个计数器 ​ 第一个指针不断地向后移，第二个指针则是将满足条件的数据移动过去即可 1234567891011121314151617181920212223242526class Solution: def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 2: return len(nums) count = 1 result_index = 0 for i in range(1, len(nums)): if nums[i] == nums[result_index]: if count &gt;= 2: continue else: count += 1 result_index += 1 nums[result_index] = nums[i] else: count = 1 result_index += 1 nums[result_index] = nums[i] return result_index + 1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 804. 唯一摩尔斯密码词]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20804.%C2%A0%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: &quot;a&quot; 对应 &quot;.-&quot;, &quot;b&quot;对应 &quot;-...&quot;, &quot;c&quot; 对应 &quot;-.-.&quot;, 等等。 为了方便，所有26个英文字母对应摩尔斯密码表如下： 1[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] 给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-.-….-“，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。 返回我们可以获得所有词不同单词翻译的数量。 1234567891011例如:输入: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]输出: 2解释: 各单词翻译如下:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;. 注意: 单词列表words 的长度不会超过 100。 每个单词 words[i]的长度范围为 [1, 12]。 每个单词 words[i]只包含小写字母。 2、解题思路​ 12345678910111213class Solution: def uniqueMorseRepresentations(self, words): """ :type words: List[str] :rtype: int """ alpha = [".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."] result = set() for i in words: result.add("".join([alpha[ord(v) - ord('a')] for v in i])) return len(result)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 806. 写字符串需要的行数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20806.%C2%A0%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E8%A1%8C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 widths ，这个数组 widths[0] 代表 ‘a’ 需要的单位， widths[1] 代表 ‘b’ 需要的单位，…， widths[25] 代表 ‘z’ 需要的单位。 现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。 12345678示例 1:输入: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = &quot;abcdefghijklmnopqrstuvwxyz&quot;输出: [3, 60]解释: 所有的字符拥有相同的占用单位10。所以书写所有的26个字母，我们需要2个整行和占用60个单位的一行。 123456789示例 2:输入: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = &quot;bbbcccdddaaa&quot;输出: [2, 4]解释: 除去字母&apos;a&apos;所有的字符都是相同的单位10，并且字符串 &quot;bbbcccdddaa&quot; 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.最后一个字母 &apos;a&apos; 将会被写到第二行，因为第一行只剩下2个单位了。所以，这个答案是2行，第二行有4个单位宽度。 注: 字符串 S 的长度在 [1, 1000] 的范围。 S 只包含小写字母。 widths 是长度为 26的数组。 widths[i] 值的范围在 [2, 10]。 2、解题思路​ 12345678910111213141516171819202122232425/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* numberOfLines(int* widths, int widthsSize, char* S, int* returnSize) &#123; *returnSize = 2; int lines = 0; int remaining = 0; for (int i = 0; i &lt; strlen(S); i++) &#123; if (remaining &gt;= widths[S[i] - 'a']) &#123; remaining -= widths[S[i] - 'a']; &#125; else &#123; lines++; remaining = 100; i--; &#125; &#125; int *result = (int *) malloc(sizeof(int) * 2); result[0] = lines; result[1] = 100 - remaining; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 81. 搜索旋转排序数组 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2081.%C2%A0%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1: 12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2: 12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 2、解题思路​ 前面33题，搜索旋转排序数组，之前的是没有重复元素的，实际上这道题的解题思路与前面没什么区别，需要注意的就是，要判断等于的情况 ​ 左右边界的问题，在前面，我们能够直接判断的情况，现在需要继续判断 [1,3,1,1,1] 3 如上面的例子，如果出现了这种情况，我们需要知道要排除哪一边才行 我们分为4种情况， middle=left=right ​ 这种情况，需要判断是左面的相等，还是右面的相等，将相等的删掉 middle = left middle≠right ​ 直接删除左面的 middle ≠ left middle=right ​ 直接删除右面的 middle ≠ left middle≠right ​ 按照正常情况讨论 出现不同情况，分别进行讨论 实际上，只要判断中间值是不是等于两边中的一个就好了，如果中间值等于 主要是，每一次进行二分法的时候，要排除哪一边才好 不过呢，用python没这么麻烦，直接判断数量就好了 123456789101112class Solution: def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: bool """ if nums.count(target) &gt;= 1: return True return False ​ 不过呢，这个办法有点取巧，而且效率不高 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution: def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: bool """ left = 0 right = len(nums) - 1 middle = (left + right) // 2 while left &lt;= right: if nums[middle] == target: return True equal = True if nums[middle] == nums[left] and nums[middle] == nums[right]: for i in range(left, middle): if nums[i] != nums[left]: equal = False break if equal: left = middle + 1 else: right = middle - 1 elif nums[middle] == nums[left] and nums[middle] != nums[right]: left = middle + 1 elif nums[middle] != nums[left] and nums[middle] == nums[right]: right = middle - 1 else: if nums[middle] &gt; nums[left]: if nums[left] &lt;= target and target &lt; nums[middle]: right = middle - 1 else: left = middle + 1 else: # 现在middle位与右面的递增数组上面 if nums[right] &gt;= target and target &gt; nums[middle]: left = middle + 1 else: right = middle - 1 middle = (left + right) // 2 return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 811. 子域名访问计数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20811.%C2%A0%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述一个网站域名，如”discuss.leetcode.com”，包含了多个子域名。作为顶级域名，常用的有”com”，下一级则有”leetcode.com”，最低的一级为”discuss.leetcode.com”。当我们访问域名”discuss.leetcode.com”时，也同时访问了其父域名”leetcode.com”以及顶级域名 “com”。 给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如：”9001 discuss.leetcode.com”。 接下来会给出一组访问次数和域名组合的列表cpdomains 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。 1234567示例 1:输入: [&quot;9001 discuss.leetcode.com&quot;]输出: [&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]说明: 例子中仅包含一个网站域名：&quot;discuss.leetcode.com&quot;。按照前文假设，子域名&quot;leetcode.com&quot;和&quot;com&quot;都会被访问，所以它们都被访问了9001次。 12345678示例 2输入: [&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]输出: [&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]说明: 按照假设，会访问&quot;google.mail.com&quot; 900次，&quot;yahoo.com&quot; 50次，&quot;intel.mail.com&quot; 1次，&quot;wiki.org&quot; 5次。而对于父域名，会访问&quot;mail.com&quot; 900+1 = 901次，&quot;com&quot; 900 + 50 + 1 = 951次，和 &quot;org&quot; 5 次。 注意事项： cpdomains 的长度小于 100。 每个域名的长度小于100。 每个域名地址包含一个或两个”.”符号。 输入中任意一个域名的访问次数都小于10000。 2、解题思路​ 1234567891011121314151617181920212223class Solution: def subdomainVisits(self, cpdomains): """ :type cpdomains: List[str] :rtype: List[str] """ result = [] domain_dict = &#123;&#125; for i in cpdomains: t = i.split(' ') nums = int(t[0]) temp = t[1].split('.') for j in range(len(temp)): if domain_dict.get(".".join(temp[j:])) is None: domain_dict[".".join(temp[j:])] = nums else: domain_dict[".".join(temp[j:])] += nums for k, v in domain_dict.items(): result.append(str(v) + " " + k) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 812. 最大三角形面积]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20812.%C2%A0%E6%9C%80%E5%A4%A7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。 12345示例:输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]输出: 2解释: 这五个点如下图所示。组成的橙色三角形是最大的，面积为2。 注意: 3 &lt;= points.length &lt;= 50. 不存在重复的点。 -50 &lt;= points[i][j] &lt;= 50. 结果误差值在 10^-6 以内都认为是正确答案。 2、解题思路​ 这个题目的难点在于要知道如何利用三个点的坐标求解面积， ​ 有时间可以看看有限元分析 已知三个点坐标求 三角形面积 12345678910设A(x1,y1),B(x2,y2),C(x3,y3) 由A--&gt;B--&gt;C--&gt;A 按逆时针方向转。(行列式书写要求） 设三角形的面积为S 则S=（1/2)*(下面行列式） |x1 y1 1| |x2 y2 1| |x3 y3 1| S=(1/2)*(x1y2*1+x2y3*1+x3y1*1-x1y3*1-x2y1*1-x3y2*1) 即用三角形的三个顶点坐标求其面积的公式为: S=(1/2)*(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2) 1234567891011class Solution: def largestTriangleArea(self, points): """ :type points: List[List[int]] :rtype: float """ return max([self.getArea(point1, point2, point3) for point1, point2, point3 in itertools.combinations(points, 3)]) def getArea(self, point1, point2, point3): (x1, y1), (x2, y2), (x3, y3) = point1, point2, point3 return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 819. 最常见的单词]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20819.%C2%A0%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。题目保证至少有一个词不在禁用列表中，而且答案唯一。 禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。 12345678910示例:输入: paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;banned = [&quot;hit&quot;]输出: &quot;ball&quot;解释: &quot;hit&quot; 出现了3次，但它是一个禁用的单词。&quot;ball&quot; 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 &quot;ball,&quot;）， &quot;hit&quot;不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。 说明: 1 &lt;= 段落长度 &lt;= 1000. 1 &lt;= 禁用单词个数 &lt;= 100. 1 &lt;= 禁用单词长度 &lt;= 10. 答案是唯一的, 且都是小写字母 (即使在 paragraph 里是大写的，即使是一些特定的名词，答案都是小写的。) paragraph 只包含字母、空格和下列标点符号!?&#39;,;. paragraph 里单词之间都由空格隔开。 不存在没有连字符或者带有连字符的单词。 单词里只包含字母，不会出现省略号或者其他标点符号。 2、解题思路​ 文本中有特殊字符，可以用正则删掉，也可以使用translate，maketrans的方式， ​ 这个是建立映射关系，将某个字符映射到某个字符上 1234567891011121314class Solution: def mostCommonWord(self, paragraph, banned): """ :type paragraph: str :type banned: List[str] :rtype: str """ pa = [v.lower().translate(str.maketrans('!?\',;.', '\0\0\0\0\0\0')).replace("\0","") for v in paragraph.split(" ")] count = collections.Counter(pa) for i in banned: if count.get(i): count.pop(i) return count.most_common(1)[0][0]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 82. 删除排序链表中的重复元素 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2082.%C2%A0%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 12输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2: 12输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 2、解题思路​ 设置两个指针，如果第一个指针指向的节点的值等于第二个指针指向的节点的值，就将将第二个指针后移，一直移到不相等或者为空， ​ 然后，这一段就是需要删除的 ​ 这个题目的关键点就在与，头指针的判定，我们需要构造一个节点，这个节点指向头指针 ​ 然后从头指针开始删除 ​ 一开始，prev指向的不是头指针，而是我们构造的节点，因为头部的元素也可能是需要删除的 ​ 注意，prev指向前面一个有效节点 ​ 使用p，q两个指针进行判断，如果两个值相等，表示遇到了需要删除的，就让q继续向下走，直到找到不相等的那个或者None为止，这时候，中间的一段需要删除； ​ 然后令prev的next指向q，这样就删掉了中间的重复节点，然后继续判断 ​ 如果下一个值与当前的值不相等，表示当前的值是一个有效节点，prev指向这个节点 ​ 以此类推，不断地向下判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head prev = ListNode(0) prev.next = head result_head = prev p = head q = head.next while p and q: if p.val == q.val: while q.next: if p.val != q.val: break q = q.next if p.val == q.val: prev.next = None break else: prev.next = q p = q q = q.next else: prev = p p = q q = q.next return result_head.next ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 821. 字符的最短距离]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20821.%C2%A0%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。 示例 1: 12输入: S = &quot;loveleetcode&quot;, C = &apos;e&apos;输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 说明: 字符串 S 的长度范围为 [1, 10000]。 C 是一个单字符，且保证是字符串 S 里的字符。 S 和 C 中的所有字母均为小写字母。 2、解题思路​ 使用切片，分成左右字符串，左面的字符串反向，然后查找第一个C出现的位置，返回小的那个，需要注意，过滤掉-1，也就是没找到的情况 123456789101112class Solution: def shortestToChar(self, S, C): """ :type S: str :type C: str :rtype: List[int] """ result = [] for i in range(len(S)): result.append(min([v for v in (S[i::-1].find(C), S[i:].find(C)) if v &gt;= 0])) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 824. 山羊拉丁文]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20824.%C2%A0%E5%B1%B1%E7%BE%8A%E6%8B%89%E4%B8%81%E6%96%87%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个由空格分割单词的句子 S。每个单词只包含大写或小写字母。 我们要将句子转换为 “Goat Latin”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。 山羊拉丁文的规则如下： 如果单词以元音开头（a, e, i, o, u），在单词后添加&quot;ma&quot;。例如，单词&quot;apple&quot;变为&quot;applema&quot;。 如果单词以辅音字母开头（即非元音字母），移除第一个字符并将它放到末尾，之后再添加&quot;ma&quot;。例如，单词&quot;goat&quot;变为&quot;oatgma&quot;。 根据单词在句子中的索引，在单词最后添加与索引相同数量的字母&#39;a&#39;，索引从1开始。例如，在第一个单词后添加&quot;a&quot;，在第二个单词后添加&quot;aa&quot;，以此类推。 返回将 S 转换为山羊拉丁文后的句子。 示例 1: 12输入: &quot;I speak Goat Latin&quot;输出: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot; 示例 2: 12输入: &quot;The quick brown fox jumped over the lazy dog&quot;输出: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot; 说明: S 中仅包含大小写字母和空格。单词间有且仅有一个空格。 1 &lt;= S.length &lt;= 150。 2、解题思路​ 12345678910111213141516171819class Solution: def toGoatLatin(self, S): """ :type S: str :rtype: str """ temp = S.split(" ") result = [self.change(s, index + 1) for index,s in enumerate(temp)] return " ".join(result) def change(self, s, index): vowels = ('a', 'e', 'i', 'o', 'u') if s[0].lower() in vowels: temp = s + "ma" + "a" * index else: temp = s[1:] + s[0] + "ma" + "a" * index return temp]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 83.删除排序链表中的重复元素]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2083.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2: 12输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 2、解题思路1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* deleteDuplicates(struct ListNode* head) &#123; // 如果只有一个元素或为空 if (!head || !head-&gt;next ) &#123; return head; &#125; struct ListNode * result = head; while (head-&gt;next) &#123; if (head-&gt;val == head-&gt;next-&gt;val) &#123; head-&gt;next = head-&gt;next-&gt;next; &#125; else &#123; head = head-&gt;next; &#125; &#125; return result;&#125; 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* deleteDuplicates(struct ListNode* head) &#123; // 如果只有一个元素或为空 if (!head || !head-&gt;next) &#123; return head; &#125; struct ListNode *cur = head; struct ListNode *ne = head; if (head) &#123; ne = head-&gt;next; &#125; while (ne) &#123; if(cur-&gt;val == ne-&gt;val)&#123; cur-&gt;next = ne-&gt;next; ne = ne-&gt;next; &#125; else&#123; cur = cur-&gt;next; ne = ne-&gt;next; &#125; &#125; return head;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 830. 较大分组的位置]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20830.%C2%A0%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述在一个由小写字母构成的字符串 S 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 S = &quot;abbxxxxzyy&quot; 中，就含有 &quot;a&quot;, &quot;bb&quot;, &quot;xxxx&quot;, &quot;z&quot; 和 &quot;yy&quot; 这样的一些分组。 我们称所有包含大于或等于三个连续字符的分组为较大分组。找到每一个较大分组的起始和终止位置。 最终结果按照字典顺序输出。 示例 1: 123输入: &quot;abbxxxxzzy&quot;输出: [[3,6]]解释: &quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。 示例 2: 123输入: &quot;abc&quot;输出: []解释: &quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。 示例 3: 12输入: &quot;abcdddeeeeaabbbcd&quot;输出: [[3,5],[6,9],[12,14]] 说明: 1 &lt;= S.length &lt;= 1000 2、解题思路​ 1234567891011121314151617181920212223242526class Solution: def largeGroupPositions(self, S): """ :type S: str :rtype: List[List[int]] """ if S is None: return [] result = [] current_index = 0 current_count = 0 current_char = S[0] for i, c in enumerate(S): if current_char == c: current_count += 1 else: current_char = c if current_count &gt;= 3: result.append([current_index, current_index + current_count - 1]) current_index = i current_count = 1 if current_count &gt;= 3: result.append([current_index, current_index + current_count - 1]) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 832. 翻转图像]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20832.%C2%A0%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1: 1234输入: [[1,1,0],[1,0,1],[0,0,0]]输出: [[1,0,0],[0,1,0],[1,1,1]]解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2: 1234输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 说明: 1 &lt;= A.length = A[0].length &lt;= 20 0 &lt;= A[i][j] &lt;= 1 2、解题思路​ 12345678910class Solution: def flipAndInvertImage(self, A): """ :type A: List[List[int]] :rtype: List[List[int]] """ result = [] for i in A: result.append([1 if v == 0 else 0 for v in reversed(i)]) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 836. 矩形重叠]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20836.%C2%A0%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。 给出两个矩形，判断它们是否重叠并返回结果。 示例 1： 12输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]输出：true 示例 2： 12输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]输出：false 说明： 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。 矩形中的所有坐标都处于 -10^9 和 10^9 之间。 2、解题思路​ 这个题目最好使用反向思考，例如，判断不相交，如果没出现不想交的情况，表示相交 1234567891011class Solution: def isRectangleOverlap(self, rec1, rec2): """ :type rec1: List[int] :type rec2: List[int] :rtype: bool """ if rec1[1] &gt;= rec2[3] or rec1[3] &lt;= rec2[1] or rec1[0] &gt;= rec2[2] or rec1[2] &lt;= rec2[0]: return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 840. 矩阵中的幻方]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20840.%C2%A0%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%BB%E6%96%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述3 x 3 的幻方是一个填充有从 1 到 9 的不同数字的 3 x 3 矩阵，其中每行，每列以及两条对角线上的各数之和都相等。 给定一个由整数组成的 N × N 矩阵，其中有多少个 3 × 3 的 “幻方” 子矩阵？（每个子矩阵都是连续的）。 示例 1: 12345678910111213141516输入: [[4,3,8,4], [9,5,1,9], [2,7,6,2]]输出: 1解释: 下面的子矩阵是一个 3 x 3 的幻方：438951276而这一个不是：384519762总的来说，在本示例所给定的矩阵中只有一个 3 x 3 的幻方子矩阵。 提示: 1 &lt;= grid.length = grid[0].length &lt;= 10 0 &lt;= grid[i][j] &lt;= 15 2、解题思路​ 首先，不断地取出3*3的矩阵，用来判断是不是幻方 ​ 在判断的时候，首先，判断有没有重复数字，有的话，直接返回False 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def numMagicSquaresInside(self, grid): """ :type grid: List[List[int]] :rtype: int """ row = len(grid) col = len(grid[0]) result = 0 nine_num = [] for i in range(row): if i + 2 &lt; row: for j in range(col): if j + 2 &lt; col: nine_num.clear() nine_num.append(grid[i][j:j + 3]) nine_num.append(grid[i + 1][j:j + 3]) nine_num.append(grid[i + 2][j:j + 3]) if self.isMagic(nine_num): result += 1 return result def isMagic(self, grid): nums = set([1, 2, 3, 4, 5, 6, 7, 8, 9]) nums_grid = set(grid[0] + grid[1] + grid[2]) if len(nums_grid) &lt; 9 or nums.difference(nums_grid) != set() : return False total = sum(grid[0]) if sum(grid[1]) != total or sum(grid[2]) != total: return False if sum([v[0] for v in grid]) != total or sum([v[0] for v in grid]) != total or sum( [v[0] for v in grid]) != total: return False if sum([grid[0][0], grid[1][1], grid[2][2]]) != total or sum([grid[0][2], grid[1][1], grid[2][0]]) != total: return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 844. 比较含退格的字符串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20844.%20%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述1234567891011121314151617181920212223242526272829给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。示例 1：输入：S = &quot;ab#c&quot;, T = &quot;ad#c&quot;输出：true解释：S 和 T 都会变成 “ac”。示例 2：输入：S = &quot;ab##&quot;, T = &quot;c#d#&quot;输出：true解释：S 和 T 都会变成 “”。示例 3：输入：S = &quot;a##c&quot;, T = &quot;#a#c&quot;输出：true解释：S 和 T 都会变成 “c”。示例 4：输入：S = &quot;a#c&quot;, T = &quot;b&quot;输出：false解释：S 会变成 “c”，但 T 仍然是 “b”。 提示：1 &lt;= S.length &lt;= 2001 &lt;= T.length &lt;= 200S 和 T 只含有小写字母以及字符 &apos;#&apos;。 2、 解题思路2.1 从后向前递推法​ 因为字符串中仅包含退格键和小写字母，而退格键则是取消掉前面的一个字符，如果是多个退格键，则取消多个字符 ​ 基本思路就是，从右面向左进行比较，判断出现去掉退格键的影响以后的第一个字符是什么，如果第一个字符相同，继续判断下一个 ​ 直到出现不相同的或者字符串比较完毕，返回结果 12345678910111213141516171819202122232425262728293031323334353637char findFisrtCharForBackspaceString(char *s, int *length) &#123; int backspaces = 0; char temp = 0; while (!temp &amp;&amp; *length &gt; 0) &#123; if (s[*length - 1] == '#') &#123; backspaces++; (*length)--; &#125; else if (backspaces &gt; 0) &#123; (*length)--; backspaces--; &#125; else if (*length &gt;=1) &#123; temp = s[*length - 1]; &#125; else &#123; break; &#125; &#125; return temp;&#125;bool backspaceCompare(char *S, char *T) &#123; bool flag = true; int length_s = strlen(S); int length_t = strlen(T); while (length_s &gt; 0 || length_t &gt; 0) &#123; if (findFisrtCharForBackspaceString(S, &amp;length_s) != findFisrtCharForBackspaceString(T,&amp;length_t))&#123; flag = false; break; &#125; length_s--; length_t--; &#125; return flag;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 848. 字母移位]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20848.%20%E5%AD%97%E6%AF%8D%E7%A7%BB%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述有一个由小写字母组成的字符串 S，和一个整数数组 shifts。 我们将字母表中的下一个字母称为原字母的 移位（由于字母表是环绕的， &#39;z&#39; 将会变成 &#39;a&#39;）。 例如·，shift(&#39;a&#39;) = &#39;b&#39;， shift(&#39;t&#39;) = &#39;u&#39;,， 以及 shift(&#39;z&#39;) = &#39;a&#39;。 对于每个 shifts[i] = x ， 我们会将 S 中的前 i+1 个字母移位 x 次。 返回将所有这些移位都应用到 S 后最终得到的字符串。 示例： 1234567输入：S = &quot;abc&quot;, shifts = [3,5,9]输出：&quot;rpl&quot;解释： 我们以 &quot;abc&quot; 开始。将 S 中的第 1 个字母移位 3 次后，我们得到 &quot;dbc&quot;。再将 S 中的前 2 个字母移位 5 次后，我们得到 &quot;igc&quot;。最后将 S 中的这 3 个字母移位 9 次后，我们得到答案 &quot;rpl&quot;。 提示： 1 &lt;= S.length = shifts.length &lt;= 20000 0 &lt;= shifts[i] &lt;= 10 ^ 9 2、解题思路12345678910111213class Solution: def shiftingLetters(self, S, shifts): """ :type S: str :type shifts: List[int] :rtype: str """ move = list(reversed(list(itertools.accumulate(reversed(shifts))))) for index, c in enumerate(S): S = S[:index] + chr((ord(c) - 97 + move[index]) % 26 + 97) + S[index + 1:] return S]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 849. 到最近的人的最大距离]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20849.%C2%A0%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。 至少有一个空座位，且至少有一人坐在座位上。 亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。 返回他到离他最近的人的最大距离。 示例 1： 123456输入：[1,0,0,0,1,0,1]输出：2解释：如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。因此，他到离他最近的人的最大距离是 2 。 示例 2： 12345输入：[1,0,0,0]输出：3解释： 如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。这是可能的最大距离，所以答案是 3 。 提示： 1 &lt;= seats.length &lt;= 20000 seats 中只含有 0 和 1，至少有一个 0，且至少有一个 1。 2、解题思路​ ​ 使用了基于字符串的想法，先把list变成字符串，然后通过1进行分割，第一个和最后一个单独判断，找出中间的连续最多的0的长度 ​ 12345678910111213141516171819202122class Solution: def maxDistToClosest(self, seats): """ :type seats: List[int] :rtype: int """ total = "".join([str(i) for i in seats]).split("1") left = total[0] right = total[len(total) - 1] if len(total[1:-1]) == 0: max_zeros = 0; else: max_zeros = len(max(total[1:-1], key=lambda x: len(x))) result = (max_zeros + 1) // 2 if left != "": result = max(result, len(left)) if right != "": result = max(result, len(right)) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 852. 山脉数组的峰顶索引]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20852.%C2%A0%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述我们把符合下列属性的数组 A 称作山脉： A.length &gt;= 3 存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1] 给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1] 的 i 的值。 示例 1： 12输入：[0,1,0]输出：1 示例 2： 12输入：[0,2,1,0]输出：1 提示： 3 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10^6 A 是如上定义的山脉 2、解题思路1234567class Solution: def peakIndexInMountainArray(self, A): """ :type A: List[int] :rtype: int """ return A.index(max(A)) ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 855. 考场就座]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20855.%C2%A0%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 在考场里，一排有 N 个座位，分别编号为 0, 1, 2, ..., N-1 。 ​ 当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。) ​ 返回 ExamRoom(int N) 类，它有两个公开的函数：其中，函数 ExamRoom.seat() 会返回一个 int （整型数据），代表学生坐的位置；函数 ExamRoom.leave(int p) 代表坐在座位 p 上的学生现在离开了考场。请确保每次调用 ExamRoom.leave(p) 时都有学生坐在座位 p 上。 示例： 12345678910输入：[&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]输出：[null,0,9,4,2,null,5]解释：ExamRoom(10) -&gt; nullseat() -&gt; 0，没有人在考场里，那么学生坐在 0 号座位上。seat() -&gt; 9，学生最后坐在 9 号座位上。seat() -&gt; 4，学生最后坐在 4 号座位上。seat() -&gt; 2，学生最后坐在 2 号座位上。leave(4) -&gt; nullseat() -&gt; 5，学生最后坐在 5 号座位上。 提示： 1 &lt;= N &lt;= 10^9 在所有的测试样例中 ExamRoom.seat() 和 ExamRoom.leave() 最多被调用 10^4 次。 调用 ExamRoom.leave(p) 时需要确保当前有学生坐在座位 p 上。 2、解题思路​ 首先确定一点，我们肯定需要存储已经坐下的位置 ​ 然后每次想要新的座位的时候，就需要查找最大的空位，然后放入， ​ 因此，使用list来存储已经坐下的位置，然后每一次需要查询一下，看看那个空位最大，然后返回 ​ 需要注意的是，第一个位置和最后一个位置，不需要除以2，中间位置的距离才需要除以2 ​ ==寻找座位== 判断作为是不是空，如果是，座位是0 如果不为空，第一个距离就是座位表里面的第一个数，位置是0， 从第二个数开始，每一次减去前面的那个数，除以2表示距离 如果距离变大，就更新位置和距离 判断完毕以后，跳出来判断最后一个位置 然后将位置假如座位表，并返回 ==离开座位== 需要注意的是，离开座位的时候，需要判断这个座位有没有人 12345678910111213141516171819202122232425262728293031323334import bisectclass ExamRoom(object): def __init__(self, N): self.N = N self.seats = [] def seat(self): if not self.seats: pos = 0 else: dist, pos = self.seats[0], 0 for i, s in enumerate(self.seats): if i: prev = self.seats[i-1] d = (s - prev) // 2 if d &gt; dist: dist, pos = d, prev + d # Considering the right-most seat. d = self.N - 1 - self.seats[-1] if d &gt; dist: pos = self.N - 1 bisect.insort(self.seats, pos) return pos def leave(self, p): if self.seats.count(p) != 0: self.seats.remove(p)# Your ExamRoom object will be instantiated and called as such:# obj = ExamRoom(N)# param_1 = obj.seat()# obj.leave(p)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 859. 亲密字符串]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20859.%C2%A0%E4%BA%B2%E5%AF%86%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。 示例 1： 12输入： A = &quot;ab&quot;, B = &quot;ba&quot;输出： true 示例 2： 12输入： A = &quot;ab&quot;, B = &quot;ab&quot;输出： false 示例 3: 12输入： A = &quot;aa&quot;, B = &quot;aa&quot;输出： true 示例 4： 12输入： A = &quot;aaaaaaabc&quot;, B = &quot;aaaaaaacb&quot;输出： true 示例 5： 12输入： A = &quot;&quot;, B = &quot;aa&quot;输出： false 提示： 0 &lt;= A.length &lt;= 20000 0 &lt;= B.length &lt;= 20000 A 和 B 仅由小写字母构成。 2、解题思路​ 这道题实际上考察的很简答， 首先判断，如果两个字符串长度不一致，直接返回false 长度一致的情况下，判断有几个位置的字符不一致 如果是2个，判断这两个交换以后是不是相同的，如果是，返回True 如果字符全部一致，判断是不是有两个相同的字符，有则返回True 其他情况返回False 12345678910111213141516171819202122232425262728293031class Solution: def buddyStrings(self, A, B): """ :type A: str :type B: str :rtype: bool """ length_a = len(A) length_b = len(B) if length_a != length_b: return False buff = &#123;&#125; buff_count = &#123;&#125; for i in range(length_a): if A[i] != B[i]: buff[i] = (A[i], B[i]) if buff_count.get(A[i]) is None: buff_count[A[i]] = 1 else: buff_count[A[i]] += 1 if len(buff) == 0: if len(buff_count) &gt; 0 and max(buff_count.values()) &gt;= 2: return True if len(buff) == 2: temp = list(buff.values()) if sorted(temp[0]) == sorted(temp[1]): return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 86. 分隔链表]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2086.%C2%A0%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 12输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 2、解题思路​ 分成两个链表，第一个链表保存小于x的所有节点 ​ 第二个链表保存大于等于x的链表 ​ 然后将两个链表合并即可 12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def partition(self, head, x): """ :type head: ListNode :type x: int :rtype: ListNode """ if not head or not head.next: return head less = ListNode(0) less_p = less big_equal_than = ListNode(0) big_equal_p = big_equal_than temp = head while temp: if temp.val &lt; x: less_p.next = temp less_p = less_p.next else: big_equal_p.next = temp big_equal_p = big_equal_p.next temp = temp.next less_p.next = big_equal_than.next big_equal_p.next = None return less.next]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 862. 和至少为 K 的最短子数组]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20862.%20%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。 如果没有和至少为 K 的非空子数组，返回 -1 。 示例 1： 12输入：A = [1], K = 1输出：1 示例 2： 12输入：A = [1,2], K = 4输出：-1 示例 3： 12输入：A = [2,-1,2], K = 3输出：3 提示： 1 &lt;= A.length &lt;= 50000 -10 ^ 5 &lt;= A[i] &lt;= 10 ^ 5 1 &lt;= K &lt;= 10 ^ 9 2、解题思路​ 一开始，直接想到暴力破解法，直接算出从位置0到当前位置的和，然后每个位置遍历一遍，减去从位置0一直到当前位置的差值，如果能够满足条件，更新结果 ​ 这种暴力破解法，超出了时间限制 ​ 后来又想通过动态规划来做，以前做过一道题，叫做最大子序列和，也就是找出子序列中，最大的连续的和是多少，不过这道题反其道而行之，找出最小的满足条件的值， ​ ​ 换个思路，使用滑动窗口的办法，首先，设置两个指针，一个纸箱滑动窗口左面，一个纸箱右面，还有一个和，表示当前窗口的和 如果和小于K，就将r右移 如果和小于0，将左指针和右指针一块移动，重新开始 如果当前和大于k，左指针右移 每一次遇到和大于K的情况，都更新result ​ 在写代码的时候，遇到一个问题，就是如果在左面的指针向右移动的时候，如果说已经判断当前窗口的值小于K，就继续移动right，实际上这样不行，因为前面可能还有负数，也就是说，left并没有移动到对应的位置上去 ​ 所以，每一次找到的时候，我们需要将这个子数组前面所有的都尝试减去一遍，得到满足的值就更新result，并且，还需要将left放到对应的位置上去 ​ 我们设置两个指针，一个是在这个过程中，left向右移动，最后一个满足和的要求的left，另一个则是在right处向左寻找，找到不为0的那个值，直到left结束 ​ ​ 这种思路，与求解最大子序列和有相似的地方，也有一点不同，最大子序列和并不需要移动左指针，只需要在和小于0的时候移动， ​ 所以，从这里可以看出来，凡是寻找连续子数组的情况，都能够用滑动窗口来解决 ​ 哎，没想到，滑动窗口也超过时间限制了，再换一种 2.1 暴力破解法123456789101112131415161718192021222324252627282930313233import itertoolsclass Solution: def shortestSubarray(self, A, K): """ :type A: List[int] :type K: int :rtype: int """ order_sums = list(itertools.accumulate(A)) print(order_sums) result = 100000 for i in range(len(A)): if result &lt;= 1: break if order_sums[i] &gt;= K: result = min(result, i + 1) for j in range(i): if order_sums[i] - order_sums[j] &gt;= K and i - j &lt; result: result = i - j if result == 100000: return -1 else: return resulta = Solution()print(a.shortestSubarray([77, 19, 35, 10, -14], 19)) ​ 暴力破解法超过了时间限制 2.2 滑动窗口法​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution: def shortestSubarray(self, A, K): """ :type A: List[int] :type K: int :rtype: int """ left = 0 right = -1 windows_sum = 0 length = len(A) result = length + 1 max_value = -100000000 temp_sum = 0 temp_left = 0 while left &lt; length: if right + 1 &lt; length and windows_sum &lt; K: right += 1 windows_sum += A[right] else: windows_sum -= A[left] left += 1 temp_sum = 0 max_value = -100000000 temp_left = left for i in range(right, left - 1, -1): temp_sum += A[i] if temp_sum &gt; max_value: max_value = temp_sum temp_left = i windows_sum = max_value left = temp_left if windows_sum &gt;= K: result = min(result, right - left + 1) elif windows_sum &lt; 0: left = right + 1 windows_sum = 0 if result == length + 1: return -1 return result ​ 哎，这个方法也超过时间限制了 2.3 滑动窗口改进​ 实际上，前面的方法还是有点复杂，实际上，同样是滑动窗口，并不一定非得要在原来的数组上滑动，也可以在我们构造的累加和数组上滑动 ​ 例如，构造一个数组，如果right指向的数减去left指向的数能够大于等于K，更新结果值 ​ 借助双端队列，我们在队列中，保存前面没有判断过的，并且比当前的累积和小的累加和，进行判断，判断完毕以后，就将最小的那个弹出，因为用不到了，还需要向后判断，距离会变大，所以最左端的就用不到了 ​ 注意，双端队列里面保存的是索引值，这样才计算结果值 ​ 构造和数列的时候，在前面放置一个0，这样我们才能得到与第一个元素的差值 例如[1,2,3] 和数列 [1,3,6] ​ 如果我们不放置一个0在前面，就会发现我们用3-1，6-1，得到的是第2个元素，第2，3元素之和，无法得到第0元素之和 ​ 所以，放置一个0才可以 ​ 这一次时间没有超过限制 1234567891011121314151617181920212223242526272829303132import collectionsclass Solution: def shortestSubarray(self, A, K): """ :type A: List[int] :type K: int :rtype: int """ length = len(A) result = length + 1 if length &lt;= 0: return 0 sums = [0] + list(itertools.accumulate(A)) less_than = collections.deque() for index, cur_sum in enumerate(sums): while less_than and cur_sum &lt;= sums[less_than[-1]]: less_than.pop() while less_than and cur_sum - sums[less_than[0]] &gt;= K: result = min(result, index - less_than[0]) less_than.popleft() less_than.append(index) if result == length + 1: return -1 else: return result ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 860. 柠檬水找零]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20860.%20%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5美元。 注意，一开始你手头没有任何零钱。 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例 1： 1234567输入：[5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2： 12输入：[5,5,10]输出：true 示例 3： 12输入：[10,10]输出：false 示例 4： 1234567输入：[5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 0 &lt;= bills.length &lt;= 10000 bills[i] 不是 5 就是 10 或是 20 2、解题思路​ 这道题是简单题，只要保存5，10，20有几张就好了 ​ 如果收到的是5圆的，直接放入，数量加一 ​ 如果收到10圆的，判断手里有没有至少一张5圆的，有的话，10元加一，5元减一 ​ 如果收到20，判断手里能不能找到15元，也就是10+5，5+5+5，找到的话，放入20，减少15 ​ 不能找零，返回假 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def lemonadeChange(self, bills): """ :type bills: List[int] :rtype: bool """ buff = &#123;&#125; if len(bills) == 0: return True if bills[0] != 5: return False for i in bills: if i == 5: if buff.get(5) is None: buff[5] = 1 else: buff[5] += 1 elif i == 10: if buff.get(5) is not None and buff[5] &gt;= 1: buff[5] -= 1 if buff.get(10) is None: buff[10] = 1 else: buff[10] += 1 else: return False else: if buff.get(10) is not None and buff.get(5) is not None and buff[10] &gt;= 1 and buff[5] &gt;= 1: buff[10] -= 1 buff[5] -= 1 if buff.get(20) is None: buff[20] = 1 else: buff[20] += 1 elif buff.get(5) is not None and buff[5] &gt;= 3: buff[5] -= 3 if buff.get(20) is None: buff[20] = 1 else: buff[20] += 1 else: return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 866. 具有所有最深结点的最小子树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20866.%20%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。 如果结点具有最大深度，则该结点是最深的。 返回具有最大深度的结点，以该结点为根的子树中包含所有最深的结点。 示例： 1234567891011输入：[3,5,1,6,2,0,8,null,null,7,4]输出：[2,7,4]解释：我们返回值为 2 的结点，在图中用黄色标记。在图中用蓝色标记的是树的最深的结点。输入 &quot;[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]&quot; 是对给定的树的序列化表述。输出 &quot;[2, 7, 4]&quot; 是对根结点的值为 2 的子树的序列化表述。输入和输出都具有 TreeNode 类型。 提示： 树中结点的数量介于 1 和 500 之间。 2、解题思路​ 这道题一开始没有理解思路，就是如果只有一个深度最深的节点，直接返回就好了 ​ 如果有多个，那么那个节点的子树能够包含这两个，就返回这个节点 ​ 当然，根节点肯定是包含的 ​ 可以这样分析，如果左子树的深度等于右子树的深度，就返回根节点 ​ 如果左子树的深度大于右子树的深度，抛弃右子树，重新判断左子树即可 ​ 最终得到的就是左右子树深度一致的节点，并且包含最深的节点 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def subtreeWithAllDeepest(self, root): """ :type root: TreeNode :rtype: TreeNode """ if not root: return root if self.dfs(root.left) == self.dfs(root.right): return root elif self.dfs(root.left) &gt; self.dfs(root.right): return self.subtreeWithAllDeepest(root.left) else: return self.subtreeWithAllDeepest(root.right) def dfs(self, node): if not node: return 0 return max(self.dfs(node.left) + 1, self.dfs(node.right) + 1)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 867. 回文素数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20867.%20%E5%9B%9E%E6%96%87%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述求出大于或等于 N 的最小回文素数。 回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是素数。 例如，2，3，5，7，11 以及 13 是素数。 回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是回文数。 例如，12321 是回文数。 示例 1： 12输入：6输出：7 示例 2： 12输入：8输出：11 示例 3： 12输入：13输出：101 提示： 1 &lt;= N &lt;= 10^8 2、解题思路​ 这道题的基本思路就是，构造不小于N的回文数，判断是不是质数，如果是，就返回 ​ 关键点在于构造回文数 ​ 这里使用的是回文长度的思路 ​ 例如现在构造3位的回文数，基准值是10，第一个回文就是101 ​ 然后是111 ​ 如果构造4位的回文，基准值是10，第一个回文是1001，第二个是1111，以此类推 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import mathclass Solution: def primePalindrome(self, N): &quot;&quot;&quot; :type N: int :rtype: int &quot;&quot;&quot; p = str(N) p_length = len(p) base_num = 10 ** ((p_length - 1) // 2) if base_num == 1: base_num = 0 while True: judge_num = self.buildPalindrome(base_num, p_length) if judge_num &gt;= N: if self.isPrime(judge_num): return judge_num if len(str(base_num + 1)) &gt; len(str(base_num)): p_length += 1 base_num = 10 ** ((p_length - 1) // 2) else: base_num += 1 def buildPalindrome(self, num, p_length): s = str(num) if p_length % 2 == 0: result = int(s + &quot;&quot;.join(list(reversed(s)))) else: result = int(s[:-1] + s[-1] + &quot;&quot;.join(list(reversed(s[:-1])))) return result def isPrime(self, num): if num &lt;= 1: return False if num == 2: return True a = math.ceil(math.sqrt(num)) for i in range(2, a + 1): if num % i == 0: return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 868. 转置矩阵]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20868.%20%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个矩阵 A， 返回 A 的转置矩阵。 矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 示例 1： 12输入：[[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]] 示例 2： 12输入：[[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]] 2、解题思路​ 这个题目很简单，直接构造目标数组，然后对应的赋值即可，只不过横坐标和纵坐标是相反的 123456789101112131415161718class Solution(object): def transpose(self, A): """ :type A: List[List[int]] :rtype: List[List[int]] """ row = len(A) if row &lt;= 0: return A col = len(A[0]) result = [[0] * row for i in range(col)] for i in range(col): for j in range(row): result[i][j] = A[j][i] return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 868. 二进制间距]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20868.%C2%A0%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%B4%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个正整数 N，找到并返回 N 的二进制表示中两个连续的 1 之间的最长距离。 如果没有两个连续的 1，返回 0 。 示例 1： 12345678输入：22输出：2解释：22 的二进制是 0b10110 。在 22 的二进制表示中，有三个 1，组成两对连续的 1 。第一对连续的 1 中，两个 1 之间的距离为 2 。第二对连续的 1 中，两个 1 之间的距离为 1 。答案取两个距离之中最大的，也就是 2 。 示例 2： 1234输入：5输出：2解释：5 的二进制是 0b101 。 示例 3： 1234输入：6输出：1解释：6 的二进制是 0b110 。 示例 4： 12345输入：8输出：0解释：8 的二进制是 0b1000 。在 8 的二进制表示中没有连续的 1，所以返回 0 。 提示： 1 &lt;= N &lt;= 10^9 2、解题思路​ 题目其实很简单，只需要一遍扫描即可 判断当前位置是不是1，如果是，更新间距（第一个1不需要更新） 一直向后判断，判断32次即可 123456789101112131415161718class Solution: def binaryGap(self, N): """ :type N: int :rtype: int """ result = 0 cur = -1 first = False for i in range(32): if N &amp; (1 &lt;&lt; i) != 0: if first: result = max(result, i - cur) else: first = True cur = i return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 872. 叶子相似的树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20872.%C2%A0%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述考虑一个二叉树的所有叶子。这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。 举个例子，给定一个如上图所示的树，其叶值序列为 (6, 7, 4, 9, 8) 。 如果两个二叉树的叶值序列相同，我们就认为它们是 叶相似的。 如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，返回 true；否则返回 false 。 提示： 给定的两个树会有 1 到 100 个结点。 2、解题思路​ 使用深度优先搜索，判断如果当前节点是叶子节点，节加入到结果数组中 如果结果数组长度一致，继续判断，不一致返回False 123456789101112131415161718192021222324252627282930313233343536# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def leafSimilar(self, root1, root2): """ :type root1: TreeNode :type root2: TreeNode :rtype: bool """ self.buff = [] self.dfs(root1) temp1 = self.buff.copy() self.buff = [] self.dfs(root2) if len(temp1) != len(self.buff): return False else: for i in range(len(temp1)): if temp1[i] != self.buff[i]: return False return True def dfs(self, root): if not root: return if not root.left and not root.right: self.buff.append(root.val) self.dfs(root.left) self.dfs(root.right)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 874. 行走机器人模拟]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20874.%C2%A0%E8%A1%8C%E8%B5%B0%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述无限网格上的机器人从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令： -2：向左转 90 度 -1：向右转 90 度 1 &lt;= x &lt;= 9：向前移动 x 个单位长度 有一些网格方块被视作障碍物。 第 i 个障碍物位于网格点 (obstacles[i][0], obstacles[i][1]) 如果机器人试图走到障碍物上方，那么它将停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。 返回从原点到机器人的最大欧式距离的平方。 示例 1： 123输入: commands = [4,-1,3], obstacles = []输出: 25解释: 机器人将会到达 (3, 4) 示例 2： 123输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]输出: 65解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处 提示： 0 &lt;= commands.length &lt;= 10000 0 &lt;= obstacles.length &lt;= 10000 -30000 &lt;= obstacle[i][0] &lt;= 30000 -30000 &lt;= obstacle[i][1] &lt;= 30000 答案保证小于 2 ^ 31 2、解题思路​ 首先，我们使用下面的变量保存方向 12345678direct : 0 东 1 南 2 西 3 北 (direct + 1 + 4 )% 4 ： 表示右转(direct - 1 + 4 )% 4 ： 表示左转 然后就需要根据方向，还有步伐，加减，只要前方没有障碍物，继续走 最后返回坐标平方和 ​ 因为障碍物的list不好查询，我们转换成dict ​ 要注意一点，返回的是最大欧式距离平方，也就是距离原点最远距离的位置， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution: def robotSim(self, commands, obstacles): """ :type commands: List[int] :type obstacles: List[List[int]] :rtype: int """ obstacles_dict = &#123;tuple(v): i for i, v in enumerate(obstacles)&#125; start_x = 0 start_y = 0 direct = 3 result = 0 for i in commands: if i == -1: direct = (direct + 1 + 4) % 4 elif i == -2: direct = (direct - 1 + 4) % 4 else: temp = i while temp &gt; 0: if direct == 0: if (start_x + 1, start_y) not in obstacles_dict: start_x += 1 else: break elif direct == 1: if (start_x, start_y - 1) not in obstacles_dict: start_y -= 1 else: break elif direct == 2: if (start_x - 1, start_y) not in obstacles_dict: start_x -= 1 else: break else: if (start_x, start_y + 1) not in obstacles_dict: start_y += 1 else: break temp -= 1 result = max(result, start_x ** 2 + start_y ** 2) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 876. 链表的中间结点]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20876.%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 12345输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 123输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 2、解题思路​ 统计一共有多少节点 然后找到中间节点的位置 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def middleNode(self, head): """ :type head: ListNode :rtype: ListNode """ temp = head count = 0 while temp: count += 1 temp = temp.next count = count // 2 + 1 res = head while count &gt; 1: res = res.next count -= 1 return res ​ 这道题虽然是简单题，不过也太简单了点]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 88. 合并两个有序数组]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2088.%C2%A0%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 2、解题思路​ 第二个数组，从后向前，依次找到插入的位置 1234567891011121314151617void merge(int* nums1, int m, int* nums2, int n) &#123; int pos = m; int insert = pos - 1; for (int i = 0; i &lt; n; i++) &#123; while (insert &gt;= 0) &#123; if (nums2[i] &lt; nums1[insert]) &#123; nums1[insert+1] = nums1[insert]; &#125; else&#123; break; &#125; insert--; &#125; nums1[insert + 1] = nums2[i]; pos++; insert = pos - 1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 89. 格雷编码]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2089.%C2%A0%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 示例 1: 123456789101112131415输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1 示例 2: 12345输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 2、解题思路​ 实际上题目很简单，找一下规律就好了 ​ 如果是n位的格雷编码，一共是$2^n$项 实际上，有这样的规律 1位的格雷编码，是这样的 0 1 两位的格雷编码是这样的： 00 01 11 10 3位的格雷编码是这样的 000 001 011 010 110 111 101 100 规律就是，每增加一位，格雷编码扩大两倍，并且，前面的一半与n-1为的相同，后面的则是在前面的基础上增加1，并且倒序输出即可 所以，我们就能得到4位的格雷编码了 00000001001100100110011101010100 （先把3位的复制过来，前面加0） 11001101111111101010101110011000 然后是在前面加一，并且复制过来，倒序即可 题目里面描述的两种，实际上是初始的1位的情况，有两种： 1201 1210 由此，不断迭代出来的就有两种情况了 12345678910111213141516class Solution: def grayCode(self, n): """ :type n: int :rtype: List[int] """ if n == 0: return [0] result = [0, 1] for i in range(1, n): for j in range(2 ** i - 1, -1, -1): result.append(result[j] ^ (1 &lt;&lt; i)) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 9. 回文数]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%209.%C2%A0%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述12345678910111213141516171819Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.Example 1:Input: 121Output: trueExample 2:Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.Example 3:Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome.Follow up:Coud you solve it without converting the integer to a string? 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 2、解题思路2.1 按位比较​ 首先判断一共有多少位，例如123，1234，分别是3，4位，实际上，我们只需要比较位数的一般，也就是3位的，比较1次，4位的比较两次 1234567891011121314151617181920212223242526272829303132333435bool isPalindrome(int x) &#123; if (x&lt;0)&#123; return false; &#125; int nums = 1; int temp = x; bool flag = true; int left_num, right_num; if (x &lt; 10) &#123; return true; &#125; while ((temp = temp / 10) &gt; 0) &#123; nums++; &#125; for (int i = 0, j = 1; i &lt; nums / 2; i++) &#123; left_num = right_num = x; while (nums - i - j++ &gt; 0) &#123; left_num /= 10; &#125; left_num %= 10; j = i; while (j-- &gt; 0) &#123; right_num /= 10; &#125; right_num %= 10; j = 1; if (left_num != right_num) &#123; flag = false; break; &#125; &#125; return flag;&#125; 2.2 按位取（减少计算量）​ 上面的方式是按照位数取得，下面按照同时得到最高位的阶数，也就是$10^n$ 123456789101112131415161718192021222324252627bool isPalindrome(int x) &#123; if (x &lt; 0) &#123; return false; &#125; else if (x &lt; 10) &#123; return true; &#125; int div = 1; int nums = 1; int temp = x; bool flag = true; while ((temp = temp / 10) &gt; 0) &#123; nums++; div *= 10; &#125; for (int i = 0; i &lt; nums / 2; i++) &#123; if (((x / div) %10) != (x % 10))&#123; flag = false; break; &#125; x /=10; div /=100; &#125; return flag;&#125; ​ 有一点可以注意一下，在leetcode上提交的运行时间不一定就很准，第一次提交需要124ms，第二次就用了104ms，上面的按理说会多一些，大约120ms左右； 2.3 整数比较​ 前面是按照每一位进行比较，实际上有些慢，如果直接取出多位，直接比较数字，会快很多 ​ 后面的几位很好取出来，前面的就不太好取出来，需要反着取出来 1234567891011121314151617181920212223242526272829303132333435363738394041bool isPalindrome(int x) &#123; if (x &lt; 0) &#123; return false; &#125; else if (x &lt; 10) &#123; return true; &#125; int div_left = 1; int div_right = 1; int nums = 1; int temp = x; bool flag = true; int left_num = 0, right_num = 0; int i; while ((temp = temp / 10) &gt; 0) &#123; nums++; &#125; i = nums - (nums / 2); while (i-- &gt; 0) &#123; div_left *= 10; &#125; if ((nums % 2) == 0) &#123; div_right = div_left; &#125; else &#123; div_right = div_left / 10; &#125; left_num = x / div_left % 10; div_left *= 10; for (int i = 0; i &lt; nums / 2 - 1; i++) &#123; left_num = 10 * left_num + x / div_left % 10; div_left *= 10; &#125; right_num = x % (div_right); if (left_num != right_num) &#123; flag = false; &#125; return flag;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 90. 子集 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2090.%C2%A0%E5%AD%90%E9%9B%86%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个可能包含重复元素的整数数组 *nums*，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 12345678910输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] 2、解题思路​ 实际上，这道题与前面的子集并没有什么区别，只需要判断一下是不是重复的即可 ​ 借助实现的求解组合的函数 12345678910111213class Solution: def subsetsWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ hash_dict = &#123;&#125; for i in range(len(nums) + 1): for k in itertools.combinations(nums, i): hash_dict[tuple(sorted(k))] = 1 return [list(v) for v in hash_dict.keys()]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 91. 解码方法]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2091.%C2%A0%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述一条包含字母 A-Z 的消息通过以下方式进行了编码： 1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 123输入: &quot;12&quot;输出: 2解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2: 123输入: &quot;226&quot;输出: 3解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 2、解题思路​ 看到题目描述就能想到的就是深度遍历，每一次前进一个有效的字符，向下传递，直到全部解码，解码数加一 ​ 可惜的是，下面的递归方法耗费时间太长了，超出了时间限制 123456789101112131415161718192021222324class Solution: def numDecodings(self, s): """ :type s: str :rtype: int """ return self.dfs(s, 0) def dfs(self, s, index): if index &gt;= len(s): return 1 if ord(s[index]) &lt;= ord('0'): return 0 count = 0 if index &lt; len(s) - 1: if ord(s[index]) &lt;= ord('2') and ord(s[index + 1]) &lt;= ord('6') or ord(s[index]) &lt;= ord('1'): count += self.dfs(s, index + 2) count += self.dfs(s, index + 1) return count ​ 换个思路，这道题明显是后面的结果依赖于前面的结果，这与动态规划很相似，用动态规划做一下试试 ​ 关键是递推公式该是如何 ​ 结果数组：result ​ result[i] 表示，前i个字符的解码数量，所以result的长度是字符串长度+1 ​ 假如说当前字符的前面两个字符能够合并，表示前面的解码方式能够叠加，也就是说，i-2的字符的解码方式加上i-1的字符的解码方式， ​ 为什么能够叠加呢，因为i-2的字符与i-1的字符合并成一个，这样来说，我们看前面的解码方式，就有两个了 ​ 如果不能叠加在一起，就直接看前面的那个就好了，也就是i-1 1234567891011121314151617181920212223242526class Solution: def numDecodings(self, s): """ :type s: str :rtype: int """ length = len(s) if length == 0: return 0 result = [0 for i in range(length + 1)] result[0] = 1 for i in range(1, length + 1): if s[i - 1] == '0': result[i - 1] = 0 if i &gt;= 2 and (s[i - 2] == '1' or s[i - 2] == '2' and s[i - 1] &lt;= '6'): result[i] = result[i - 1] + result[i - 2] else: result[i] = result[i - 1] return result[length] ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 92. 反转链表 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2092.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 2、解题思路​ 设置两个指针，第一个指针先走m步然后两个指针一块走一面走，一面反转 ​ 考虑到头部的元素也可能反转，所以要在最前面添加一个节点，用来指向返回的头结点 ​ ​ 123456789101112131415161718192021222324252627282930313233343536373839class Solution: def reverseBetween(self, head, m, n): """ :type head: ListNode :type m: int :type n: int :rtype: ListNode """ prev = ListNode(0) result_head = prev prev.next = head temp = m while temp &gt; 1: prev = prev.next temp -= 1 first_reverse = prev.next first = prev.next second = first.next temp_node = second if temp_node: temp_node = first.next.next temp = n while temp - m &gt; 0: second.next = first first = second second = temp_node if temp_node: temp_node = temp_node.next temp -= 1 prev.next = first first_reverse.next = second return result_head.next ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 93. 复原IP地址]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2093.%C2%A0%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述​ 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 12输入: &quot;25525511135&quot;输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 2、解题思路​ 先想到的是深度优先搜索 ​ 每一次，取一个字符，2个字符，3个字符，分别判断，如果满足条件，继续判断 如果刚好用尽了所有字符，并且数组里面元素刚刚好4个，表示满足条件，加入结果数组 需要注意，如果有0，那么前两位不能是0 12345678910111213141516171819202122232425262728293031323334353637class Solution: def restoreIpAddresses(self, s): """ :type s: str :rtype: List[str] """ result = [] self.dfs(s, 0, [], result) return list(set(result)) def dfs(self, s, index, current, result): if index &gt;= len(s): if len(current) == 4: result.append(".".join(current)) return elif len(current) &gt;= 4: return temp = current[:] temp_num = int(s[index:index + 1]) if temp_num &lt;= 255 and (len(s) - index - 1) &lt;= (3 - len(current)) * 3: temp.append(s[index:index + 1]) self.dfs(s, index + 1, temp, result) temp = current[:] temp_num = int(s[index:index + 2]) if temp_num &lt;= 255 and s[index] != '0' and (len(s) - index - 2) &lt;= (3 - len(current)) * 3: temp.append(s[index:index + 2]) self.dfs(s, index + 2, temp, result) temp = current[:] temp_num = int(s[index:index + 3]) if temp_num &lt;= 255 and s[index:index + 2] != '00' and s[index] != '0' and (len(s) - index - 3) &lt;= ( 3 - len(current)) * 3: temp.append(s[index:index + 3]) self.dfs(s, index + 3, temp, result)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 94. 二叉树的中序遍历]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2094.%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 2、解题思路​ 一般二叉树的问题都能够用递归来解决，不过这个问题既然不用递归，就需要借助数据结构，例如栈来存储 前面尚未放到结果中的节点 123456789101112131415161718192021222324252627282930313233343536# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneimport queueclass Solution: def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ result = [] q = queue.deque() if root: q.append(root) judge = True while q: if judge and q[-1].left: q.append(q[-1].left) continue judge = False result.append(q[-1].val) if q[-1].right: q.append(q.pop().right) judge = True else: q.pop() return result ​ 一开始，没有用judge变量，发现陷入了死循环，然后分析了一下，发现，是因为我们将队列中的节点弹出，这时候就不应该是去判断左节点，不然那就会出现下面的情况 弹出左节点 发现有左节点，放入 这种情况是不对的 ​ 什么时候重新判断左节点呢？ 就是当放入新的右节点的时候，需要判断他有没有左节点]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 95. 不同的二叉搜索树 II]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2095.%C2%A0%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20II%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例: 1234567891011121314151617输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 2、解题思路​ 看到二叉树，首先想到的就是递归求解，不顾哦这个形式有一点特殊，特殊在哪里呢？ ​ 这个题目是典型的分治法，但是有一点不同，就在于，小问题之间需要相互组合求解，例如，确定一个根节点，但是左节点的可能性有多个，右节点的可能性也有多个，于是，同一个根节点，就有了几棵树 ​ 基本的解题思路是这样的 从1到n中，先确定根节点 假如确定了5，那么1-4中是他的左子树，6-n是右子树 左子树和右子树都有多个，这时候，相互之间的组合就有多个 12345678910111213141516171819202122232425262728293031323334# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def generateTrees(self, n): """ :type n: int :rtype: List[TreeNode] """ if n &lt;= 0: return [] return self.dfs(1, n) def dfs(self, left, right): result = [] if left &gt; right: result.append(None) return result for i in range(left, right + 1): for left_node in self.dfs(left, i - 1): for right_node in self.dfs(i + 1, right): root_node = TreeNode(i) root_node.left = left_node root_node.right = right_node result.append(root_node) return result]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 96. 不同的二叉搜索树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2096.%C2%A0%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 2、解题思路​ 这道题实际上就是前面95题的一个简化版，我呢只需要知道左右节点的数量即可 ​ 确定根节点，然后是左右子树种类相乘，然后乘以根节点的数量，直接返回即可 123456789101112131415161718192021class Solution: def generateTrees(self, n): """ :type n: int :rtype: List[TreeNode] """ if n &lt;= 0: return 0 return self.dfs(1, n) def dfs(self, left, right): if left &gt; right: return 1 result = 0 for i in range(left, right + 1): left_num = self.dfs(left, i - 1) right_num = self.dfs(i + 1, right) result = result + left_num * right_num return result ​ 遗憾的是，这种方法得到的结果超过了时间限制，那么需要换个思路 ​ 分析一下，一棵树，如果有4个节点，假设已经确定了根节点，那么左子树有几种情况，右子树有几种情况呢？ 3，0 2，1 1，2 0，3 ​ 假设我们已经知道了0，1，2，3个节点的树的组合方法，就能直接计算出来，而不需要用递归了 如果只有1个节点，左子树有0，右子树有0。所以，动态规划是从0开始的，到n结束，一共n+1 所以，4个节点的所有状态就是： [3] [0] + [2] [1] + [1] [2] + [0][3] 12345678910111213141516171819class Solution: def numTrees(self, n): """ :type n: int :rtype: int """ if n &lt;= 0: return 0 if n == 1: return 1 dp = [0 for i in range(n + 1)] dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): for j in range(i): dp[i] = dp[i] + dp[j] * dp[i - 1 - j] return dp[n] ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 98. 验证二叉搜索树]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2098.%C2%A0%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。 一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 / \ 1 3输出: true 示例 2: 123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 2、解题思路​ 假设左子树是二叉搜索树，右子树也是二叉搜索树，那么只要当前节点大于左子树的最大节点，小于右子树的最小节点即可 ​ 其实一个简单的做法，二叉搜索树的中序遍历是一个排序数组，如果使用中序遍历找到最后，每一个值都是大于前面的值，表示这就是二叉搜索树 ​ 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: prev = -1 res = True def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ self.dfs(root) return self.res def dfs(self, node): if node is not None: self.dfs(node.left) if self.prev != -1: if node.val &lt;= self.prev: self.res = False return self.prev = node.val self.dfs(node.right) ​ 需要注意的是，prev和res不能采用参数传递的方式，因为每个函数有自己的调用栈，会导致每次使用的都是之前的prev ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 10. 正则表达式匹配]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%2010.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述1234567891011121314151617181920212223242526272829303132333435363738394041424344给定一个字符串 (s) 和一个字符模式 (p)。实现支持 &apos;.&apos; 和 &apos;*&apos; 的正则表达式匹配。&apos;.&apos; 匹配任意单个字符。&apos;*&apos; 匹配零个或多个前面的元素。匹配应该覆盖整个字符串 (s) ，而不是部分字符串。说明:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。示例 1:输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。示例 2:输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: &apos;*&apos; 代表可匹配零个或多个前面的元素, 即可以匹配 &apos;a&apos; 。因此, 重复 &apos;a&apos; 一次, 字符串可变为 &quot;aa&quot;。示例 3:输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个(&apos;*&apos;)任意字符(&apos;.&apos;)。示例 4:输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: &apos;c&apos; 可以不被重复, &apos;a&apos; 可以被重复一次。因此可以匹配字符串 &quot;aab&quot;。示例 5:输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 2、解题思路2.1 递归法 先判断特殊情况，如果匹配规则是0，直接根据字符串返回结果 如果第2个字符不是*，就判断第一个字符是不是匹配，如果是，就从下一个字符和下一个 如果匹配规则第二个是*,那么就判断这个*过滤了几个字符 最后，判断剩下的规则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bool isMatch(char *s, char *p) &#123; int length_str = 0; int length_pattern = 0; int i = 0; while (s[i++]) &#123; length_str++; &#125; i = 0; while (p[i++]) &#123; length_pattern++; &#125; // 如果匹配规则的长度为0，如果字符串长度为0，返回真，否则返回假； if (length_pattern == 0) &#123; return (length_str == 0); &#125; // 如果匹配规则只有一个字符，判断字符串是否是1， // 两个字符是不是相等，或者匹配字符是'.' if (length_pattern == 1) &#123; return (length_str == 1 &amp;&amp; (s[0] == p[0] || p[0] == '.')); &#125; if (p[1] != '*') &#123; // 如果匹配规则第一个字符不是*,表示肯定会匹配到字符，这时候如果字符长度是0，返回假 if (length_str == 0) &#123; return false; &#125; // 这时候，判断第一个字符是否匹配，并判断后续的字符 return (s[0] == p[0] || p[0] == '.') &amp;&amp; isMatch(&amp;s[1], &amp;p[1]); &#125; // 如果规则第二个字符是*，这时候，就要判断，字符串不为空，如果字符串为空，就直接判断空字符串与后面的规则是不是匹配 // 还要判断第一个字符是不是匹配，如果不匹配，表示前面*将前面的过滤掉了，重新判断字符串与后面的规则的匹配情况 // 如果第一个字符匹配，判断匹配了几个字符 while ((s[0] != '\0') &amp;&amp; (s[0] == p[0] || p[0] == '.')) &#123; // 如果说这个*匹配了0个，那么就直接判断后面的是不是匹配 if (isMatch(s, &amp;p[2])) &#123; return true; &#125; // 如果*匹配了多个，判断匹配了几个 // 将s的指针向前移动一位，表示匹配了一个 // 这里需要判断的是，是不是将所有的s中的字符都匹配掉了，如果是的话，就要退出来 s = &amp;s[1]; &#125; // 这时候，知道*匹配了几个字符，判断后面的规则是否成立 return isMatch(s, &amp;p[2]);&#125; ​ 下面是一种化简形式，基本思路是相同的 12345if (!*p) return !*s;if (p[1] == '*') return isMatch(s, p+2) || (*p == '.' &amp;&amp; *s || *s == *p) &amp;&amp; isMatch(s+1, p);return (*s == *p || (*p == '.' &amp;&amp; *s)) &amp;&amp; isMatch(s+1, p+1); 2.2 动态规划​ 创建一个数组，用来存放中间结果 ​ 例如，字符串字符数是3，匹配字符是4，那么考虑到都可能是0的情况，也就是说，有下面的对应情况 字符数/匹配字符数 0 1 2 3 4 0 匹配 1 不匹配 2 不匹配 3 不匹配 ​ 如上表，我们知道，0个字符和0个匹配字符，肯定是匹配的 ​ 然后，如果匹配字符的第二个字符是”*”,也是会匹配的，由此得到下面的情况 字符数/匹配字符数 0 1 2 3 4 0 匹配 匹配 匹配 1 不匹配 2 不匹配 3 不匹配 ​ 第一列中，出列第一个，其他的都不会匹配，这是初始状况 ​ 剩下的就是不断地将匹配状况判断出来，并写入表格，直到得到最后一个，字符数是3，匹配字符数是4，这种情况是不是匹配 ​ 举个例子，&quot;abc&quot;和&quot;a*bc&quot; ，很明显这个是匹配的 ​ 下面就来计算一下 因为第二个匹配字符是*,，所以初始化的二维数组就如上面的所示 ​ 接下来，判断右下方的状况 ​ 1：1 因为这时候，需要判断的是前面的一个字符是不是匹配，也就是dp[0][0], 并且当前字符是相等的，或者匹配字符是”.“ （如果是奇数个匹配字符，肯定无法匹配0个字符） 字符数/匹配字符数 0 1 2 3 4 0 匹配 不匹配 匹配 不匹配 匹配 1 不匹配 匹配 匹配 2 不匹配 3 不匹配 接下来判断1：2 ​ 这时候需要判断几种情况，只要有一种能够匹配，就代表可以匹配到 *匹配了0个字符 匹配字符的第二个字符是* ,首先判断，匹配字符向前推2个，也就是看dp[1][0]，明显是不匹配的 * 匹配了一个字符 （向左看） 表示，如果不看*， 前面的字符能不能匹配 判断向前看一个匹配字符，也就是a，是不是和字符串的能够匹配，如果可以，表示能够匹配，明显在表格里面得到了 （向上看） 如果不看前面的一个字符，当前的匹配串不是能够匹配到，如果能的话，只需要判断*前面的字符能不能匹配到 然后判断1：3 ​ 因为匹配字符第三个字符是b，因此，只需要判断前面的一个，也就是dp[0][2], 也就是说，前面的匹配如果是成功的，那么看当前字符匹配是不是对的，如果是，那么就是匹配的 ​ 根据上面的规则，得到下面的矩阵： s：abc p：a*bc 字符数/匹配字符数 0 1 2 3 4 0 匹配 不匹配 匹配 不匹配 不匹配 1 不匹配 匹配 匹配 不匹配 不匹配 2 不匹配 不匹配 不匹配 匹配 不匹配 3 不匹配 不匹配 不匹配 不匹配 匹配 ​ 由此可见，最右下角的依赖于其他的元素进行判断，也就是动态规划的主要思想，依赖于前面的计算结果 ​ 不管什么样的规则，我们都能够找到这样的一个矩阵进行匹配 ​ 相比起递归调用的繁琐，动态规划要快 ​ 不过递归调用的思路要清晰很多 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include "string.h"bool isMatch(char *s, char *p) &#123; int length_str = (int) strlen(s); int length_pattern = (int) strlen(p); bool dp[length_str + 1][length_pattern + 1]; // 初始化边界条件，也就是第0列，第1行 int i; dp[0][0] = true; for (i = 1; i &lt; length_str + 1; i++) &#123; dp[i][0] = false; &#125; for (i = 1; i &lt; length_pattern + 1; i++) &#123; // 奇数个是不能匹配到0个字符的，因此为假 if (i % 2) &#123; dp[0][i] = false; &#125; // 当为偶数个的时候，判断隔着一个字符的那个位置，能不能匹配到，如果能，就能 else if (p[i - 1] == '*') &#123; dp[0][i] = dp[0][i - 2]; &#125; else &#123; dp[0][i] = false; &#125; &#125; // 接下来填充数组 for (i = 1; i &lt; length_str + 1; i++) &#123; for (int j = 1; j &lt; length_pattern + 1; ++j) &#123; if (p[j - 1] == '*') &#123; dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || (dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == '.')); &#125; else &#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.'); &#125; &#125; &#125; for (i = 0; i &lt; length_str + 1; i++) &#123; for (int j = 0; j &lt; length_pattern + 1; ++j) &#123; printf("%s\t", dp[i][j] ? "true" : "false"); &#125; printf("\n"); &#125; return dp[length_str][length_pattern];&#125;void print(int x) &#123; int num = 1; for (int i = 31; i &gt;= 0; i--) &#123; if (x &amp; (num &lt;&lt; i)) &#123; printf("1"); &#125; else &#123; printf("0"); &#125; &#125; printf("\n");&#125;int main() &#123; printf("string: %s\t \npattern: %s\t\nresult: %s\n", "abc", "ab*c", isMatch("abc", "a*bc") ? "true" : "false"); printf("string: %s\t \npattern: %s\t\nresult: %s\n", "aab", "c*a*b", isMatch("aab", "c*a*b") ? "true" : "false");&#125; 1234567891011121314151617/Users/zhangguohao/CLionProjects/untitled/cmake-build-debug/untitledtrue false true false false false true true false false false false false true false false false false false true string: abc pattern: ab*c result: truetrue false true false true false false false false true true false false false false false true false false false false false false true string: aab pattern: c*a*b result: trueProcess finished with exit code 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 155. 最小栈]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20155.%20%E6%9C%80%E5%B0%8F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 示例: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 2、解题思路2.1 关联数值法​ 正常情况，能够想到的就是直接将值存放到变量中，这样得到的每一次能够直接取得最小元素 ​ 但是，查询最小元素的时间却是$O(n)$ ​ ​ 考虑到进栈，出栈的情况，如果栈中每一个只都能够跟最小值关联，也就是能够直接计算处来最小值，就可以直接得到最小值 ​ 例如，正常的想法，我们将每一个数直接入栈，但是我们现在想要每一个值与最小值进行关联，怎么做呢，取差值，例如，当前的最小值是2，入栈的值是5，5-2=3，我们将3存放到栈中，如果想要得到栈顶元素，就用最小值加上3就能得到 实例 ​ 入栈顺序是 2，1，3，-1，5 第一个元素 ​ 最小值是2，栈顶值为0 第二个元素 ​ 栈顶值为 1- 2 = -1，因为小于0，表示新值小于最小值，需要更新最小值，最小值为当前的元素值，1 第三个元素 ​ 栈顶值为 3-1 = 2 ，大于零，表示最小值不用更新 第四个元素 ​ 栈顶值为 -1-1 = -2， 小于0，表示需要更新最小值，最小值为-1 第五个元素 ​ 栈顶值为5 - （-1） = 6，大于零，不用更新最小值 因此，栈中的元素值为 1230 -1 2 -2 6最小值为：2 1 1 -1 -1 当我们在push的时候，就根据上面的规则 如果需要pop的时候，需要判断这个值是大于零还是小于零，如果是大于零，表示不需要更新最小值，如果是小于零，就需要更新最小值 出栈 第五个元素 ​ 栈顶值大于零，表示不需要更新最小值，入股需要返回值，就用最小值计算 ​ 6 +（-1） = 5 第4个元素 ​ 栈顶值小于零，表示此处需要更新最小值，这时候，当前的最小值就是这个点的值 ​ 计算最小值 ​ -（-2）+ -1 = 1， 最小值更新为1 其他的以此类推 ==注意: 这个方法存在问题，会有数值计算的时候的问题，会超过int的限制== ​ 下面的程序是有一点bug的，问题出在边界条件上 ​ 如果当前最小值是2147483648, push 一个- 2147483648， 这时候，本来应该更新最小值的，但是，因为计算的限制，-2147483648 - 2147483648 = 1， 这样一来，就无法得到正确的结果了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include "stdio.h"#include "string.h"/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */typedef struct &#123; int size; int *stack; int min_value; int top_pos;&#125; MinStack;/** initialize your data structure here. */MinStack *minStackCreate(int maxSize) &#123; MinStack *minStack = (MinStack *) malloc(sizeof(MinStack)); minStack-&gt;min_value = INT32_MIN; minStack-&gt;top_pos = -1; minStack-&gt;stack = (int *) malloc(sizeof(int) * maxSize); minStack-&gt;size = maxSize; return minStack;&#125;void minStackPush(MinStack *obj, int x) &#123; if (!obj) &#123; return; &#125; // 初始化 if (obj-&gt;top_pos == -1) &#123; obj-&gt;min_value = x; obj-&gt;stack[++obj-&gt;top_pos] = 0; &#125; else if (obj-&gt;top_pos &lt; obj-&gt;size - 1) &#123; obj-&gt;stack[++obj-&gt;top_pos] = x - obj-&gt;min_value; // 如果小于零，表示需要更新最小值 if (obj-&gt;stack[obj-&gt;top_pos] &lt; 0) &#123; obj-&gt;min_value = x; &#125; &#125;&#125;void minStackPop(MinStack *obj) &#123; if (!obj || obj-&gt;top_pos &lt;= -1) &#123; return; &#125; // 判断栈顶的值 if (obj-&gt;stack[obj-&gt;top_pos] &lt; 0) &#123; obj-&gt;min_value = obj-&gt;min_value - obj-&gt;stack[obj-&gt;top_pos]; obj-&gt;top_pos--; &#125; else &#123; obj-&gt;top_pos--; &#125; if (obj-&gt;top_pos &lt;= -1) &#123; obj-&gt;min_value = INT32_MIN; &#125;&#125;int minStackTop(MinStack *obj) &#123; if (!obj || obj-&gt;top_pos &lt;= -1) &#123; return INT32_MIN; &#125; // 判断栈顶的值是不是小于零，是的话，就返回最小值即可 if (obj-&gt;stack[obj-&gt;top_pos] &lt; 0) &#123; return obj-&gt;min_value; &#125; else &#123; return obj-&gt;stack[obj-&gt;top_pos] + obj-&gt;min_value; &#125;&#125;int minStackGetMin(MinStack *obj) &#123; if (!obj || obj-&gt;top_pos &lt;= -1) &#123; return INT32_MIN; &#125; return obj-&gt;min_value;&#125;void minStackFree(MinStack *obj) &#123; if (obj) &#123; if (obj-&gt;stack) &#123; free(obj-&gt;stack); &#125; free(obj); &#125;&#125;/** * Your MinStack struct will be instantiated and called as such: * struct MinStack* obj = minStackCreate(maxSize); * minStackPush(obj, x); * minStackPop(obj); * int param_3 = minStackTop(obj); * int param_4 = minStackGetMin(obj); * minStackFree(obj); */void pprint(MinStack *s) &#123; printf("=====================\n"); for (int i = 0; i &lt; 4; i++) &#123; printf("%d\t", s-&gt;stack[i]); &#125; printf("\nmin value : %d\n", s-&gt;min_value); printf("=====================\n");&#125;int main() &#123; MinStack *s = minStackCreate(10); minStackPush(s, 2); minStackPush(s, 0); minStackPush(s, 3); minStackPush(s, 0); pprint(s); printf("%d\n", minStackGetMin(s)); minStackPop(s); printf("%d\n", minStackGetMin(s)); minStackPop(s); printf("%d\n", minStackGetMin(s)); minStackPop(s); printf("%d\n", minStackGetMin(s)); printf("==========\n"); printf("%d\n", INT32_MIN - INT32_MAX);&#125; 2.2 备用数组法​ 考虑到上面的问题，因此，使用一个数组专门存储最小值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113typedef struct &#123; int size; int *stack; int *min_value; int top_pos;&#125; MinStack;/** initialize your data structure here. */MinStack *minStackCreate(int maxSize) &#123; MinStack *minStack = (MinStack *) malloc(sizeof(MinStack) * maxSize); minStack-&gt;top_pos = -1; minStack-&gt;stack = (int *) malloc(sizeof(int) * maxSize); minStack-&gt;min_value = (int *) malloc(sizeof(int) * maxSize);; minStack-&gt;size = maxSize; return minStack;&#125;void minStackPush(MinStack *obj, int x) &#123; if (!obj) &#123; return; &#125; // 初始化 if (obj-&gt;top_pos == -1) &#123; obj-&gt;top_pos++; obj-&gt;min_value[obj-&gt;top_pos] = x; obj-&gt;stack[obj-&gt;top_pos] = x; &#125; else if (obj-&gt;top_pos &lt; obj-&gt;size - 1) &#123; obj-&gt;stack[++obj-&gt;top_pos] = x; if (obj-&gt;min_value[obj-&gt;top_pos - 1] &gt; x) &#123; obj-&gt;min_value[obj-&gt;top_pos] = x; &#125; else &#123; obj-&gt;min_value[obj-&gt;top_pos] = obj-&gt;min_value[obj-&gt;top_pos - 1]; &#125; &#125;&#125;void minStackPop(MinStack *obj) &#123; if (!obj || obj-&gt;top_pos &lt;= -1) &#123; return; &#125; // 栈顶减一 obj-&gt;top_pos--;&#125;int minStackTop(MinStack *obj) &#123; if (!obj || obj-&gt;top_pos &lt;= -1) &#123; return INT32_MIN; &#125; // 返回栈顶的值 return obj-&gt;stack[obj-&gt;top_pos];&#125;int minStackGetMin(MinStack *obj) &#123; if (!obj || obj-&gt;top_pos &lt;= -1) &#123; return INT32_MIN; &#125; return obj-&gt;min_value[obj-&gt;top_pos];&#125;void minStackFree(MinStack *obj) &#123; if (obj) &#123; if (obj-&gt;stack) &#123; free(obj-&gt;stack); &#125; if (obj-&gt;min_value) &#123; free(obj-&gt;min_value); &#125; free(obj); &#125;&#125;// MinStack* minStackCreate(int maxSize) &#123; // &#125;// void minStackPush(MinStack* obj, int x) &#123; // &#125;// void minStackPop(MinStack* obj) &#123; // &#125;// int minStackTop(MinStack* obj) &#123; // &#125;// int minStackGetMin(MinStack* obj) &#123; // &#125;// void minStackFree(MinStack* obj) &#123; // &#125;/** * Your MinStack struct will be instantiated and called as such: * struct MinStack* obj = minStackCreate(maxSize); * minStackPush(obj, x); * minStackPop(obj); * int param_3 = minStackTop(obj); * int param_4 = minStackGetMin(obj); * minStackFree(obj); */]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 378. 有序矩阵中第K小的元素]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode%2FLeetCode%3A%20378.%C2%A0%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 1、题目描述给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。请注意，它是排序后的第k小元素，而不是第k个元素。 示例: 12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,返回 13。 说明:你可以假设 k 的值永远是有效的, $1 ≤ k ≤ n^2$ 。 2、解题思路​ 有一种思路，我们能够直接判断当前值所处的范围 左上角的都是小于当前值的，右下角的都是大于当前值的，因此，我们就能够直接得到当前值在整个矩阵中所可能处于的位置 123(1,1) (2,4) (3,7)(2,4) (4,6) (6,8)(3,7) (6,8) (9,9) 假如我们想要找第8个元素，就判断(6,8)位置的数字 如果想要找第6个元素，就要判断(3,7),(4,6),(6,8)所处的位置 1234(1,1) (2,4) (3,7) (4,13)(2,4) (4,6) (6,8) (8,14)(3,7) (6,8) (9,9) (12,15)(4,13) (8,14) (12,15) (16,16) ​ 不过直接定位还是有一点麻烦 换个思路，我们设置n个指针，放在每一行中，然后，将他的坐标同时保存，并且，放入堆中 每一次取出一个最小的，然后将这个指针右移，如果指针溢出，就不将右面的数组添加进堆中 举个例子 123456789101112matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,首先，我们将第一列，也就是，1，10，12，连同坐标，放到一个堆里面：[(1, 0, 0), (10, 1, 0), (12, 2, 0)]然后我们取出最小的，(1,0,0),然后将5连同坐标放进去[(5, 0, 1), (12, 2, 0), (10, 1, 0)]然后重复上面的步骤，最后就得到第K个元素了 1234567891011121314151617181920class Solution: def kthSmallest(self, matrix, k): """ :type matrix: List[List[int]] :type k: int :rtype: int """ row = len(matrix) col = len(matrix[0]) heap = [(matrix[i][0], i, 0) for i in range(row)] heapq.heapify(heap) for i in range(k - 1): temp = heapq.heappop(heap) if temp[2] + 1 &lt; col: heapq.heappush(heap, (matrix[temp[1]][temp[2] + 1], temp[1], temp[2] + 1)) res = heapq.heappop(heap)[0] return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
